\section{Data on B\+E\+M3\+D surfaces}
\label{group__data}\index{Data on B\+E\+M3\+D surfaces@{Data on B\+E\+M3\+D surfaces}}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\bf B\+E\+M3\+D\+Mesh\+Data} $\ast$ {\bf bem3d\+\_\+mesh\+\_\+data\+\_\+new} ({\bf B\+E\+M3\+D\+Mesh} $\ast$m, gint n)
\item 
gint {\bf bem3d\+\_\+mesh\+\_\+data\+\_\+free} ({\bf B\+E\+M3\+D\+Mesh\+Data} $\ast$d)
\item 
{\bf B\+E\+M3\+D\+Mesh\+Data} $\ast$ {\bf bem3d\+\_\+mesh\+\_\+data\+\_\+sized\+\_\+new} (gint n, gint m)
\item 
gint {\bf bem3d\+\_\+mesh\+\_\+data\+\_\+clear} ({\bf B\+E\+M3\+D\+Mesh\+Data} $\ast$m)
\item 
gdouble $\ast$ {\bf bem3d\+\_\+mesh\+\_\+data\+\_\+get} ({\bf B\+E\+M3\+D\+Mesh\+Data} $\ast$m, gint i)
\item 
gint {\bf bem3d\+\_\+mesh\+\_\+data\+\_\+add} ({\bf B\+E\+M3\+D\+Mesh\+Data} $\ast$f, gint i, G\+Array $\ast$g)
\item 
gint {\bf bem3d\+\_\+mesh\+\_\+data\+\_\+write} ({\bf B\+E\+M3\+D\+Mesh\+Data} $\ast$f, F\+I\+L\+E $\ast$fp, gchar $\ast$header)
\item 
gint {\bf bem3d\+\_\+mesh\+\_\+data\+\_\+read} ({\bf B\+E\+M3\+D\+Mesh\+Data} $\ast$$\ast$f, F\+I\+L\+E $\ast$fp, gint width)
\item 
gint {\bf bem3d\+\_\+mesh\+\_\+data\+\_\+add\+\_\+node} ({\bf B\+E\+M3\+D\+Mesh\+Data} $\ast$m, gint i)
\item 
gint {\bf bem3d\+\_\+mesh\+\_\+data\+\_\+multiproc\+\_\+sum} ({\bf B\+E\+M3\+D\+Mesh\+Data} $\ast$m)
\item 
gint {\bf bem3d\+\_\+mesh\+\_\+data\+\_\+node\+\_\+number} ({\bf B\+E\+M3\+D\+Mesh\+Data} $\ast$d)
\item 
{\bf B\+E\+M3\+D\+Mesh\+Data} $\ast$ {\bf bem3d\+\_\+mesh\+\_\+data\+\_\+merge} ({\bf B\+E\+M3\+D\+Mesh\+Data} $\ast$f1, {\bf B\+E\+M3\+D\+Mesh\+Data} $\ast$f2, gboolean strict)
\item 
gint {\bf bem3d\+\_\+mesh\+\_\+data\+\_\+add\+\_\+mesh} ({\bf B\+E\+M3\+D\+Mesh\+Data} $\ast$d, {\bf B\+E\+M3\+D\+Mesh} $\ast$m)
\item 
gint {\bf bem3d\+\_\+mesh\+\_\+data\+\_\+write\+\_\+weights} ({\bf B\+E\+M3\+D\+Mesh\+Data} $\ast$f, F\+I\+L\+E $\ast$fp, gint $\ast$fields, gint nfields)
\end{DoxyCompactItemize}


\subsection{Detailed Description}


\subsection{Function Documentation}
\index{Data on B\+E\+M3\+D surfaces@{Data on B\+E\+M3\+D surfaces}!bem3d\+\_\+mesh\+\_\+data\+\_\+add@{bem3d\+\_\+mesh\+\_\+data\+\_\+add}}
\index{bem3d\+\_\+mesh\+\_\+data\+\_\+add@{bem3d\+\_\+mesh\+\_\+data\+\_\+add}!Data on B\+E\+M3\+D surfaces@{Data on B\+E\+M3\+D surfaces}}
\subsubsection[{bem3d\+\_\+mesh\+\_\+data\+\_\+add}]{\setlength{\rightskip}{0pt plus 5cm}gint bem3d\+\_\+mesh\+\_\+data\+\_\+add (
\begin{DoxyParamCaption}
\item[{{\bf B\+E\+M3\+D\+Mesh\+Data} $\ast$}]{f, }
\item[{gint}]{i, }
\item[{G\+Array $\ast$}]{g}
\end{DoxyParamCaption}
)}\label{group__data_gaf5317a69aed083fea33ca23ccae65cb5}
Add an array of data to a mesh data entry.


\begin{DoxyParams}{Parameters}
{\em f} & \doxyref{B\+E\+M3\+D\+Mesh\+Data}{p.}{structBEM3DMeshData} block; \\
\hline
{\em i} & global node index; \\
\hline
{\em g} & array of entries to add to field i.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success 
\end{DoxyReturn}


References bem3d\+\_\+mesh\+\_\+data\+\_\+get().

\index{Data on B\+E\+M3\+D surfaces@{Data on B\+E\+M3\+D surfaces}!bem3d\+\_\+mesh\+\_\+data\+\_\+add\+\_\+mesh@{bem3d\+\_\+mesh\+\_\+data\+\_\+add\+\_\+mesh}}
\index{bem3d\+\_\+mesh\+\_\+data\+\_\+add\+\_\+mesh@{bem3d\+\_\+mesh\+\_\+data\+\_\+add\+\_\+mesh}!Data on B\+E\+M3\+D surfaces@{Data on B\+E\+M3\+D surfaces}}
\subsubsection[{bem3d\+\_\+mesh\+\_\+data\+\_\+add\+\_\+mesh}]{\setlength{\rightskip}{0pt plus 5cm}gint bem3d\+\_\+mesh\+\_\+data\+\_\+add\+\_\+mesh (
\begin{DoxyParamCaption}
\item[{{\bf B\+E\+M3\+D\+Mesh\+Data} $\ast$}]{d, }
\item[{{\bf B\+E\+M3\+D\+Mesh} $\ast$}]{m}
\end{DoxyParamCaption}
)}\label{group__data_gab001ecc763ca8a763537695cc835d74f}
Expand a \doxyref{B\+E\+M3\+D\+Mesh\+Data}{p.}{structBEM3DMeshData} to include entries for another mesh, so that the data block contains data for more than one mesh.


\begin{DoxyParams}{Parameters}
{\em d} & an existing \doxyref{B\+E\+M3\+D\+Mesh\+Data}{p.}{structBEM3DMeshData} \\
\hline
{\em m} & a \doxyref{B\+E\+M3\+D\+Mesh}{p.}{structBEM3DMesh} whose nodes are to be added to {\itshape d} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success 
\end{DoxyReturn}


References bem3d\+\_\+mesh\+\_\+foreach\+\_\+node().

\index{Data on B\+E\+M3\+D surfaces@{Data on B\+E\+M3\+D surfaces}!bem3d\+\_\+mesh\+\_\+data\+\_\+add\+\_\+node@{bem3d\+\_\+mesh\+\_\+data\+\_\+add\+\_\+node}}
\index{bem3d\+\_\+mesh\+\_\+data\+\_\+add\+\_\+node@{bem3d\+\_\+mesh\+\_\+data\+\_\+add\+\_\+node}!Data on B\+E\+M3\+D surfaces@{Data on B\+E\+M3\+D surfaces}}
\subsubsection[{bem3d\+\_\+mesh\+\_\+data\+\_\+add\+\_\+node}]{\setlength{\rightskip}{0pt plus 5cm}gint bem3d\+\_\+mesh\+\_\+data\+\_\+add\+\_\+node (
\begin{DoxyParamCaption}
\item[{{\bf B\+E\+M3\+D\+Mesh\+Data} $\ast$}]{m, }
\item[{gint}]{i}
\end{DoxyParamCaption}
)}\label{group__data_ga6fa5766a482e9f8b2be3fbb8084b97e4}
Add a node to a \doxyref{B\+E\+M3\+D\+Mesh\+Data}{p.}{structBEM3DMeshData}.


\begin{DoxyParams}{Parameters}
{\em m} & mesh data block to add information to; \\
\hline
{\em i} & index of node to add. A check is performed to ensure that it is not already present.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success. 
\end{DoxyReturn}


References bem3d\+\_\+mesh\+\_\+data\+\_\+get().

\index{Data on B\+E\+M3\+D surfaces@{Data on B\+E\+M3\+D surfaces}!bem3d\+\_\+mesh\+\_\+data\+\_\+clear@{bem3d\+\_\+mesh\+\_\+data\+\_\+clear}}
\index{bem3d\+\_\+mesh\+\_\+data\+\_\+clear@{bem3d\+\_\+mesh\+\_\+data\+\_\+clear}!Data on B\+E\+M3\+D surfaces@{Data on B\+E\+M3\+D surfaces}}
\subsubsection[{bem3d\+\_\+mesh\+\_\+data\+\_\+clear}]{\setlength{\rightskip}{0pt plus 5cm}gint bem3d\+\_\+mesh\+\_\+data\+\_\+clear (
\begin{DoxyParamCaption}
\item[{{\bf B\+E\+M3\+D\+Mesh\+Data} $\ast$}]{m}
\end{DoxyParamCaption}
)}\label{group__data_ga9301ffa46f86eb0139c5220260abaea4}
Set all entries of a \doxyref{B\+E\+M3\+D\+Mesh\+Data}{p.}{structBEM3DMeshData} block to zero.


\begin{DoxyParams}{Parameters}
{\em m} & \doxyref{B\+E\+M3\+D\+Mesh\+Data}{p.}{structBEM3DMeshData} to clear.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success 
\end{DoxyReturn}
\index{Data on B\+E\+M3\+D surfaces@{Data on B\+E\+M3\+D surfaces}!bem3d\+\_\+mesh\+\_\+data\+\_\+free@{bem3d\+\_\+mesh\+\_\+data\+\_\+free}}
\index{bem3d\+\_\+mesh\+\_\+data\+\_\+free@{bem3d\+\_\+mesh\+\_\+data\+\_\+free}!Data on B\+E\+M3\+D surfaces@{Data on B\+E\+M3\+D surfaces}}
\subsubsection[{bem3d\+\_\+mesh\+\_\+data\+\_\+free}]{\setlength{\rightskip}{0pt plus 5cm}gint bem3d\+\_\+mesh\+\_\+data\+\_\+free (
\begin{DoxyParamCaption}
\item[{{\bf B\+E\+M3\+D\+Mesh\+Data} $\ast$}]{d}
\end{DoxyParamCaption}
)}\label{group__data_ga9b920a22173641abfb11fc1a7aba3247}
Free a \doxyref{B\+E\+M3\+D\+Mesh\+Data}{p.}{structBEM3DMeshData}.


\begin{DoxyParams}{Parameters}
{\em d} & \doxyref{B\+E\+M3\+D\+Mesh\+Data}{p.}{structBEM3DMeshData} to be freed.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
B\+E\+M3\+D\+\_\+\+S\+U\+C\+C\+E\+S\+S on success ; 
\end{DoxyReturn}
\index{Data on B\+E\+M3\+D surfaces@{Data on B\+E\+M3\+D surfaces}!bem3d\+\_\+mesh\+\_\+data\+\_\+get@{bem3d\+\_\+mesh\+\_\+data\+\_\+get}}
\index{bem3d\+\_\+mesh\+\_\+data\+\_\+get@{bem3d\+\_\+mesh\+\_\+data\+\_\+get}!Data on B\+E\+M3\+D surfaces@{Data on B\+E\+M3\+D surfaces}}
\subsubsection[{bem3d\+\_\+mesh\+\_\+data\+\_\+get}]{\setlength{\rightskip}{0pt plus 5cm}gdouble$\ast$ bem3d\+\_\+mesh\+\_\+data\+\_\+get (
\begin{DoxyParamCaption}
\item[{{\bf B\+E\+M3\+D\+Mesh\+Data} $\ast$}]{m, }
\item[{gint}]{i}
\end{DoxyParamCaption}
)}\label{group__data_gaa28701d5f03c9ae65850963597a8d69c}
Look up the data for a given mesh node.


\begin{DoxyParams}{Parameters}
{\em m} & \doxyref{B\+E\+M3\+D\+Mesh\+Data}{p.}{structBEM3DMeshData} block; \\
\hline
{\em i} & global index of node to look up.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a pointer to the data for node i, N\+U\+L\+L if the index is not in the block. 
\end{DoxyReturn}


Referenced by bem3d\+\_\+element\+\_\+write\+\_\+pos(), bem3d\+\_\+mesh\+\_\+data\+\_\+add(), bem3d\+\_\+mesh\+\_\+data\+\_\+add\+\_\+node(), and bem3d\+\_\+reduction\+\_\+func\+\_\+sum().

\index{Data on B\+E\+M3\+D surfaces@{Data on B\+E\+M3\+D surfaces}!bem3d\+\_\+mesh\+\_\+data\+\_\+merge@{bem3d\+\_\+mesh\+\_\+data\+\_\+merge}}
\index{bem3d\+\_\+mesh\+\_\+data\+\_\+merge@{bem3d\+\_\+mesh\+\_\+data\+\_\+merge}!Data on B\+E\+M3\+D surfaces@{Data on B\+E\+M3\+D surfaces}}
\subsubsection[{bem3d\+\_\+mesh\+\_\+data\+\_\+merge}]{\setlength{\rightskip}{0pt plus 5cm}{\bf B\+E\+M3\+D\+Mesh\+Data}$\ast$ bem3d\+\_\+mesh\+\_\+data\+\_\+merge (
\begin{DoxyParamCaption}
\item[{{\bf B\+E\+M3\+D\+Mesh\+Data} $\ast$}]{f1, }
\item[{{\bf B\+E\+M3\+D\+Mesh\+Data} $\ast$}]{f2, }
\item[{gboolean}]{strict}
\end{DoxyParamCaption}
)}\label{group__data_ga95a42216156f5bfa64769cb1beeec05a}
Merge two data blocks into a single block. This is intended for merging data generated for two disjoint meshes, with different indices. If an index appears in both blocks the behaviour is undefined. The output block will be sized to accomodate all data from both inputs, with zero padding where required.


\begin{DoxyParams}{Parameters}
{\em f1} & an input \doxyref{B\+E\+M3\+D\+Mesh\+Data}{p.}{structBEM3DMeshData}; \\
\hline
{\em f2} & another input \doxyref{B\+E\+M3\+D\+Mesh\+Data}{p.}{structBEM3DMeshData}; \\
\hline
{\em strict} & (not currently used).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a new \doxyref{B\+E\+M3\+D\+Mesh\+Data}{p.}{structBEM3DMeshData} containing the data from {\itshape f1} and {\itshape f2}. 
\end{DoxyReturn}


References bem3d\+\_\+mesh\+\_\+data\+\_\+node\+\_\+number(), and bem3d\+\_\+mesh\+\_\+data\+\_\+sized\+\_\+new().

\index{Data on B\+E\+M3\+D surfaces@{Data on B\+E\+M3\+D surfaces}!bem3d\+\_\+mesh\+\_\+data\+\_\+multiproc\+\_\+sum@{bem3d\+\_\+mesh\+\_\+data\+\_\+multiproc\+\_\+sum}}
\index{bem3d\+\_\+mesh\+\_\+data\+\_\+multiproc\+\_\+sum@{bem3d\+\_\+mesh\+\_\+data\+\_\+multiproc\+\_\+sum}!Data on B\+E\+M3\+D surfaces@{Data on B\+E\+M3\+D surfaces}}
\subsubsection[{bem3d\+\_\+mesh\+\_\+data\+\_\+multiproc\+\_\+sum}]{\setlength{\rightskip}{0pt plus 5cm}gint bem3d\+\_\+mesh\+\_\+data\+\_\+multiproc\+\_\+sum (
\begin{DoxyParamCaption}
\item[{{\bf B\+E\+M3\+D\+Mesh\+Data} $\ast$}]{m}
\end{DoxyParamCaption}
)}\label{group__data_ga1f2747030cf84458a2e5b3b4291ce23d}
Sum the data stored in a \doxyref{B\+E\+M3\+D\+Mesh\+Data}{p.}{structBEM3DMeshData} block across all processes so that each process holds the same data.


\begin{DoxyParams}{Parameters}
{\em m} & \doxyref{B\+E\+M3\+D\+Mesh\+Data}{p.}{structBEM3DMeshData} block to sum\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success. 
\end{DoxyReturn}
\index{Data on B\+E\+M3\+D surfaces@{Data on B\+E\+M3\+D surfaces}!bem3d\+\_\+mesh\+\_\+data\+\_\+new@{bem3d\+\_\+mesh\+\_\+data\+\_\+new}}
\index{bem3d\+\_\+mesh\+\_\+data\+\_\+new@{bem3d\+\_\+mesh\+\_\+data\+\_\+new}!Data on B\+E\+M3\+D surfaces@{Data on B\+E\+M3\+D surfaces}}
\subsubsection[{bem3d\+\_\+mesh\+\_\+data\+\_\+new}]{\setlength{\rightskip}{0pt plus 5cm}{\bf B\+E\+M3\+D\+Mesh\+Data}$\ast$ bem3d\+\_\+mesh\+\_\+data\+\_\+new (
\begin{DoxyParamCaption}
\item[{{\bf B\+E\+M3\+D\+Mesh} $\ast$}]{m, }
\item[{gint}]{n}
\end{DoxyParamCaption}
)}\label{group__data_ga4e26190bdd6b26ee494e3f040f6c4c03}
Allocate a \doxyref{B\+E\+M3\+D\+Mesh\+Data}{p.}{structBEM3DMeshData} block, sized to the number of collocation points on a \doxyref{B\+E\+M3\+D\+Mesh}{p.}{structBEM3DMesh}.


\begin{DoxyParams}{Parameters}
{\em m} & \doxyref{B\+E\+M3\+D\+Mesh}{p.}{structBEM3DMesh} for which to allocate data \\
\hline
{\em n} & number of data points per mesh node\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pointer to new data block 
\end{DoxyReturn}


References B\+E\+M3\+D\+\_\+\+I\+S\+\_\+\+M\+E\+S\+H, bem3d\+\_\+mesh\+\_\+data\+\_\+sized\+\_\+new(), bem3d\+\_\+mesh\+\_\+foreach\+\_\+node(), bem3d\+\_\+mesh\+\_\+node\+\_\+index\+\_\+max, bem3d\+\_\+mesh\+\_\+node\+\_\+index\+\_\+min, and bem3d\+\_\+mesh\+\_\+node\+\_\+number().

\index{Data on B\+E\+M3\+D surfaces@{Data on B\+E\+M3\+D surfaces}!bem3d\+\_\+mesh\+\_\+data\+\_\+node\+\_\+number@{bem3d\+\_\+mesh\+\_\+data\+\_\+node\+\_\+number}}
\index{bem3d\+\_\+mesh\+\_\+data\+\_\+node\+\_\+number@{bem3d\+\_\+mesh\+\_\+data\+\_\+node\+\_\+number}!Data on B\+E\+M3\+D surfaces@{Data on B\+E\+M3\+D surfaces}}
\subsubsection[{bem3d\+\_\+mesh\+\_\+data\+\_\+node\+\_\+number}]{\setlength{\rightskip}{0pt plus 5cm}gint bem3d\+\_\+mesh\+\_\+data\+\_\+node\+\_\+number (
\begin{DoxyParamCaption}
\item[{{\bf B\+E\+M3\+D\+Mesh\+Data} $\ast$}]{d}
\end{DoxyParamCaption}
)}\label{group__data_ga7cd91d22c9f2580825bfe1c5854e550e}
Find the number of nodes in a \doxyref{B\+E\+M3\+D\+Mesh\+Data}{p.}{structBEM3DMeshData}.


\begin{DoxyParams}{Parameters}
{\em d} & a \doxyref{B\+E\+M3\+D\+Mesh\+Data}{p.}{structBEM3DMeshData}.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of nodes in {\itshape d}, or zero if d is N\+U\+L\+L. 
\end{DoxyReturn}


Referenced by bem3d\+\_\+mesh\+\_\+data\+\_\+merge(), and bem3d\+\_\+reduction\+\_\+func\+\_\+sum().

\index{Data on B\+E\+M3\+D surfaces@{Data on B\+E\+M3\+D surfaces}!bem3d\+\_\+mesh\+\_\+data\+\_\+read@{bem3d\+\_\+mesh\+\_\+data\+\_\+read}}
\index{bem3d\+\_\+mesh\+\_\+data\+\_\+read@{bem3d\+\_\+mesh\+\_\+data\+\_\+read}!Data on B\+E\+M3\+D surfaces@{Data on B\+E\+M3\+D surfaces}}
\subsubsection[{bem3d\+\_\+mesh\+\_\+data\+\_\+read}]{\setlength{\rightskip}{0pt plus 5cm}gint bem3d\+\_\+mesh\+\_\+data\+\_\+read (
\begin{DoxyParamCaption}
\item[{{\bf B\+E\+M3\+D\+Mesh\+Data} $\ast$$\ast$}]{f, }
\item[{F\+I\+L\+E $\ast$}]{fp, }
\item[{gint}]{width}
\end{DoxyParamCaption}
)}\label{group__data_gaa19a6d2cd10140b35d7e7673a7f3dd2b}
Read a \doxyref{B\+E\+M3\+D\+Mesh\+Data}{p.}{structBEM3DMeshData} block from an input file, allocating it as necessary.


\begin{DoxyParams}{Parameters}
{\em f} & \+::\+B\+E\+M3\+D\+M\+Esh\+Data block to allocate; \\
\hline
{\em fp} & input file stream; \\
\hline
{\em width} & data is set to the maximum of {\itshape width} and the number of elements specified in the input file; set to 0 to use the number specified in the file.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success. 
\end{DoxyReturn}


References bem3d\+\_\+mesh\+\_\+data\+\_\+sized\+\_\+new().

\index{Data on B\+E\+M3\+D surfaces@{Data on B\+E\+M3\+D surfaces}!bem3d\+\_\+mesh\+\_\+data\+\_\+sized\+\_\+new@{bem3d\+\_\+mesh\+\_\+data\+\_\+sized\+\_\+new}}
\index{bem3d\+\_\+mesh\+\_\+data\+\_\+sized\+\_\+new@{bem3d\+\_\+mesh\+\_\+data\+\_\+sized\+\_\+new}!Data on B\+E\+M3\+D surfaces@{Data on B\+E\+M3\+D surfaces}}
\subsubsection[{bem3d\+\_\+mesh\+\_\+data\+\_\+sized\+\_\+new}]{\setlength{\rightskip}{0pt plus 5cm}{\bf B\+E\+M3\+D\+Mesh\+Data}$\ast$ bem3d\+\_\+mesh\+\_\+data\+\_\+sized\+\_\+new (
\begin{DoxyParamCaption}
\item[{gint}]{n, }
\item[{gint}]{m}
\end{DoxyParamCaption}
)}\label{group__data_ga864fb827bf3c17436a427f94761b51d1}
Allocate \doxyref{B\+E\+M3\+D\+Mesh\+Data}{p.}{structBEM3DMeshData} block of a given size, without linking to a \doxyref{B\+E\+M3\+D\+Mesh}{p.}{structBEM3DMesh}.


\begin{DoxyParams}{Parameters}
{\em n} & number of data points per mesh node; \\
\hline
{\em m} & number of points for which to allocate the \doxyref{B\+E\+M3\+D\+Mesh\+Data}{p.}{structBEM3DMeshData}.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\doxyref{B\+E\+M3\+D\+Mesh\+Data}{p.}{structBEM3DMeshData} block. 
\end{DoxyReturn}


Referenced by bem3d\+\_\+mesh\+\_\+data\+\_\+merge(), bem3d\+\_\+mesh\+\_\+data\+\_\+new(), and bem3d\+\_\+mesh\+\_\+data\+\_\+read().

\index{Data on B\+E\+M3\+D surfaces@{Data on B\+E\+M3\+D surfaces}!bem3d\+\_\+mesh\+\_\+data\+\_\+write@{bem3d\+\_\+mesh\+\_\+data\+\_\+write}}
\index{bem3d\+\_\+mesh\+\_\+data\+\_\+write@{bem3d\+\_\+mesh\+\_\+data\+\_\+write}!Data on B\+E\+M3\+D surfaces@{Data on B\+E\+M3\+D surfaces}}
\subsubsection[{bem3d\+\_\+mesh\+\_\+data\+\_\+write}]{\setlength{\rightskip}{0pt plus 5cm}gint bem3d\+\_\+mesh\+\_\+data\+\_\+write (
\begin{DoxyParamCaption}
\item[{{\bf B\+E\+M3\+D\+Mesh\+Data} $\ast$}]{f, }
\item[{F\+I\+L\+E $\ast$}]{fp, }
\item[{gchar $\ast$}]{header}
\end{DoxyParamCaption}
)}\label{group__data_ga409fb405712584435c8df106fe012572}
Write a \doxyref{B\+E\+M3\+D\+Mesh\+Data}{p.}{structBEM3DMeshData} block to a file. The output format is one line containing\+:

{\itshape N\+P} {\itshape N\+E} \doxyref{B\+E\+M3\+D\+Mesh\+Data}{p.}{structBEM3DMeshData}

where {\itshape N\+P} is the number of nodes in the block and {\itshape N\+E} is the number of numerical entries per point, followed by {\itshape N\+P} lines each containing {\itshape N\+E} numerical entries. If {\itshape header} is not N\+U\+L\+L, it is used in place of the standard first line. If it contains C formatting strings d, these generate {\itshape N\+P} and {\itshape N\+E}.


\begin{DoxyParams}{Parameters}
{\em f} & \doxyref{B\+E\+M3\+D\+Mesh\+Data}{p.}{structBEM3DMeshData} block; \\
\hline
{\em fp} & file pointer; \\
\hline
{\em header} & first line of output file (may be N\+U\+L\+L)\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success. 
\end{DoxyReturn}
\index{Data on B\+E\+M3\+D surfaces@{Data on B\+E\+M3\+D surfaces}!bem3d\+\_\+mesh\+\_\+data\+\_\+write\+\_\+weights@{bem3d\+\_\+mesh\+\_\+data\+\_\+write\+\_\+weights}}
\index{bem3d\+\_\+mesh\+\_\+data\+\_\+write\+\_\+weights@{bem3d\+\_\+mesh\+\_\+data\+\_\+write\+\_\+weights}!Data on B\+E\+M3\+D surfaces@{Data on B\+E\+M3\+D surfaces}}
\subsubsection[{bem3d\+\_\+mesh\+\_\+data\+\_\+write\+\_\+weights}]{\setlength{\rightskip}{0pt plus 5cm}gint bem3d\+\_\+mesh\+\_\+data\+\_\+write\+\_\+weights (
\begin{DoxyParamCaption}
\item[{{\bf B\+E\+M3\+D\+Mesh\+Data} $\ast$}]{f, }
\item[{F\+I\+L\+E $\ast$}]{fp, }
\item[{gint $\ast$}]{fields, }
\item[{gint}]{nfields}
\end{DoxyParamCaption}
)}\label{group__data_ga64881a8e9f45f0ba9d93f9221f91ffc1}
Write a block of data in the form of a single row suitable for use in a weighting matrix, e.\+g. of a type generated by \doxyref{bem3d\+\_\+function\+\_\+integral\+\_\+weights}{p.}{group__functions_ga042d41960a69e5549aed4d2c24161005}. Data are written on one row in the form

index f0 f1 f2 index f0 f1 f2 ...

with any entries with all data equal to zero neglected, effectively treating the data as a sparse matrix.


\begin{DoxyParams}{Parameters}
{\em f} & data to write; \\
\hline
{\em fp} & file pointer for output; \\
\hline
{\em fields} & indices of fields to write to output (must all be less than the number of fields per node in {\itshape f}); \\
\hline
{\em nfields} & number of fields to write.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success 
\end{DoxyReturn}
