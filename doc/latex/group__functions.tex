\section{Functions of surface data}
\label{group__functions}\index{Functions of surface data@{Functions of surface data}}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef struct \+\_\+\+B\+E\+M3\+D\+Function {\bf B\+E\+M3\+D\+Function}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
gint {\bf bem3d\+\_\+function\+\_\+variable\+\_\+add} ({\bf B\+E\+M3\+D\+Function} $\ast$f, gchar $\ast$var, gchar $\ast$def)
\item 
gint {\bf bem3d\+\_\+function\+\_\+insert\+\_\+string} ({\bf B\+E\+M3\+D\+Function} $\ast$fn, gchar $\ast$str)
\item 
gint {\bf bem3d\+\_\+function\+\_\+apply\+\_\+mesh} ({\bf B\+E\+M3\+D\+Function} $\ast$func, {\bf B\+E\+M3\+D\+Mesh} $\ast$m, {\bf B\+E\+M3\+D\+Mesh\+Data} $\ast$f, {\bf B\+E\+M3\+D\+Mesh\+Data} $\ast$g)
\item 
gint {\bf bem3d\+\_\+function\+\_\+apply\+\_\+mesh\+\_\+list} ({\bf B\+E\+M3\+D\+Function} $\ast$func, G\+Ptr\+Array $\ast$meshes, {\bf B\+E\+M3\+D\+Mesh\+Data} $\ast$f, {\bf B\+E\+M3\+D\+Mesh\+Data} $\ast$g)
\item 
gint {\bf bem3d\+\_\+function\+\_\+apply\+\_\+motion} ({\bf B\+E\+M3\+D\+Function} $\ast$func, {\bf B\+E\+M3\+D\+Motion} $\ast$m, gdouble t, {\bf B\+E\+M3\+D\+Mesh\+Data} $\ast$f, {\bf B\+E\+M3\+D\+Mesh\+Data} $\ast$g)
\item 
gint {\bf bem3d\+\_\+function\+\_\+apply\+\_\+motion\+\_\+list} ({\bf B\+E\+M3\+D\+Function} $\ast$func, G\+Ptr\+Array $\ast$motions, gdouble t, {\bf B\+E\+M3\+D\+Mesh\+Data} $\ast$f, {\bf B\+E\+M3\+D\+Mesh\+Data} $\ast$g)
\item 
gint {\bf bem3d\+\_\+function\+\_\+integral\+\_\+weights} ({\bf B\+E\+M3\+D\+Function} $\ast$func, {\bf B\+E\+M3\+D\+Mesh} $\ast$m, gint imesh, Gts\+Vertex $\ast$x, Gts\+Vector n, gint i, {\bf B\+E\+M3\+D\+Quadrature\+Rule} $\ast$q, {\bf B\+E\+M3\+D\+Mesh\+Data} $\ast$f)
\item 
gint {\bf bem3d\+\_\+function\+\_\+eval\+\_\+point} ({\bf B\+E\+M3\+D\+Function} $\ast$func, Gts\+Point $\ast$x, Gts\+Vector n, gint idx, gdouble $\ast$result, gint nres)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Application of analytical functions to data on meshes. The underlying function handler is G\+N\+U libmatheval and functions should conform to that syntax, including the built-\/in functions. Reserved variable names are {\itshape x}, {\itshape y}, {\itshape z} for node coordinates, {\itshape u}, {\itshape v}, {\itshape w} for components of node velocity, {\itshape nx}, {\itshape ny}, {\itshape nz} for node normal, {\itshape i} for node index, and {\itshape mesh} for mesh index (when multiple meshes are passed to the function evaluation). In integral evaluations, $(x,y,z)$ refers to the node coordinates in an integrand, {\itshape X}, {\itshape Y}, and {\itshape Z} are reserved for node coordinates at an evaluation point, {\itshape N\+X}, {\itshape N\+Y}, and {\itshape N\+Z} for the corresponding normal, and {\itshape I} for the node index.

Functions are applied to data at each node of a mesh with input and output data in \doxyref{B\+E\+M3\+D\+Mesh\+Data}{p.}{structBEM3DMeshData} structs. Input and output data are specified in functions as {\itshape f} and {\itshape g}, with components given as {\itshape f}[0], etc. Output data are given in {\itshape f}. 

\subsection{Typedef Documentation}
\index{Functions of surface data@{Functions of surface data}!B\+E\+M3\+D\+Function@{B\+E\+M3\+D\+Function}}
\index{B\+E\+M3\+D\+Function@{B\+E\+M3\+D\+Function}!Functions of surface data@{Functions of surface data}}
\subsubsection[{B\+E\+M3\+D\+Function}]{\setlength{\rightskip}{0pt plus 5cm}typedef struct \+\_\+\+B\+E\+M3\+D\+Function {\bf B\+E\+M3\+D\+Function}}\label{group__functions_ga2daa612ab588925bd1784c135ddf821c}
Basic function class which allows the evaluation of analytical functions of mesh data, including differentiation. 

\subsection{Function Documentation}
\index{Functions of surface data@{Functions of surface data}!bem3d\+\_\+function\+\_\+apply\+\_\+mesh@{bem3d\+\_\+function\+\_\+apply\+\_\+mesh}}
\index{bem3d\+\_\+function\+\_\+apply\+\_\+mesh@{bem3d\+\_\+function\+\_\+apply\+\_\+mesh}!Functions of surface data@{Functions of surface data}}
\subsubsection[{bem3d\+\_\+function\+\_\+apply\+\_\+mesh}]{\setlength{\rightskip}{0pt plus 5cm}gint bem3d\+\_\+function\+\_\+apply\+\_\+mesh (
\begin{DoxyParamCaption}
\item[{{\bf B\+E\+M3\+D\+Function} $\ast$}]{func, }
\item[{{\bf B\+E\+M3\+D\+Mesh} $\ast$}]{m, }
\item[{{\bf B\+E\+M3\+D\+Mesh\+Data} $\ast$}]{f, }
\item[{{\bf B\+E\+M3\+D\+Mesh\+Data} $\ast$}]{g}
\end{DoxyParamCaption}
)}\label{group__functions_ga8ccf032a544f36cc9e4392960088c49b}
Apply a function to surface data specified as \doxyref{B\+E\+M3\+D\+Mesh}{p.}{structBEM3DMesh}. The function may use any of the reserved words which apply to a \doxyref{B\+E\+M3\+D\+Function}{p.}{group__functions_ga2daa612ab588925bd1784c135ddf821c} and entries for the supplied data blocks {\itshape f} and {\itshape g} (if not N\+U\+L\+L) with reference to `f[0]\textquotesingle{}, `f[1]\textquotesingle{}, etc. for elements of data and `dfdx[0]\textquotesingle{} etc. for gradient terms, which are computed as required at each node. If a second data block is given, it may be included in the function as `g[0]\textquotesingle{} etc. On output, {\itshape f} will contain the results of the applied function.


\begin{DoxyParams}{Parameters}
{\em func} & \doxyref{B\+E\+M3\+D\+Function}{p.}{group__functions_ga2daa612ab588925bd1784c135ddf821c} to apply; \\
\hline
{\em m} & \doxyref{B\+E\+M3\+D\+Mesh}{p.}{structBEM3DMesh} for surface; \\
\hline
{\em f} & a \doxyref{B\+E\+M3\+D\+Mesh\+Data}{p.}{structBEM3DMeshData} block containing data for mesh (must not be N\+U\+L\+L); \\
\hline
{\em g} & a \doxyref{B\+E\+M3\+D\+Mesh\+Data}{p.}{structBEM3DMeshData} block containing supplementary data (may be N\+U\+L\+L);\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success. 
\end{DoxyReturn}
\index{Functions of surface data@{Functions of surface data}!bem3d\+\_\+function\+\_\+apply\+\_\+mesh\+\_\+list@{bem3d\+\_\+function\+\_\+apply\+\_\+mesh\+\_\+list}}
\index{bem3d\+\_\+function\+\_\+apply\+\_\+mesh\+\_\+list@{bem3d\+\_\+function\+\_\+apply\+\_\+mesh\+\_\+list}!Functions of surface data@{Functions of surface data}}
\subsubsection[{bem3d\+\_\+function\+\_\+apply\+\_\+mesh\+\_\+list}]{\setlength{\rightskip}{0pt plus 5cm}gint bem3d\+\_\+function\+\_\+apply\+\_\+mesh\+\_\+list (
\begin{DoxyParamCaption}
\item[{{\bf B\+E\+M3\+D\+Function} $\ast$}]{func, }
\item[{G\+Ptr\+Array $\ast$}]{meshes, }
\item[{{\bf B\+E\+M3\+D\+Mesh\+Data} $\ast$}]{f, }
\item[{{\bf B\+E\+M3\+D\+Mesh\+Data} $\ast$}]{g}
\end{DoxyParamCaption}
)}\label{group__functions_ga7e478b40f4e46818fd5e41b13f22870f}
Apply a function to a list of surface data, in the same way as \doxyref{bem3d\+\_\+function\+\_\+apply\+\_\+mesh}{p.}{group__functions_ga8ccf032a544f36cc9e4392960088c49b}. The list of surfaces is in the form of an array of \doxyref{B\+E\+M3\+D\+Mesh}{p.}{structBEM3DMesh} pointers, which are visited in turn in the same manner as in \doxyref{bem3d\+\_\+function\+\_\+apply\+\_\+mesh}{p.}{group__functions_ga8ccf032a544f36cc9e4392960088c49b}, with the reserved variable {\itshape mesh} set to the index of the surface in the list (so the ordering of the data in the list matters).


\begin{DoxyParams}{Parameters}
{\em func} & \doxyref{B\+E\+M3\+D\+Function}{p.}{group__functions_ga2daa612ab588925bd1784c135ddf821c} to apply; \\
\hline
{\em meshes} & array of pointers to \doxyref{B\+E\+M3\+D\+Mesh}{p.}{structBEM3DMesh} for surfaces; \\
\hline
{\em f} & a \doxyref{B\+E\+M3\+D\+Mesh\+Data}{p.}{structBEM3DMeshData} block containing data for mesh (must not be N\+U\+L\+L); \\
\hline
{\em g} & a \doxyref{B\+E\+M3\+D\+Mesh\+Data}{p.}{structBEM3DMeshData} block containing supplementary data (may be N\+U\+L\+L);\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success. 
\end{DoxyReturn}
\index{Functions of surface data@{Functions of surface data}!bem3d\+\_\+function\+\_\+apply\+\_\+motion@{bem3d\+\_\+function\+\_\+apply\+\_\+motion}}
\index{bem3d\+\_\+function\+\_\+apply\+\_\+motion@{bem3d\+\_\+function\+\_\+apply\+\_\+motion}!Functions of surface data@{Functions of surface data}}
\subsubsection[{bem3d\+\_\+function\+\_\+apply\+\_\+motion}]{\setlength{\rightskip}{0pt plus 5cm}gint bem3d\+\_\+function\+\_\+apply\+\_\+motion (
\begin{DoxyParamCaption}
\item[{{\bf B\+E\+M3\+D\+Function} $\ast$}]{func, }
\item[{{\bf B\+E\+M3\+D\+Motion} $\ast$}]{m, }
\item[{gdouble}]{t, }
\item[{{\bf B\+E\+M3\+D\+Mesh\+Data} $\ast$}]{f, }
\item[{{\bf B\+E\+M3\+D\+Mesh\+Data} $\ast$}]{g}
\end{DoxyParamCaption}
)}\label{group__functions_ga49ce29b38f93093acd3e00eabfb3938a}
Apply a function to surface data specified as \doxyref{B\+E\+M3\+D\+Motion}{p.}{structBEM3DMotion}, computing surface velocity for passing to the function. The function may use any of the reserved words which apply to a \doxyref{B\+E\+M3\+D\+Function}{p.}{group__functions_ga2daa612ab588925bd1784c135ddf821c} and entries for the supplied data blocks {\itshape f} and {\itshape g} (if not N\+U\+L\+L) with reference to `f[0]\textquotesingle{}, `f[1]\textquotesingle{}, etc. for elements of data and `dfdx[0]\textquotesingle{} etc. for gradient terms, which are computed as required at each node. If a second data block is given, it may be included in the function as `g[0]\textquotesingle{} etc. On output, {\itshape f} will contain the results of the applied function.


\begin{DoxyParams}{Parameters}
{\em func} & \doxyref{B\+E\+M3\+D\+Function}{p.}{group__functions_ga2daa612ab588925bd1784c135ddf821c} to apply; \\
\hline
{\em m} & \doxyref{B\+E\+M3\+D\+Motion}{p.}{structBEM3DMotion} for surface; \\
\hline
{\em t} & time for evaluation of surface position and velocity using {\itshape m}; \\
\hline
{\em f} & a \doxyref{B\+E\+M3\+D\+Mesh\+Data}{p.}{structBEM3DMeshData} block containing data for mesh (must not be N\+U\+L\+L); \\
\hline
{\em g} & a \doxyref{B\+E\+M3\+D\+Mesh\+Data}{p.}{structBEM3DMeshData} block containing supplementary data (may be N\+U\+L\+L);\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success. 
\end{DoxyReturn}
\index{Functions of surface data@{Functions of surface data}!bem3d\+\_\+function\+\_\+apply\+\_\+motion\+\_\+list@{bem3d\+\_\+function\+\_\+apply\+\_\+motion\+\_\+list}}
\index{bem3d\+\_\+function\+\_\+apply\+\_\+motion\+\_\+list@{bem3d\+\_\+function\+\_\+apply\+\_\+motion\+\_\+list}!Functions of surface data@{Functions of surface data}}
\subsubsection[{bem3d\+\_\+function\+\_\+apply\+\_\+motion\+\_\+list}]{\setlength{\rightskip}{0pt plus 5cm}gint bem3d\+\_\+function\+\_\+apply\+\_\+motion\+\_\+list (
\begin{DoxyParamCaption}
\item[{{\bf B\+E\+M3\+D\+Function} $\ast$}]{func, }
\item[{G\+Ptr\+Array $\ast$}]{motions, }
\item[{gdouble}]{t, }
\item[{{\bf B\+E\+M3\+D\+Mesh\+Data} $\ast$}]{f, }
\item[{{\bf B\+E\+M3\+D\+Mesh\+Data} $\ast$}]{g}
\end{DoxyParamCaption}
)}\label{group__functions_gae16d437f761827083d346e6f1c11de9b}
Apply a function to a list of surface data, in the same way as \doxyref{bem3d\+\_\+function\+\_\+apply\+\_\+motion}{p.}{group__functions_ga49ce29b38f93093acd3e00eabfb3938a}. The list of surfaces is in the form of an array of \doxyref{B\+E\+M3\+D\+Motion}{p.}{structBEM3DMotion} pointers, which are visited in turn in the same manner as in \doxyref{bem3d\+\_\+function\+\_\+apply\+\_\+motion}{p.}{group__functions_ga49ce29b38f93093acd3e00eabfb3938a}, with the reserved variable {\itshape mesh} set to the index of the surface in the list (so the ordering of the data in the list matters).


\begin{DoxyParams}{Parameters}
{\em func} & \doxyref{B\+E\+M3\+D\+Function}{p.}{group__functions_ga2daa612ab588925bd1784c135ddf821c} to apply; \\
\hline
{\em motions} & array of pointers to \doxyref{B\+E\+M3\+D\+Motion}{p.}{structBEM3DMotion} for surfaces; \\
\hline
{\em t} & time for evaluation of surface position and velocity using {\itshape m}; \\
\hline
{\em f} & a \doxyref{B\+E\+M3\+D\+Mesh\+Data}{p.}{structBEM3DMeshData} block containing data for mesh (must not be N\+U\+L\+L); \\
\hline
{\em g} & a \doxyref{B\+E\+M3\+D\+Mesh\+Data}{p.}{structBEM3DMeshData} block containing supplementary data (may be N\+U\+L\+L);\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success. 
\end{DoxyReturn}
\index{Functions of surface data@{Functions of surface data}!bem3d\+\_\+function\+\_\+eval\+\_\+point@{bem3d\+\_\+function\+\_\+eval\+\_\+point}}
\index{bem3d\+\_\+function\+\_\+eval\+\_\+point@{bem3d\+\_\+function\+\_\+eval\+\_\+point}!Functions of surface data@{Functions of surface data}}
\subsubsection[{bem3d\+\_\+function\+\_\+eval\+\_\+point}]{\setlength{\rightskip}{0pt plus 5cm}gint bem3d\+\_\+function\+\_\+eval\+\_\+point (
\begin{DoxyParamCaption}
\item[{{\bf B\+E\+M3\+D\+Function} $\ast$}]{func, }
\item[{Gts\+Point $\ast$}]{x, }
\item[{Gts\+Vector}]{n, }
\item[{gint}]{idx, }
\item[{gdouble $\ast$}]{result, }
\item[{gint}]{nres}
\end{DoxyParamCaption}
)}\label{group__functions_gae88b2d3a2ab245efa599aaeabd7da70b}
Evaluate a \doxyref{B\+E\+M3\+D\+Function}{p.}{group__functions_ga2daa612ab588925bd1784c135ddf821c} at a \+::\+Gts\+Point. The function is evaluated in the same way as for a \doxyref{B\+E\+M3\+D\+Mesh}{p.}{structBEM3DMesh} except that the normal and index must be supplied explicitly.


\begin{DoxyParams}{Parameters}
{\em func} & a \doxyref{B\+E\+M3\+D\+Function}{p.}{group__functions_ga2daa612ab588925bd1784c135ddf821c}; \\
\hline
{\em x} & a \+::\+Gts\+Point; \\
\hline
{\em n} & the normal at {\itshape x}; \\
\hline
{\em idx} & the mesh index to be used for {\itshape x} in {\itshape f}, if required; \\
\hline
{\em result} & the results of the evaluation of {\itshape f}; \\
\hline
{\em nres} & number of entries in {\itshape result};\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of functions evaluated, on success, -\/1 otherwise. 
\end{DoxyReturn}
\index{Functions of surface data@{Functions of surface data}!bem3d\+\_\+function\+\_\+insert\+\_\+string@{bem3d\+\_\+function\+\_\+insert\+\_\+string}}
\index{bem3d\+\_\+function\+\_\+insert\+\_\+string@{bem3d\+\_\+function\+\_\+insert\+\_\+string}!Functions of surface data@{Functions of surface data}}
\subsubsection[{bem3d\+\_\+function\+\_\+insert\+\_\+string}]{\setlength{\rightskip}{0pt plus 5cm}gint bem3d\+\_\+function\+\_\+insert\+\_\+string (
\begin{DoxyParamCaption}
\item[{{\bf B\+E\+M3\+D\+Function} $\ast$}]{fn, }
\item[{gchar $\ast$}]{str}
\end{DoxyParamCaption}
)}\label{group__functions_ga32ad6778a1f2c62e2b776d9bcd5cd7a0}
Insert a string, such as a variable definition, into a function definition, overwriting any previous definition of the same variable.


\begin{DoxyParams}{Parameters}
{\em fn} & a \doxyref{B\+E\+M3\+D\+Function}{p.}{group__functions_ga2daa612ab588925bd1784c135ddf821c} to modify \\
\hline
{\em str} & string containing definition to insert\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success. 
\end{DoxyReturn}
\index{Functions of surface data@{Functions of surface data}!bem3d\+\_\+function\+\_\+integral\+\_\+weights@{bem3d\+\_\+function\+\_\+integral\+\_\+weights}}
\index{bem3d\+\_\+function\+\_\+integral\+\_\+weights@{bem3d\+\_\+function\+\_\+integral\+\_\+weights}!Functions of surface data@{Functions of surface data}}
\subsubsection[{bem3d\+\_\+function\+\_\+integral\+\_\+weights}]{\setlength{\rightskip}{0pt plus 5cm}gint bem3d\+\_\+function\+\_\+integral\+\_\+weights (
\begin{DoxyParamCaption}
\item[{{\bf B\+E\+M3\+D\+Function} $\ast$}]{func, }
\item[{{\bf B\+E\+M3\+D\+Mesh} $\ast$}]{m, }
\item[{gint}]{imesh, }
\item[{Gts\+Vertex $\ast$}]{x, }
\item[{Gts\+Vector}]{n, }
\item[{gint}]{i, }
\item[{{\bf B\+E\+M3\+D\+Quadrature\+Rule} $\ast$}]{q, }
\item[{{\bf B\+E\+M3\+D\+Mesh\+Data} $\ast$}]{f}
\end{DoxyParamCaption}
)}\label{group__functions_ga042d41960a69e5549aed4d2c24161005}
Fill a \doxyref{B\+E\+M3\+D\+Mesh\+Data}{p.}{structBEM3DMeshData} with the integral of a function such that the entries form the weights of a quadrature, i.\+e. $\int_{S}w(\mathbf{x})\phi(\mathbf{x})\approx\sum_{i}\phi_{i}f_{i}$ where $\phi_{i}$ are the values of a function at the mesh nodes and $f_{i}$ are the entries in the \doxyref{B\+E\+M3\+D\+Mesh\+Data}{p.}{structBEM3DMeshData}


\begin{DoxyParams}{Parameters}
{\em func} & weighting function to integrate (may have multiple terms); \\
\hline
{\em m} & mesh to integrate on; \\
\hline
{\em imesh} & index of {\itshape m}, used to set reserved word {\itshape mesh} in function evaluation; \\
\hline
{\em x} & used to set coordinates of evaluation point in position-\/dependent integrands; \\
\hline
{\em n} & normal at evaluation point; \\
\hline
{\em i} & index of evaluation point; \\
\hline
{\em q} & \doxyref{B\+E\+M3\+D\+Quadrature\+Rule}{p.}{structBEM3DQuadratureRule} used for integration on elements; \\
\hline
{\em f} & output data containing integral weights.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
B\+E\+M3\+D\+\_\+\+S\+U\+C\+C\+E\+S\+S on success. 
\end{DoxyReturn}


References bem3d\+\_\+mesh\+\_\+foreach\+\_\+element().

\index{Functions of surface data@{Functions of surface data}!bem3d\+\_\+function\+\_\+variable\+\_\+add@{bem3d\+\_\+function\+\_\+variable\+\_\+add}}
\index{bem3d\+\_\+function\+\_\+variable\+\_\+add@{bem3d\+\_\+function\+\_\+variable\+\_\+add}!Functions of surface data@{Functions of surface data}}
\subsubsection[{bem3d\+\_\+function\+\_\+variable\+\_\+add}]{\setlength{\rightskip}{0pt plus 5cm}gint bem3d\+\_\+function\+\_\+variable\+\_\+add (
\begin{DoxyParamCaption}
\item[{{\bf B\+E\+M3\+D\+Function} $\ast$}]{f, }
\item[{gchar $\ast$}]{var, }
\item[{gchar $\ast$}]{def}
\end{DoxyParamCaption}
)}\label{group__functions_ga425bb1a01ab14c20e4c8ecfe27cccb47}
Add a variable definition to a \doxyref{B\+E\+M3\+D\+Function}{p.}{group__functions_ga2daa612ab588925bd1784c135ddf821c}. This will overwrite any existing definition of the same variable.


\begin{DoxyParams}{Parameters}
{\em f} & a \doxyref{B\+E\+M3\+D\+Function}{p.}{group__functions_ga2daa612ab588925bd1784c135ddf821c}; \\
\hline
{\em var} & variable name; \\
\hline
{\em def} & variable definition.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success. 
\end{DoxyReturn}
