head	1.5;
access;
symbols;
locks
	ensmjc:1.5; strict;
comment	@ * @;


1.5
date	2018.08.15.15.51.30;	author ensmjc;	state Exp;
branches;
next	1.4;

1.4
date	2017.07.03.10.47.18;	author ensmjc;	state Exp;
branches;
next	1.3;

1.3
date	2009.08.17.15.28.35;	author ensmjc;	state Exp;
branches;
next	1.2;

1.2
date	2009.01.20.13.21.12;	author ensmjc;	state Exp;
branches;
next	1.1;

1.1
date	2008.10.10.10.35.44;	author ensmjc;	state Exp;
branches;
next	;


desc
@@


1.5
log
@*** empty log message ***
@
text
@/* radiation.c
 * 
 * Copyright (C) 2006, 2018 Michael Carley
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/**
 * @@defgroup radiation Computing fields
 * @@{
 */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif /*HAVE_CONFIG_H*/

#include <stdlib.h>
#include <string.h>

#include <glib.h>
#include <gts.h>

#include "bem3d.h"
#include "bem3d-private.h"

/** 
 * Standard built-in radiation function for Laplace equation, which
 * can be used for any real problem
 * 
 * @@param G integral of Green's function
 * @@param dG integral of normal derivative of Green's function
 * @@param phi solution at nodes
 * @@param dphi normal derivative of solution at nodes
 * @@param f radiated solution integral of \f$Gd\phi/dn+dG/dn\phi\f$
 * @@param data user data, ignored in this function
 * 
 * @@return 0 on success
*/

gint bem3d_radiation_func_laplace(GArray *G, GArray *dG,
				  GArray *phi, GArray *dphi,
				  GArray *f, gpointer data)

{
  gint i, j, stride ;

  g_debug("%s: ", __FUNCTION__) ;

  stride = G->len/phi->len ;
/*   g_array_set_size(f,stride) ; */
  if ( f->len < stride ) g_array_set_size(f,stride) ;
  for ( j = 0 ; j < stride ; j ++ ) {
    for ( i = 0 ; i < phi->len ; i ++ ) 
      g_array_index(f, gdouble, j) +=
	g_array_index(dG, gdouble, i*stride+j)*g_array_index(phi, gdouble, i) -
	g_array_index(G, gdouble, i*stride+j)*g_array_index(dphi, gdouble, i) ;
  }

  return BEM3D_SUCCESS ;
}

/** 
 * Standard built-in radiation function for Helmholtz equation, which
 * can be used for any complex problem
 * 
 * @@param G integral of Green's function
 * @@param dG integral of normal derivative of Green's function
 * @@param phi solution at nodes
 * @@param dphi normal derivative of solution at nodes
 * @@param f radiated solution integral of \f$Gd\phi/dn+dG/dn\phi\f$
 * @@param data user data, ignored in this function
 * 
 * @@return 0 on success
 */

gint bem3d_radiation_func_helmholtz(GArray *G, GArray *dG,
				    GArray *phi, GArray *dphi,
				    GArray *f, gpointer data)

{
  gint i ;

  g_debug("%s: ", __FUNCTION__) ;

  g_array_set_size(f,2) ;
  for ( i = 0 ; i < (G->len)/2 ; i ++ ) {
    g_array_index(f, gdouble, 0) +=
      g_array_index(dG, gdouble, 2*i)*g_array_index(phi, gdouble, 2*i) -
      g_array_index(dG, gdouble, 2*i+1)*g_array_index(phi, gdouble, 2*i+1) -
      g_array_index(G, gdouble, 2*i)*g_array_index(dphi, gdouble, 2*i) +
      g_array_index(G, gdouble, 2*i+1)*g_array_index(dphi, gdouble, 2*i+1) ;
    g_array_index(f, gdouble, 1) +=
      g_array_index(dG, gdouble, 2*i)*g_array_index(phi, gdouble, 2*i+1) +
      g_array_index(dG, gdouble, 2*i+1)*g_array_index(phi, gdouble, 2*i) -
      g_array_index(G, gdouble, 2*i)*g_array_index(dphi, gdouble, 2*i+1) -
      g_array_index(G, gdouble, 2*i+1)*g_array_index(dphi, gdouble, 2*i) ;
  }

  return BEM3D_SUCCESS ;
}

static void radiation_real(GArray *G, GArray *dG, gint nc,
			   GArray *phi, GArray *dphi,
			   GArray *f)
{
  gint i, j, idx ;

  /* for ( i = 0 ; i < G->len ; i ++ ) */
  /*   fprintf(stderr, "%lg ", g_array_index(G, gdouble, i)) ; */
  /* fprintf(stderr, "\n") ; */

  /* for ( i = 0 ; i < dG->len ; i ++ ) */
  /*   fprintf(stderr, "%lg ", g_array_index(dG, gdouble, i)) ; */
  /* fprintf(stderr, "\n") ; */

  /* for ( i = 0 ; i < phi->len ; i ++ ) */
  /*   fprintf(stderr, "%lg ", g_array_index(phi, gdouble, i)) ; */
  /* fprintf(stderr, "\n") ; */

  /* for ( i = 0 ; i < dphi->len ; i ++ ) */
  /*   fprintf(stderr, "%lg ", g_array_index(dphi, gdouble, i)) ; */
  /* fprintf(stderr, "\n") ; */
  
  for ( j = 0 ; j < nc ; j ++ ) {
    for ( i = 0 ; i < phi->len ; i ++ ) {
      idx = i*nc + j ;
      g_array_index(f, gdouble, j) +=
	g_array_index(dG, gdouble, idx)*
	g_array_index(phi, gdouble, i) -
	g_array_index(G, gdouble, idx)*
	g_array_index(dphi, gdouble, i) ;
    }
  }

  /* for ( i = 0 ; i < f->len ; i ++ ) */
  /*   fprintf(stderr, "%lg ", g_array_index(f, gdouble, i)) ; */
  /* fprintf(stderr, "\n") ; */

  /* exit(0) ; */
  
  return ;
}

static void radiation_complex(GArray *G, GArray *dG, gint nc,
			      GArray *phi, GArray *dphi,
			      GArray *f)
{
  gint i, j, idx ;

  for ( j = 0 ; j < nc ; j ++ ) {
    for ( i = 0 ; i < (phi->len)/2 ; i ++ ) {
      idx = nc*i + j ;
      g_array_index(f, gdouble, 2*j+0) +=
	g_array_index(dG, gdouble, 2*idx+0)*
	g_array_index(phi, gdouble, 2*i+0) -
	g_array_index(dG, gdouble, 2*idx+1)*
	g_array_index(phi, gdouble, 2*i+1) -
	g_array_index(G, gdouble, 2*idx+0)*
	g_array_index(dphi, gdouble, 2*i+0) +
	g_array_index(G, gdouble, 2*idx+1)*
	g_array_index(dphi, gdouble, 2*i+1) ;
      g_array_index(f, gdouble, 2*j+1) += 
	g_array_index(dG, gdouble, 2*idx+0)*
	g_array_index(phi, gdouble, 2*i+1) +
	g_array_index(dG, gdouble, 2*idx+1)*
	g_array_index(phi, gdouble, 2*i+0) -
	g_array_index(G, gdouble, 2*idx+0)*
	g_array_index(dphi, gdouble, 2*i+1) -
	g_array_index(G, gdouble, 2*idx+1)*
	g_array_index(dphi, gdouble, 2*i+0) ;
    }
  }
  return ;
}

static void element_radiation_point(BEM3DElement *e, 
				    BEM3DConfiguration *config,
				    BEM3DParameters *gdata,
				    BEM3DLookupFunc lfunc, gpointer ldata,
				    GtsPoint *x, 
				    GArray *G, GArray *dGdn,
				    GArray *phi, GArray *dphi,
				    GArray *f)
{
  BEM3DShapeFunc shfunc, cpfunc ;
  BEM3DGreensFunction gfunc ;
  static BEM3DQuadratureRule *q = NULL ;
  static GArray *g = NULL ;
  static GArray *dgdn = NULL ;
  static gdouble *L = NULL, *dLds = NULL, *dLdt = NULL ;
  BEM3DQuadratureRuleFunc qfunc ;
  gpointer qdata ;
  gint i, j, k, stride = 0, nc ;
  gdouble s, t, J, w, wt ;
  GtsPoint y ;
  GtsVector n ;

  g_debug("%s: e=%p", __FUNCTION__, e) ;

  shfunc = bem3d_element_shape_func(e) ;
  cpfunc = bem3d_element_node_func(e) ;

  if ( g == NULL ) {
    g = g_array_new(FALSE, FALSE, sizeof(gdouble)) ;
    dgdn = g_array_new(FALSE, FALSE, sizeof(gdouble)) ;
    L = (gdouble *)g_malloc(4*bem3d_element_node_number(e)*sizeof(gdouble)) ;
    dLds = (gdouble *)g_malloc(4*bem3d_element_node_number(e)*sizeof(gdouble)) ;
    dLdt = (gdouble *)g_malloc(4*bem3d_element_node_number(e)*sizeof(gdouble)) ;
  }
  
  if ( q == NULL ) q = bem3d_quadrature_rule_new(1024, 1) ;

  g_debug("%s: %d point quadrature rule", __FUNCTION__,
	  bem3d_quadrature_vertex_number(q)) ;

  gfunc = config->gfunc ;

  qfunc = config->qrule ; qdata = config->qdata ;

  qfunc(x, e, q, &gfunc, gdata, qdata) ;

  /* get the size of the Green's function */
  if ( bem3d_greens_function_is_real(&gfunc) ) stride = 1 ;
  else stride = 2 ;
  nc = bem3d_greens_function_component_number(&gfunc) ;
  
  g_array_set_size(G,bem3d_element_node_number(e)*stride*nc) ; 
  g_array_set_size(dGdn,bem3d_element_node_number(e)*stride*nc) ;  
  g_array_set_size(phi,bem3d_element_node_number(e)*stride) ; 
  g_array_set_size(dphi,bem3d_element_node_number(e)*stride) ;  
  g_array_set_size(f,stride*nc) ; 

  g_array_set_size(G, stride*bem3d_element_node_number(e)*nc) ;
  g_array_set_size(dGdn, stride*bem3d_element_node_number(e)*nc) ;

  for ( i = 0 ; i < G->len ; i ++ ) 
    g_array_index(G,gdouble,i) = g_array_index(dGdn,gdouble,i) = 0.0 ;

  for ( i = 0 ; i < bem3d_quadrature_vertex_number(q) ; i ++ ) {
    g_assert(i < bem3d_quadrature_vertex_number_max(q)) ;
    s = bem3d_quadrature_xi(q,i) ;
    t = bem3d_quadrature_eta(q,i) ;
    wt = bem3d_quadrature_weight(q,i) ;
    shfunc(s, t, L, dLds, dLdt, NULL) ;
    bem3d_element_position(e, L, &y) ;
    bem3d_element_normal(e, dLds, dLdt, n, &J) ;
    bem3d_greens_function_func(&gfunc)(x, &y, n, gdata, g, dgdn) ;
    cpfunc(s, t, L, NULL, NULL, NULL) ;
    J *= wt ;
    for ( j = 0 ; j < bem3d_element_node_number(e) ; j ++ ) {
      w = J*L[j] ;
      for ( k = 0 ; k < stride*nc ; k ++ ) {
  	g_array_index(G,gdouble,j*stride*nc+k) +=
 	  g_array_index(g,gdouble,k)*w ;
	g_array_index(dGdn,gdouble,j*stride*nc+k) +=
	  g_array_index(dgdn,gdouble,k)*w ;
      }
    }
    /* fprintf(stderr, "%lg\n", w) ; */
    
    /* fprintf(stderr, "G: ") ; */
    /* for ( j = 0 ; j < G->len ; j ++ ) */
    /*   fprintf(stderr, "%lg ", g_array_index(G,gdouble,j)) ; */
    /* fprintf(stderr, "\n") ; */
    /* fprintf(stderr, "g: ") ; */
    /* for ( j = 0 ; j < g->len ; j ++ ) */
    /*   fprintf(stderr, "%lg ", g_array_index(g,gdouble,j)) ; */
    /* fprintf(stderr, "\n") ; */
    /* fprintf(stderr, "dG: ") ; */
    /* for ( j = 0 ; j < dGdn->len ; j ++ ) */
    /*   fprintf(stderr, "%lg ", g_array_index(dGdn,gdouble,j)) ; */
    /* fprintf(stderr, "\n") ; */
    /* fprintf(stderr, "dgdn: ") ; */
    /* for ( j = 0 ; j < g->len ; j ++ ) */
    /*   fprintf(stderr, "%lg ", g_array_index(dgdn,gdouble,j)) ; */
    /* fprintf(stderr, "\n") ; */

    /* exit(0) ; */
  }

  if ( bem3d_quadrature_free_number(q) != 0 ) {
    if ( bem3d_quadrature_free_number(q) != bem3d_element_node_number(e)*nc )
      g_error("%s: number of free terms (%d) in quadrature rule "
	      "does not match number of nodes on element (%d)",
	      __FUNCTION__, bem3d_quadrature_free_number(q), 
	      bem3d_element_node_number(e)) ;
    /*we should not arrive here in complex problems*/
    g_assert(q->wfree == 1) ;
    /* g_assert(stride == 1) ; */
    k = 0 ;
    for ( j = 0 ; j < bem3d_element_node_number(e)*nc*stride ; j ++ ) {
      g_array_index(G,gdouble,j) += bem3d_quadrature_free_term_g(q,j) ;
      g_array_index(dGdn,gdouble,j) += bem3d_quadrature_free_term_dg(q,j) ;
      /* g_array_index(G,gdouble,j*stride+k) +=  */
      /* 	bem3d_quadrature_free_term_g(q,j) ; */
      /* g_array_index(dGdn,gdouble,j*stride+k) +=  */
      /* 	bem3d_quadrature_free_term_dg(q,j) ; */
    }
  }

  g_array_set_size(phi, stride*bem3d_element_node_number(e)) ;
  g_array_set_size(dphi, stride*bem3d_element_node_number(e)) ;
  for ( j = 0 ; j < bem3d_element_node_number(e) ; j ++ ) {
    lfunc(bem3d_element_global_index(e, j), j, ldata, phi, dphi) ;
  }

  if ( bem3d_greens_function_is_real(&gfunc) ) {
    radiation_real(G, dGdn, nc, phi, dphi, f) ;
  } else {
    radiation_complex(G, dGdn, nc, phi, dphi, f) ;
  }
  
  return ;
}

static gint mesh_radiation_point(BEM3DElement *e, gpointer data[])

{
  GtsPoint *x = (GtsPoint *)data[BEM3D_BMESH_DATA_POINT] ;
  BEM3DConfiguration *config = data[BEM3D_BMESH_DATA_CONFIG] ; 
  BEM3DParameters *gdata = data[BEM3D_BMESH_DATA_GDATA] ;
  BEM3DLookupFunc lf = (BEM3DLookupFunc)data[BEM3D_BMESH_DATA_LFUNC] ;
  gpointer ldata = data[BEM3D_BMESH_DATA_LDATA] ;
  GArray *f = (GArray *)data[BEM3D_BMESH_DATA_F] ;
  static GArray *g = NULL, *dg = NULL, *phi = NULL, *dphi = NULL ;

  if ( g == NULL ) {
    g = g_array_new(FALSE, TRUE, sizeof(gdouble)) ;
    dg = g_array_new(FALSE, TRUE, sizeof(gdouble)) ;
    phi = g_array_new(FALSE, TRUE, sizeof(gdouble)) ;
    dphi = g_array_new(FALSE, TRUE, sizeof(gdouble)) ;
  }

  element_radiation_point(e, config, gdata, lf, ldata,
			  x, g, dg, phi, dphi, f) ;

  return BEM3D_SUCCESS ;
}

/** 
 * Compute the field radiated to a point from a BEM3DMesh with known
 * solution
 * 
 * @@param m BEM3DMesh for geometry;
 * @@param config ::BEM3DConfiguration for problem;
 * @@param gdata ::BEM3DParameters to pass to Green's function;
 * @@param lf lookup function for solution
 * @@param ldata user data to pass to lf
 * @@param x field point
 * @@param f radiated solution
 * 
 * @@return 0 on success
 */

gint bem3d_mesh_radiation_point(BEM3DMesh *m,
				BEM3DConfiguration *config,
				BEM3DParameters *gdata,
				BEM3DLookupFunc lf, gpointer ldata,
				GtsPoint *x, GArray *f)

{
  gpointer data[BEM3D_BMESH_DATA_WIDTH] ;
  gint j, len ;
  BEM3DGreensFunction gfunc ;

  g_debug("%s: ", __FUNCTION__) ;

  g_return_val_if_fail(m != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(BEM3D_IS_MESH(m), BEM3D_ARGUMENT_WRONG_TYPE) ;
  g_return_val_if_fail(config != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(gdata != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(lf != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(x != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(f != NULL, BEM3D_NULL_ARGUMENT) ;

  data[BEM3D_BMESH_DATA_MESH] = m ; 
  data[BEM3D_BMESH_DATA_POINT] = x ; 
  data[BEM3D_BMESH_DATA_CONFIG] = config ; 
  data[BEM3D_BMESH_DATA_GDATA] = gdata ;
  data[BEM3D_BMESH_DATA_LFUNC] = lf ;
  data[BEM3D_BMESH_DATA_LDATA] = ldata ;
  data[BEM3D_BMESH_DATA_IMIN] = &(bem3d_mesh_node_index_min(m)) ;
  data[BEM3D_BMESH_DATA_IMAX] = &(bem3d_mesh_node_index_max(m)) ;
  data[BEM3D_BMESH_DATA_F] = f ;  

  gfunc = config->gfunc ;
  len = bem3d_greens_function_component_number(&gfunc) ;
  if ( !bem3d_greens_function_is_real(&gfunc) ) len *= 2 ;
  
  g_array_set_size(f, len) ;
  for ( j = 0 ; j < f->len ; j ++ ) g_array_index(f,gdouble,j) = 0.0 ;  
  bem3d_mesh_foreach_element(m, (BEM3DElementFunc)mesh_radiation_point,
			     data) ;

  return BEM3D_SUCCESS ;
}

/** 
 * Compute the field radiated to a point from a BEM3DElement with known
 * solution
 * 
 * @@param e BEM3DElement
 * @@param config ::BEM3DConfiguration for problem;
 * @@param gdata ::BEM3DParameters to pass to Green's function;
 * @@param lfunc lookup function for solution
 * @@param ldata user data to pass to lf
 * @@param x field point
 * @@param G integral of Green's function
 * @@param dGdn integral of Green's function normal derivative
 * @@param phi solution at element nodes
 * @@param dphi solution normal derivative at element nodes
 * 
 * @@return 0 on success
 */

gint bem3d_element_radiation_point(BEM3DElement *e, 
				   BEM3DConfiguration *config,
				   BEM3DParameters *gdata,
				   BEM3DLookupFunc lfunc, gpointer ldata,
				   GtsPoint *x, 
				   GArray *G, GArray *dGdn,
				   GArray *phi, GArray *dphi)
{
  BEM3DGreensFunction gfunc ;
  BEM3DShapeFunc shfunc, cpfunc ;
  static BEM3DQuadratureRule *q = NULL ;
  static GArray *g = NULL ;
  static GArray *dgdn = NULL ;
  static gdouble *L = NULL, *dLds = NULL, *dLdt = NULL ;
  BEM3DQuadratureRuleFunc qfunc ;
  gpointer qdata ;
  gint i, j, k, stride = 0, nc ;
  gdouble s, t, J, w, wt ;
  GtsPoint y ;
  GtsVector n ;

  g_debug("%s: e=%p", __FUNCTION__, e) ;

  g_return_val_if_fail(e != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(BEM3D_IS_ELEMENT(e), BEM3D_ARGUMENT_WRONG_TYPE) ;
  g_return_val_if_fail(config != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(gdata != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(lfunc != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(x != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(G != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(dGdn != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(phi != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(dphi != NULL, BEM3D_NULL_ARGUMENT) ;

  shfunc = bem3d_element_shape_func(e) ;
  cpfunc = bem3d_element_node_func(e) ;

  if ( g == NULL ) {
    g = g_array_new(FALSE, FALSE, sizeof(gdouble)) ;
    dgdn = g_array_new(FALSE, FALSE, sizeof(gdouble)) ;
    L = (gdouble *)g_malloc(4*bem3d_element_node_number(e)*sizeof(gdouble)) ;
    dLds = (gdouble *)g_malloc(4*bem3d_element_node_number(e)*sizeof(gdouble)) ;
    dLdt = (gdouble *)g_malloc(4*bem3d_element_node_number(e)*sizeof(gdouble)) ;
  }
  
  if ( q == NULL ) q = bem3d_quadrature_rule_new(1024, 1) ;

  gfunc = config->gfunc ;
  qfunc = config->qrule ; qdata = config->qdata ;

  qfunc(x, e, q, &gfunc, gdata, qdata) ;

  g_debug("%s: %d point quadrature rule", __FUNCTION__,
	  bem3d_quadrature_vertex_number(q)) ;
  
  /* get the size of the Green's function */
  if ( bem3d_greens_function_is_real(&gfunc) ) stride = 1 ;
  else stride = 2 ;
  nc = bem3d_quadrature_component_number(q) ;

  g_array_set_size(G,bem3d_element_node_number(e)*stride*nc) ; 
  g_array_set_size(dGdn,bem3d_element_node_number(e)*stride*nc) ;  
  g_array_set_size(phi,bem3d_element_node_number(e)*stride) ; 
  g_array_set_size(dphi,bem3d_element_node_number(e)*stride) ;  

  for ( i = 0 ; i < G->len ; i ++ ) 
    g_array_index(G,gdouble,i) = g_array_index(dGdn,gdouble,i) = 0.0 ;

  for ( i = 0 ; i < bem3d_quadrature_vertex_number(q) ; i ++ ) {
    g_assert(i < bem3d_quadrature_vertex_number_max(q)) ;
    g_assert(nc == 1) ;
    s = bem3d_quadrature_xi(q,i) ;
    t = bem3d_quadrature_eta(q,i) ;
    wt = bem3d_quadrature_weight(q,i) ;
    shfunc(s, t, L, dLds, dLdt, NULL) ;
    bem3d_element_position(e, L, &y) ;
    bem3d_element_normal(e, dLds, dLdt, n, &J) ;
    bem3d_greens_function_func(&gfunc)(x, &y, n, gdata, g, dgdn) ;
    cpfunc(s, t, L, NULL, NULL, NULL) ;
    J *= wt ;
    stride = g->len ;

    for ( j = 0 ; j < bem3d_element_node_number(e) ; j ++ ) {
      w = J*L[j] ;
      for ( k = 0 ; k < stride ; k ++ ) {
  	g_array_index(G,gdouble,j*stride+k) +=
 	  g_array_index(g,gdouble,k)*w ;
	g_array_index(dGdn,gdouble,j*stride+k) +=
	  g_array_index(dgdn,gdouble,k)*w ;
      }
    }

  }

  if ( bem3d_quadrature_free_number(q) != 0 ) {
    if ( bem3d_quadrature_free_number(q) != bem3d_element_node_number(e) )
      g_error("%s: number of free terms (%d) in quadrature rule "
	      "does not match number of nodes on element (%d)",
	      __FUNCTION__, bem3d_quadrature_free_number(q), 
	      bem3d_element_node_number(e)) ;
    /*we should not arrive here in complex problems*/
    g_assert(q->wfree == 1) ; g_assert(stride == 1) ;
    k = 0 ;
    for ( j = 0 ; j < bem3d_element_node_number(e)*nc ; j ++ ) {
      g_array_index(G,gdouble,j*stride+k) += 
	bem3d_quadrature_free_term_g(q,j) ;
      g_array_index(dGdn,gdouble,j*stride+k) += 
	bem3d_quadrature_free_term_dg(q,j) ;
    }
  }

  g_array_set_size(phi, bem3d_element_node_number(e)) ;
  g_array_set_size(dphi, bem3d_element_node_number(e)) ;
  for ( j = 0 ; j < bem3d_element_node_number(e) ; j ++ )
    lfunc(bem3d_element_global_index(e, j), j, ldata, phi, dphi) ;

  return BEM3D_SUCCESS ;
}

static gint mesh_radiation_mesh(gint i, GtsVertex *v, gpointer data[])

{
  BEM3DMesh *m = (BEM3DMesh *)data[BEM3D_BMESH_DATA_MESH] ;
  BEM3DConfiguration *config = data[BEM3D_BMESH_DATA_CONFIG] ; 
  BEM3DParameters *gdata = data[BEM3D_BMESH_DATA_GDATA] ;
  BEM3DLookupFunc lf = (BEM3DLookupFunc)data[BEM3D_BMESH_DATA_LFUNC] ;
  gpointer ldata = data[BEM3D_BMESH_DATA_LDATA] ;
  BEM3DMeshData *fm = (BEM3DMeshData *)data[BEM3D_BMESH_DATA_F] ;
  static GArray *f = NULL ;

  if ( f == NULL ) {
    f = g_array_new(FALSE, TRUE, sizeof(gdouble)) ;
  }

  bem3d_mesh_radiation_point(m, config, gdata, lf, ldata, GTS_POINT(v), f) ;
  bem3d_mesh_data_add(fm, i, f) ;

  return BEM3D_SUCCESS ;
}

/** 
 * Compute the field radiated to a BEM3DMesh from a BEM3DMesh with
 * known solution
 * 
 * @@param m BEM3DMesh for geometry;
 * @@param config ::BEM3DConfiguration for problem;
 * @@param gdata ::BEM3DParameters to pass to Green's function;
 * @@param lfunc lookup function for solution
 * @@param ldata user data to pass to lfunc
 * @@param s BEM3DMesh on which to compute field
 * @@param f BEM3DMeshData block containing computed field
 * 
 * @@return 0 on success 
 */

gint bem3d_mesh_radiation_mesh(BEM3DMesh *m,
			       BEM3DConfiguration *config,
			       BEM3DParameters *gdata,
			       BEM3DLookupFunc lfunc, gpointer ldata,
			       BEM3DMesh *s, BEM3DMeshData *f)

{
  gpointer data[BEM3D_BMESH_DATA_WIDTH] ;

  g_debug("%s: ", __FUNCTION__) ;

  g_return_val_if_fail(m != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(BEM3D_IS_MESH(m), BEM3D_ARGUMENT_WRONG_TYPE) ;
  g_return_val_if_fail(config != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(gdata != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(lfunc != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(s != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(BEM3D_IS_MESH(s), BEM3D_ARGUMENT_WRONG_TYPE) ;
  g_return_val_if_fail(f != NULL, BEM3D_NULL_ARGUMENT) ;

  data[BEM3D_BMESH_DATA_MESH] = m ; 
  data[BEM3D_BMESH_DATA_CONFIG] = config ; 
  data[BEM3D_BMESH_DATA_GDATA] = gdata ;
  data[BEM3D_BMESH_DATA_LFUNC] = lfunc ;
  data[BEM3D_BMESH_DATA_LDATA] = ldata ;
  data[BEM3D_BMESH_DATA_IMIN] = &(bem3d_mesh_node_index_min(m)) ;
  data[BEM3D_BMESH_DATA_IMAX] = &(bem3d_mesh_node_index_max(m)) ;
  data[BEM3D_BMESH_DATA_F] = f ;  

  bem3d_mesh_foreach_node(s, (BEM3DNodeFunc)mesh_radiation_mesh,
			  data) ;

  return BEM3D_SUCCESS ;
}

/**
 * @@}
 * 
 */
@


1.4
log
@*** empty log message ***
@
text
@d3 1
a3 1
 * Copyright (C) 2006 Michael Carley
d118 1
a118 1
  gint i, j ;
d120 19
a138 2
  for ( j = 0 ; j < nc ; j ++ ) 
    for ( i = 0 ; i < phi->len ; i ++ ) 
d140 1
a140 1
	g_array_index(dG, gdouble, j*phi->len+i)*
d142 1
a142 1
	g_array_index(G, gdouble, j*phi->len+i)*
d144 8
d156 1
a156 1
static void radiation_complex(GArray *G, GArray *dG,
d160 1
a160 1
  gint i ;
d162 22
a183 11
  for ( i = 0 ; i < (G->len)/2 ; i ++ ) {
    g_array_index(f, gdouble, 0) +=
      g_array_index(dG, gdouble, 2*i)*g_array_index(phi, gdouble, 2*i) -
      g_array_index(dG, gdouble, 2*i+1)*g_array_index(phi, gdouble, 2*i+1) -
      g_array_index(G, gdouble, 2*i)*g_array_index(dphi, gdouble, 2*i) +
      g_array_index(G, gdouble, 2*i+1)*g_array_index(dphi, gdouble, 2*i+1) ;
    g_array_index(f, gdouble, 1) +=
      g_array_index(dG, gdouble, 2*i)*g_array_index(phi, gdouble, 2*i+1) +
      g_array_index(dG, gdouble, 2*i+1)*g_array_index(phi, gdouble, 2*i) -
      g_array_index(G, gdouble, 2*i)*g_array_index(dphi, gdouble, 2*i+1) -
      g_array_index(G, gdouble, 2*i+1)*g_array_index(dphi, gdouble, 2*i) ;
a184 1

a187 1

d237 1
a237 1
  nc = bem3d_quadrature_component_number(q) ;
d245 3
a257 3
    /* if (  x->x == y.x && x->y == y.y && x->z == y.z )  */
    /*   g_error("%s: coincident points (%lg,%lg,%lg)", __FUNCTION__, */
    /* 	      x->x, x->y, x->z) ; */
a261 3
    stride = g->len ;
    g_array_set_size(G, stride*bem3d_element_node_number(e)) ;
    g_array_set_size(dGdn, stride*bem3d_element_node_number(e)) ;
d264 2
a265 2
      for ( k = 0 ; k < stride ; k ++ ) {
  	g_array_index(G,gdouble,j*stride+k) +=
d267 1
a267 1
	g_array_index(dGdn,gdouble,j*stride+k) +=
d271 20
d300 2
a301 1
    g_assert(q->wfree == 1) ; g_assert(stride == 1) ;
d303 7
a309 5
    for ( j = 0 ; j < bem3d_element_node_number(e)*nc ; j ++ ) {
      g_array_index(G,gdouble,j*stride+k) += 
	bem3d_quadrature_free_term_g(q,j) ;
      g_array_index(dGdn,gdouble,j*stride+k) += 
	bem3d_quadrature_free_term_dg(q,j) ;
d313 2
a314 2
  g_array_set_size(phi, bem3d_element_node_number(e)) ;
  g_array_set_size(dphi, bem3d_element_node_number(e)) ;
a317 9
  
  /* for ( j = 0 ; j < 6 ; j ++ ) { */
  /*   fprintf(stderr, "%lg %lg %lg %lg\n", */
  /* 	    g_array_index(phi, gdouble, j), */
  /* 	    g_array_index(dphi, gdouble, j), */
  /* 	    g_array_index(G, gdouble, j), */
  /* 	    g_array_index(dG, gdouble, j)) ; */
  /* } */

d322 1
a322 1
    radiation_complex(G, dGdn, phi, dphi, f) ;
d324 1
a324 1

a327 1

a332 1
  BEM3DGreensFunction *gfunc ; /* = data[BEM3D_BMESH_DATA_GFUNC] ; */
a345 9
  gfunc = &(config->gfunc) ;
  if ( bem3d_greens_function_is_real(gfunc) ) {
/*     g_array_set_size(f, 4) ; */
/*     radiation_real(g, dg, phi, dphi, f) ; */
  } else {
    g_array_set_size(f, 2) ;
/*     radiation_complex(g, dg, phi, dphi, f) ; */
  }

d375 2
a376 1
  gint j ;
d398 6
a403 2
  g_array_set_size(f, 16) ;
  for ( j = 0 ; j < f->len ; j ++ ) g_array_index(f,gdouble,j)=0.0 ;  
d509 1
a509 2
    g_array_set_size(G, stride*bem3d_element_node_number(e)) ;
    g_array_set_size(dGdn, stride*bem3d_element_node_number(e)) ;
d519 1
d556 1
a556 2
  gint j ;
  static GArray *g = NULL, *f = NULL ;
d558 1
a558 1
  if ( g == NULL ) {
a559 1
    g = g_array_new(FALSE, TRUE, sizeof(gdouble)) ;
a561 1
  for ( j = 0 ; j < f->len ; j ++ ) g_array_index(f,gdouble,j)=0.0 ;
d569 1
a569 1
 * Computed the field radiated to a BEM3DMesh from a BEM3DMesh with
a584 1
			       /* BEM3DGreensFunction *gfunc,  */
a585 1
			       /* BEM3DQuadratureRuleFunc qfunc, gpointer qdata, */
@


1.3
log
@*** empty log message ***
@
text
@d114 170
d288 2
a289 1
  BEM3DGreensFunc gfunc = (BEM3DGreensFunc)data[BEM3D_BMESH_DATA_GFUNC] ; 
a290 3
  BEM3DQuadratureRuleFunc qf = 
    (BEM3DQuadratureRuleFunc)data[BEM3D_BMESH_DATA_QFUNC] ;
  gpointer qdata = data[BEM3D_BMESH_DATA_QDATA] ;
a292 2
  BEM3DRadiationFunc rf = (BEM3DRadiationFunc)data[BEM3D_BMESH_DATA_RFUNC] ;
  gpointer rdata = data[BEM3D_BMESH_DATA_RDATA] ;
a301 3
  
  bem3d_element_radiation_point(e, gfunc, gdata, qf, qdata, lf, ldata,
				x, g, dg, phi, dphi) ;
d303 11
a313 1
  rf(g, dg, phi, dphi, f, rdata) ;
d322 3
a324 5
 * @@param m BEM3DMesh for geometry
 * @@param gf Green's function of problem
 * @@param gdata user data to pass to Green's function
 * @@param qf quadrature rule function, (default if qf is NULL)
 * @@param qdata user data to pass to qf
a326 2
 * @@param rfunc radiation function
 * @@param rdata user data to pass to rfunc
d334 1
a334 1
				BEM3DGreensFunc gf, 
a335 1
				BEM3DQuadratureRuleFunc qf, gpointer qdata,
a336 1
				BEM3DRadiationFunc rfunc, gpointer rdata,
d347 1
a347 1
  g_return_val_if_fail(gf != NULL, BEM3D_NULL_ARGUMENT) ;
d355 1
a355 1
  data[BEM3D_BMESH_DATA_GFUNC] = gf ; 
a356 8
  if ( qf != NULL ) 
    data[BEM3D_BMESH_DATA_QFUNC] = qf ;
  else
    data[BEM3D_BMESH_DATA_QFUNC] = bem3d_quadrature_rule_default ;    
  if ( qdata != NULL ) 
    data[BEM3D_BMESH_DATA_QDATA] = qdata ;
  else
    data[BEM3D_BMESH_DATA_QDATA] = bem3d_quadrature_selector_default() ;
a358 4
  if ( rfunc != NULL ) 
    data[BEM3D_BMESH_DATA_RFUNC] = rfunc ;
  else
    data[BEM3D_BMESH_DATA_RFUNC] = bem3d_radiation_func_laplace ;
d363 1
d376 2
a377 4
 * @@param gfunc Green's function of problem
 * @@param gdata user data to pass to Green's function
 * @@param qfunc quadrature rule function, (default if qf is NULL)
 * @@param qdata user data to pass to qf
d390 1
a390 1
				   BEM3DGreensFunc gfunc,
a391 2
				   BEM3DQuadratureRuleFunc qfunc, 
				   gpointer qdata,
d397 1
d403 3
a405 1
  gint i, j, k, stride = 0 ;
d414 1
a414 1
  g_return_val_if_fail(gfunc != NULL, BEM3D_NULL_ARGUMENT) ;
d434 6
a439 4
  if ( q == NULL ) q = bem3d_quadrature_rule_new(1024) ;
  if ( qfunc != NULL ) qfunc(x, e, q, qdata) ;
  else bem3d_quadrature_rule_default(x, e, q, 
				     bem3d_quadrature_selector_default()) ;
d445 6
a450 10
  s = bem3d_quadrature_xi(q,0) ;
  t = bem3d_quadrature_eta(q,0) ;
  shfunc(s, t, L, dLds, dLdt, NULL) ;
/*   bem3d_element_position(e, L, &y) ; */
  y.x = x->x+1.0 ; y.y = x->y+1.0 ; y.z = x->z+1.0 ;
  bem3d_element_normal(e, dLds, dLdt, n, &J) ;
  gfunc(x, &y, n, gdata, g, dgdn) ;
  stride = g->len ;
  g_array_set_size(G,bem3d_element_node_number(e)*stride) ; 
  g_array_set_size(dGdn,bem3d_element_node_number(e)*stride) ;  
d459 1
d466 1
a466 1
    gfunc(x, &y, n, gdata, g, dgdn) ;
d492 1
a492 1
    for ( j = 0 ; j < bem3d_element_node_number(e) ; j ++ ) {
d502 1
a502 1
  for ( j = 0 ; j < bem3d_element_node_number(e) ; j ++ ) {
a503 1
  }
d512 1
a512 1
  BEM3DGreensFunc gf = (BEM3DGreensFunc)data[BEM3D_BMESH_DATA_GFUNC] ; 
a513 3
  BEM3DQuadratureRuleFunc qf = 
    (BEM3DQuadratureRuleFunc)data[BEM3D_BMESH_DATA_QFUNC] ;
  gpointer qdata = data[BEM3D_BMESH_DATA_QDATA] ;
a515 2
  BEM3DRadiationFunc rfunc = (BEM3DRadiationFunc)data[BEM3D_BMESH_DATA_RFUNC] ;
  gpointer rdata = data[BEM3D_BMESH_DATA_RDATA] ;
d518 1
a518 2
  static GArray *g = NULL, *dg = NULL, *phi = NULL, 
    *dphi = NULL, *f = NULL ;
a522 3
    dg = g_array_new(FALSE, TRUE, sizeof(gdouble)) ;
    phi = g_array_new(FALSE, TRUE, sizeof(gdouble)) ;
    dphi = g_array_new(FALSE, TRUE, sizeof(gdouble)) ;
d526 1
a526 2
  bem3d_mesh_radiation_point(m, gf, gdata, qf, qdata, lf, ldata,
			     rfunc, rdata, GTS_POINT(v), f) ;
d536 3
a538 5
 * @@param m BEM3DMesh for geometry
 * @@param gfunc Green's function of problem
 * @@param gdata user data to pass to Green's function
 * @@param qfunc quadrature rule function, (default if qf is NULL)
 * @@param qdata user data to pass to qfunc
a540 2
 * @@param rfunc radiation function
 * @@param rdata user data to pass to rfunc
d548 2
a549 1
			       BEM3DGreensFunc gfunc, 
d551 1
a551 1
			       BEM3DQuadratureRuleFunc qfunc, gpointer qdata,
a552 1
			       BEM3DRadiationFunc rfunc, gpointer rdata,
d562 1
a562 1
  g_return_val_if_fail(gfunc != NULL, BEM3D_NULL_ARGUMENT) ;
a564 1
  g_return_val_if_fail(rfunc != NULL, BEM3D_NULL_ARGUMENT) ;
d570 1
a570 1
  data[BEM3D_BMESH_DATA_GFUNC] = gfunc ; 
a571 8
  if ( qfunc != NULL ) 
    data[BEM3D_BMESH_DATA_QFUNC] = qfunc ;
  else
    data[BEM3D_BMESH_DATA_QFUNC] = bem3d_quadrature_rule_default ;    
  if ( qdata != NULL ) 
    data[BEM3D_BMESH_DATA_QDATA] = qdata ;
  else
    data[BEM3D_BMESH_DATA_QDATA] = bem3d_quadrature_selector_default() ;
a573 5
  if ( rfunc != NULL ) 
    data[BEM3D_BMESH_DATA_RFUNC] = rfunc ;
  else
    data[BEM3D_BMESH_DATA_RFUNC] = bem3d_radiation_func_laplace ;
  data[BEM3D_BMESH_DATA_RDATA] = rdata ;  
@


1.2
log
@*** empty log message ***
@
text
@d62 2
a63 1
  g_array_set_size(f,stride) ;
d141 1
d178 7
a184 3
  g_assert(m != NULL) ; g_assert(x != NULL) ;
  g_assert(gf != NULL) ; g_assert(lf != NULL) ;
  g_assert(f != NULL) ;
d245 1
a245 2
  BEM3DShapeFunc shfunc = bem3d_element_shapefunc(e) ;
  BEM3DShapeFunc cpfunc = bem3d_element_node_func(e) ;
d257 14
d329 17
d421 9
a429 3
  g_assert(m != NULL) ; g_assert(s != NULL) ;
  g_assert(gfunc != NULL) ; g_assert(lfunc != NULL) ;
  g_assert(f != NULL) ;
@


1.1
log
@Initial revision
@
text
@d25 3
d35 2
a36 6
#include "bem.h"
#include "bem-private.h"
#include "bmesh.h"

gint _mesh_radiation_point(BEMElement *e, gpointer data[]) ;
gint _mesh_radiation_mesh(gint i, GtsVertex *v, gpointer data[]) ;
d52 3
a54 3
gint bem_radiation_func_laplace(GArray *G, GArray *dG,
				GArray *phi, GArray *dphi,
				GArray *f, gpointer data)
d59 2
d66 2
a67 2
	g_array_index(G, gdouble, i*stride+j)*g_array_index(dphi, gdouble, i) +
	g_array_index(dG, gdouble, i*stride+j)*g_array_index(phi, gdouble, i) ;
d70 1
a70 1
  return BEM_SUCCESS ;
a72 1

d87 3
a89 3
gint bem_radiation_func_helmholtz(GArray *G, GArray *dG,
				  GArray *phi, GArray *dphi,
				  GArray *f, gpointer data)
d94 2
a98 2
      g_array_index(G, gdouble, 2*i)*g_array_index(dphi, gdouble, 2*i) -
      g_array_index(G, gdouble, 2*i+1)*g_array_index(dphi, gdouble, 2*i+1) +
d100 3
a102 1
      g_array_index(dG, gdouble, 2*i+1)*g_array_index(phi, gdouble, 2*i+1) ;
a103 2
      g_array_index(G, gdouble, 2*i)*g_array_index(dphi, gdouble, 2*i+1) +
      g_array_index(G, gdouble, 2*i+1)*g_array_index(dphi, gdouble, 2*i) +
d105 3
a107 1
      g_array_index(dG, gdouble, 2*i+1)*g_array_index(phi, gdouble, 2*i) ;
d110 1
a110 1
  return BEM_SUCCESS ;
d113 1
a113 1
gint _mesh_radiation_point(BEMElement *e, gpointer data[])
d116 11
a126 11
  GtsPoint *x = (GtsPoint *)data[_BMESH_DATA_POINT] ;
  BEMGreensFunc gf = (BEMGreensFunc)data[_BMESH_DATA_GFUNC] ; 
  gpointer gdata = data[_BMESH_DATA_GDATA] ;
  BEMQuadratureRuleFunc qf = 
    (BEMQuadratureRuleFunc)data[_BMESH_DATA_QFUNC] ;
  gpointer qdata = data[_BMESH_DATA_QDATA] ;
  BEMLookupFunc lf = (BEMLookupFunc)data[_BMESH_DATA_LFUNC] ;
  gpointer ldata = data[_BMESH_DATA_LDATA] ;
  BEMRadiationFunc rf = (BEMRadiationFunc)data[_BMESH_DATA_RFUNC] ;
  gpointer rdata = data[_BMESH_DATA_RDATA] ;
  GArray *f = (GArray *)data[_BMESH_DATA_F] ;
d128 1
d136 2
a137 2
  bem_element_radiation_point(e, gf, gdata, qf, qdata, lf, ldata,
			      x, g, dg, phi, dphi) ;
d140 1
a140 1
  return BEM_SUCCESS ;
d144 1
a144 1
 * Compute the field radiated to a point from a BEMMesh with known
d147 1
a147 1
 * @@param m BEMMesh for geometry
d162 7
a168 6
gint bem_mesh_radiation_point(BEMMesh *m,
			      BEMGreensFunc gf, gpointer gdata,
			      BEMQuadratureRuleFunc qf, gpointer qdata,
			      BEMLookupFunc lf, gpointer ldata,
			      BEMRadiationFunc rfunc, gpointer rdata,
			      GtsPoint *x, GArray *f)
d171 1
a171 1
  gpointer data[_BMESH_DATA_WIDTH] ;
d174 2
d180 4
a183 4
  data[_BMESH_DATA_MESH] = m ; 
  data[_BMESH_DATA_POINT] = x ; 
  data[_BMESH_DATA_GFUNC] = gf ; 
  data[_BMESH_DATA_GDATA] = gdata ;
d185 1
a185 1
    data[_BMESH_DATA_QFUNC] = qf ;
d187 1
a187 1
    data[_BMESH_DATA_QFUNC] = bem_quadrature_rule_default ;    
d189 1
a189 1
    data[_BMESH_DATA_QDATA] = qdata ;
d191 3
a193 3
    data[_BMESH_DATA_QDATA] = bem_quadrature_selector_default() ;
  data[_BMESH_DATA_LFUNC] = lf ;
  data[_BMESH_DATA_LDATA] = ldata ;
d195 1
a195 1
    data[_BMESH_DATA_RFUNC] = rfunc ;
d197 4
a200 4
    data[_BMESH_DATA_RFUNC] = bem_radiation_func_laplace ;
  data[_BMESH_DATA_IMIN] = &(bem_mesh_cpt_index_min(m)) ;
  data[_BMESH_DATA_IMAX] = &(bem_mesh_cpt_index_max(m)) ;
  data[_BMESH_DATA_F] = f ;  
d203 2
a204 2
  bem_mesh_foreach_element(m, (BEMElementFunc)_mesh_radiation_point,
			   data) ;
d206 1
a206 1
  return BEM_SUCCESS ;
d210 1
a210 1
 * Compute the field radiated to a point from a BEMElement with known
d213 1
a213 1
 * @@param e BEMElement
d229 9
a237 7
gint bem_element_radiation_point(BEMElement *e, 
				 BEMGreensFunc gfunc, gpointer gdata,
				 BEMQuadratureRuleFunc qfunc, gpointer qdata,
				 BEMLookupFunc lfunc, gpointer ldata,
				 GtsPoint *x, 
				 GArray *G, GArray *dGdn,
				 GArray *phi, GArray *dphi)
d239 3
a241 3
  BEMShapeFunc shfunc = bem_element_shapefunc(e) ;
  BEMShapeFunc cpfunc = bem_element_collfunc(e) ;
  static BEMQuadratureRule *q = NULL ;
d250 2
d255 3
a257 3
    L = (gdouble *)g_malloc(4*bem_element_ncpt(e)*sizeof(gdouble)) ;
    dLds = (gdouble *)g_malloc(4*bem_element_ncpt(e)*sizeof(gdouble)) ;
    dLdt = (gdouble *)g_malloc(4*bem_element_ncpt(e)*sizeof(gdouble)) ;
d260 4
a263 5
  if ( q == NULL ) q = bem_quadrature_rule_new(0) ;
  qfunc(x, e, q, qdata) ;

  for ( i = 0 ; i < G->len ; i ++ ) 
    g_array_index(G,gdouble,i) = g_array_index(dGdn,gdouble,i) = 0.0 ;
d265 3
d269 2
a270 2
  s = bem_quadrature_xi(q,0) ;
  t = bem_quadrature_eta(q,0) ;
d272 3
a274 2
  bem_element_position(e, L, &y) ;
  bem_element_normal(e, dLds, dLdt, n, &J) ;
d277 13
a289 9
  g_array_set_size(G,bem_element_ncpt(e)*stride) ; 
  g_array_set_size(dGdn,bem_element_ncpt(e)*stride) ;  
  g_array_set_size(phi,bem_element_ncpt(e)*stride) ; 
  g_array_set_size(dphi,bem_element_ncpt(e)*stride) ;  

  for ( i = 0 ; i < bem_quadrature_npts(q) ; i ++ ) {
    s = bem_quadrature_xi(q,i) ;
    t = bem_quadrature_eta(q,i) ;
    wt = bem_quadrature_weight(q,i) ;
d291 2
a292 2
    bem_element_position(e, L, &y) ;
    bem_element_normal(e, dLds, dLdt, n, &J) ;
d297 3
a299 3
    g_array_set_size(G, stride*bem_element_ncpt(e)) ;
    g_array_set_size(dGdn, stride*bem_element_ncpt(e)) ;
    for ( j = 0 ; j < bem_element_ncpt(e) ; j ++ ) {
d304 1
a304 1
	g_array_index(dGdn,gdouble,j*stride+k) -=
d310 4
a313 4
  g_array_set_size(phi, bem_element_ncpt(e)) ;
  g_array_set_size(dphi, bem_element_ncpt(e)) ;
  for ( j = 0 ; j < bem_element_ncpt(e) ; j ++ ) {
    lfunc(bem_element_global_index(e, j), j, ldata, phi, dphi) ;
d316 1
a316 1
  return BEM_SUCCESS ;
d319 1
a319 1
gint _mesh_radiation_mesh(gint i, GtsVertex *v, gpointer data[])
d322 11
a332 11
  BEMMesh *m = (BEMMesh *)data[_BMESH_DATA_MESH] ;
  BEMGreensFunc gf = (BEMGreensFunc)data[_BMESH_DATA_GFUNC] ; 
  gpointer gdata = data[_BMESH_DATA_GDATA] ;
  BEMQuadratureRuleFunc qf = 
    (BEMQuadratureRuleFunc)data[_BMESH_DATA_QFUNC] ;
  gpointer qdata = data[_BMESH_DATA_QDATA] ;
  BEMLookupFunc lf = (BEMLookupFunc)data[_BMESH_DATA_LFUNC] ;
  gpointer ldata = data[_BMESH_DATA_LDATA] ;
  BEMRadiationFunc rfunc = (BEMRadiationFunc)data[_BMESH_DATA_RFUNC] ;
  gpointer rdata = data[_BMESH_DATA_RDATA] ;
  BEMMeshData *fm = (BEMMeshData *)data[_BMESH_DATA_F] ;
d346 3
a348 3
  bem_mesh_radiation_point(m, gf, gdata, qf, qdata, lf, ldata,
			   rfunc, rdata, GTS_POINT(v), f) ;
  bem_mesh_data_add(fm, i, f) ;
d350 1
a350 1
  return BEM_SUCCESS ;
d354 2
a355 2
 * Computed the field radiated to a BEMMesh from a BEMMesh with known
 * solution
d357 1
a357 1
 * @@param m BEMMesh for geometry
d366 2
a367 2
 * @@param s BEMMesh on which to compute field
 * @@param f BEMMeshData block containing computed field
d372 7
a378 6
gint bem_mesh_radiation_mesh(BEMMesh *m,
			     BEMGreensFunc gfunc, gpointer gdata,
			     BEMQuadratureRuleFunc qfunc, gpointer qdata,
			     BEMLookupFunc lfunc, gpointer ldata,
			     BEMRadiationFunc rfunc, gpointer rdata,
			     BEMMesh *s, BEMMeshData *f)
d381 3
a383 1
  gpointer data[_BMESH_DATA_WIDTH] ;
d389 3
a391 3
  data[_BMESH_DATA_MESH] = m ; 
  data[_BMESH_DATA_GFUNC] = gfunc ; 
  data[_BMESH_DATA_GDATA] = gdata ;
d393 1
a393 1
    data[_BMESH_DATA_QFUNC] = qfunc ;
d395 1
a395 1
    data[_BMESH_DATA_QFUNC] = bem_quadrature_rule_default ;    
d397 1
a397 1
    data[_BMESH_DATA_QDATA] = qdata ;
d399 3
a401 3
    data[_BMESH_DATA_QDATA] = bem_quadrature_selector_default() ;
  data[_BMESH_DATA_LFUNC] = lfunc ;
  data[_BMESH_DATA_LDATA] = ldata ;
d403 1
a403 1
    data[_BMESH_DATA_RFUNC] = rfunc ;
d405 5
a409 5
    data[_BMESH_DATA_RFUNC] = bem_radiation_func_laplace ;
  data[_BMESH_DATA_RDATA] = rdata ;  
  data[_BMESH_DATA_IMIN] = &(bem_mesh_cpt_index_min(m)) ;
  data[_BMESH_DATA_IMAX] = &(bem_mesh_cpt_index_max(m)) ;
  data[_BMESH_DATA_F] = f ;  
d411 1
a411 1
  bem_mesh_foreach_cpoint(s, (BEMCPTFunc)_mesh_radiation_mesh,
d414 1
a414 1
  return BEM_SUCCESS ;
@
