head	1.5;
access;
symbols;
locks
	ensmjc:1.5; strict;
comment	@ * @;


1.5
date	2018.08.15.15.51.30;	author ensmjc;	state Exp;
branches;
next	1.4;

1.4
date	2017.07.03.10.47.18;	author ensmjc;	state Exp;
branches;
next	1.3;

1.3
date	2009.08.17.15.28.35;	author ensmjc;	state Exp;
branches;
next	1.2;

1.2
date	2009.01.20.13.21.12;	author ensmjc;	state Exp;
branches;
next	1.1;

1.1
date	2008.10.10.10.35.44;	author ensmjc;	state Exp;
branches;
next	;


desc
@@


1.5
log
@*** empty log message ***
@
text
@/* elements.c
 * 
 * Copyright (C) 2006, 2018 Michael Carley
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/**
 * @@defgroup elements Building elements
 *
 * BEM3D can handle a wide range of elements and some of them are
 * built in to the main library. The BEMElement type contains the
 * geometric and other information needed to perform calculations; the
 * ::BEM3DElementBuildFunc type defines a function which takes as input
 * the vertices of an element and returns the new element. In each
 * case, the inputs are an array of GtsEdge's and an array of
 * GtsVertex's which define the boundary of the element, with the
 * exception of ::bem3d_element_build_t3 and ::bem3d_element_build_q2
 * which include an interior point in the centre of the element.
 *
 * @@{
 * 
 */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif /*HAVE_CONFIG_H*/

#include <stdio.h>

#include <glib.h>
#include <gts.h>

#include "bem3d.h"
#include "bem3d-private.h"

static GtsEdge *connect_vertices(GtsEdgeClass *klass, 
				 GtsVertex *v1, GtsVertex *v2)

{
  GtsEdge *e ;

  if ( (e = GTS_EDGE(gts_vertices_are_connected(v1, v2))) == NULL )
    e = gts_edge_new(klass, v1, v2) ;

  return e ;
}

/** 
 * Generate a zero order triangular element.  The shape function for
 * computation is ::bem3d_shfunc_t0 and for the geometry is
 * ::bem3d_shfunc_t1.
 *
 * @@param e array of GtsEdge around the outside of the element
 * @@param v array of GtsVertex around the outside of the element
 * 
 * @@return a pointer to the new element
 */

BEM3DElement *bem3d_element_build_t0(GtsEdge **e, GtsVertex **v)

{
  BEM3DElement *el ;
  GtsFace *f ;
  GtsEdge *e1, *e2, *e3 ;
  GtsVertex *v1 ;

  g_return_val_if_fail(e != NULL, NULL) ;
  g_return_val_if_fail(v != NULL, NULL) ;

  el = bem3d_element_new(bem3d_element_class(),
		       3, 3, 1, 3,
		       bem3d_shfunc_t1, bem3d_shfunc_t0) ;

  bem3d_element_add_vertex(el, v[0], 0) ;
  bem3d_element_set_corner(el, 0, 0) ;
  bem3d_element_add_vertex(el, v[1], 1) ;
  bem3d_element_set_corner(el, 1, 1) ;
  bem3d_element_add_vertex(el, v[2], 2) ;
  bem3d_element_set_corner(el, 2, 2) ;

  v1 = gts_vertex_new(gts_vertex_class(), 
		      (GTS_POINT(v[0])->x+
		       GTS_POINT(v[1])->x+
		       GTS_POINT(v[2])->x)/3.0,
		      (GTS_POINT(v[0])->y+
		       GTS_POINT(v[1])->y+
		       GTS_POINT(v[2])->y)/3.0,
		      (GTS_POINT(v[0])->z+
		       GTS_POINT(v[1])->z+
		       GTS_POINT(v[2])->z)/3.0) ;

  e1 = gts_edge_new(gts_edge_class(), v[0], v1) ;
  e2 = gts_edge_new(gts_edge_class(), v[1], v1) ;
  e3 = gts_edge_new(gts_edge_class(), v[2], v1) ;

  f = gts_face_new(gts_face_class(), e[0], e2, e1) ;
  bem3d_element_add_face(el, f, 0) ;

  f = gts_face_new(gts_face_class(), e[1], e3, e2) ;
  bem3d_element_add_face(el, f, 1) ;

  f = gts_face_new(gts_face_class(), e[2], e1, e3) ;
  bem3d_element_add_face(el, f, 2) ;

  bem3d_element_add_node(el, v1, 0) ;

  bem3d_element_node_xi(el,0) = 1/3.0 ;
  bem3d_element_node_eta(el,0) = 1/3.0 ;

  bem3d_element_vertex_xi(el,0) = 0.0 ;
  bem3d_element_vertex_eta(el,0) = 0.0 ;
  bem3d_element_vertex_xi(el,1) = 1.0 ;
  bem3d_element_vertex_eta(el,1) = 0.0 ;
  bem3d_element_vertex_xi(el,2) = 0.0 ;
  bem3d_element_vertex_eta(el,2) = 1.0 ;
  
  return el ;
}

/** 
 * Generate a first order triangular element. The shape function for
 * geometry and computation is ::bem3d_shfunc_t1.
 * 
 * @@param e array of GtsEdge around the outside of the element
 * @@param v array of GtsVertex around the outside of the element
 * 
 * @@return a pointer to the new ::BEM3DElement
 */

BEM3DElement *bem3d_element_build_t1(GtsEdge **e, GtsVertex **v)

{
  BEM3DElement *el ;
  GtsFace *f ;

  g_return_val_if_fail(e != NULL, NULL) ;
  g_return_val_if_fail(v != NULL, NULL) ;
  g_return_val_if_fail(v[0] != NULL && v[1] != NULL && v[2] != NULL, NULL) ;

  if ( e[0] == NULL ) e[0] = connect_vertices(gts_edge_class(), v[0], v[1]) ;
  if ( e[1] == NULL ) e[1] = connect_vertices(gts_edge_class(), v[1], v[2]) ;
  if ( e[2] == NULL ) e[2] = connect_vertices(gts_edge_class(), v[2], v[0]) ;

  if ( !gts_segment_connect(GTS_SEGMENT(e[0]), v[0], v[1]) )
    g_error("%s: e[0] does not connect v[0] and v[1];", __FUNCTION__) ;
  if ( !gts_segment_connect(GTS_SEGMENT(e[1]), v[1], v[2]) )
    g_error("%s: e[1] does not connect v[1] and v[2];", __FUNCTION__) ;
  if ( !gts_segment_connect(GTS_SEGMENT(e[2]), v[2], v[0]) )
    g_error("%s: e[2] does not connect v[2] and v[0];", __FUNCTION__) ;

  el = bem3d_element_new(bem3d_element_class(),
			 1, 3, 0, 3,
			 bem3d_shfunc_t1, bem3d_shfunc_t1) ;

  bem3d_element_add_vertex(el, v[0], 0) ;
  bem3d_element_set_corner(el, 0, 0) ;
  bem3d_element_add_vertex(el, v[1], 1) ;
  bem3d_element_set_corner(el, 1, 1) ;
  bem3d_element_add_vertex(el, v[2], 2) ;
  bem3d_element_set_corner(el, 2, 2) ;

  f = gts_face_new(gts_face_class(), e[0], e[1], e[2]) ;

  bem3d_element_add_face(el, f, 0) ;

  /*the shape and collocation point data are shared: we only need to
    deal with one of them*/
  bem3d_element_vertex_xi(el,0) = 0.0 ;
  bem3d_element_vertex_eta(el,0) = 0.0 ;
  bem3d_element_vertex_xi(el,1) = 1.0 ;
  bem3d_element_vertex_eta(el,1) = 0.0 ;
  bem3d_element_vertex_xi(el,2) = 0.0 ;
  bem3d_element_vertex_eta(el,2) = 1.0 ;

  return el ;
}

/** 
 * Generate a second order triangular element.  The shape function for
 * geometry and computation is ::bem3d_shfunc_t2.
 * 
 * @@param e array of GtsEdge around the outside of the element
 * @@param v array of GtsVertex around the outside of the element
 * 
 * @@return a pointer to the new element
 */

BEM3DElement *bem3d_element_build_t2(GtsEdge **e, GtsVertex **v)

{
  BEM3DElement *el ;
  GtsEdge *e1, *e2, *e3 ;
  GtsFace *f ;

  g_return_val_if_fail(e != NULL, NULL) ;
  g_return_val_if_fail(v != NULL, NULL) ;

  el = bem3d_element_new(bem3d_element_class(),
		       4, 6, 0, 3,
		       bem3d_shfunc_t2, bem3d_shfunc_t2) ;

  e[0] = connect_vertices(gts_edge_class(), v[0], v[1]) ;
  e[1] = connect_vertices(gts_edge_class(), v[1], v[2]) ;
  e[2] = connect_vertices(gts_edge_class(), v[2], v[3]) ;
  e[3] = connect_vertices(gts_edge_class(), v[3], v[4]) ;
  e[4] = connect_vertices(gts_edge_class(), v[4], v[5]) ;
  e[5] = connect_vertices(gts_edge_class(), v[5], v[0]) ;

  e1 = connect_vertices(gts_edge_class(), v[1], v[5]) ;
  e2 = connect_vertices(gts_edge_class(), v[1], v[3]) ;
  e3 = connect_vertices(gts_edge_class(), v[3], v[5]) ;

  bem3d_element_add_vertex(el, v[0], 0) ;
  bem3d_element_set_corner(el, 0, 0) ;
  bem3d_element_add_vertex(el, v[2], 1) ;
  bem3d_element_set_corner(el, 1, 1) ;
  bem3d_element_add_vertex(el, v[4], 2) ;
  bem3d_element_set_corner(el, 2, 2) ;

  bem3d_element_add_vertex(el, v[1], 3) ;
  bem3d_element_add_vertex(el, v[3], 4) ;
  bem3d_element_add_vertex(el, v[5], 5) ;

  f = gts_face_new(gts_face_class(), e[0], e1, e[5]) ;
  bem3d_element_add_face(el, f, 0) ;

  f = gts_face_new(gts_face_class(), e[1], e[2], e2) ;
  bem3d_element_add_face(el, f, 1) ;

  f = gts_face_new(gts_face_class(), e1, e2, e3) ;
  bem3d_element_add_face(el, f, 2) ;

  f = gts_face_new(gts_face_class(), e3, e[3], e[4]) ;
  bem3d_element_add_face(el, f, 3) ;

  bem3d_element_vertex_xi(el,0) = 0.0 ;
  bem3d_element_vertex_eta(el,0) = 0.0 ;
  bem3d_element_vertex_xi(el,1) = 1.0 ;
  bem3d_element_vertex_eta(el,1) = 0.0 ;
  bem3d_element_vertex_xi(el,2) = 0.0 ;
  bem3d_element_vertex_eta(el,2) = 1.0 ;
  bem3d_element_vertex_xi(el,3) = 0.5 ;
  bem3d_element_vertex_eta(el,3) = 0.0 ;
  bem3d_element_vertex_xi(el,4) = 0.5 ;
  bem3d_element_vertex_eta(el,4) = 0.5 ;
  bem3d_element_vertex_xi(el,5) = 0.0 ;
  bem3d_element_vertex_eta(el,5) = 0.5 ;

  return el ;
}

/** 
 * Generate a third order triangular element.  The shape function for
 * geometry and computation is ::bem3d_shfunc_t3. If the tenth GtsVertex
 * in \a v is NULL, the centre vertex is the centroid of the supplied
 * vertices, otherwise \a v[9] is used. 
 * 
 * @@param e array of GtsEdge around the outside of the element
 * @@param v array of GtsVertex around the outside of the element
 * 
 * @@return a pointer to the new element
 */

BEM3DElement *bem3d_element_build_t3(GtsEdge **e, GtsVertex **v)

{
  BEM3DElement *el ;
  GtsEdge *e1, *e2, *e3, *e4, *e5, *e6, *e7, *e8, *e9 ;
  GtsFace *f ;
  GtsVertex *v1 ;

  g_return_val_if_fail(e != NULL, NULL) ;
  g_return_val_if_fail(v != NULL, NULL) ;

  if ( v[9] == NULL ) 
    v1 = gts_vertex_new(gts_vertex_class(),
			(GTS_POINT(v[0])->x+
			 GTS_POINT(v[3])->x+
			 GTS_POINT(v[6])->x)/3.0,
			(GTS_POINT(v[0])->y+
			 GTS_POINT(v[3])->y+
			 GTS_POINT(v[6])->y)/3.0,
			(GTS_POINT(v[0])->z+
			 GTS_POINT(v[3])->z+
			 GTS_POINT(v[6])->z)/3.0) ;
  else 
    v1 = v[9] ;

  el = bem3d_element_new(bem3d_element_class(),
			 9, 10, 0, 3, bem3d_shfunc_t3, bem3d_shfunc_t3) ;

  /*element corners*/
  bem3d_element_add_vertex(el, v[0], 0) ;
  bem3d_element_set_corner(el, 0, 0) ;
  bem3d_element_add_vertex(el, v[3], 1) ;
  bem3d_element_set_corner(el, 1, 1) ;
  bem3d_element_add_vertex(el, v[6], 2) ;
  bem3d_element_set_corner(el, 2, 2) ;

  /*element edges*/
  bem3d_element_add_vertex(el, v[1], 3) ;
  bem3d_element_add_vertex(el, v[2], 4) ;
  bem3d_element_add_vertex(el, v[4], 5) ;
  bem3d_element_add_vertex(el, v[5], 6) ;
  bem3d_element_add_vertex(el, v[7], 7) ;
  bem3d_element_add_vertex(el, v[8], 8) ;
  bem3d_element_add_vertex(el, v1,   9) ;

  /*edges*/
  e1 = gts_edge_new(gts_edge_class(), el->v[3], el->v[8]) ;
  e2 = gts_edge_new(gts_edge_class(), el->v[3], el->v[9]) ;
  e3 = gts_edge_new(gts_edge_class(), el->v[4], el->v[9]) ;
  e4 = gts_edge_new(gts_edge_class(), el->v[4], el->v[5]) ;
  e5 = gts_edge_new(gts_edge_class(), el->v[8], el->v[9]) ;
  e6 = gts_edge_new(gts_edge_class(), el->v[9], el->v[5]) ;
  e7 = gts_edge_new(gts_edge_class(), el->v[7], el->v[9]) ;
  e8 = gts_edge_new(gts_edge_class(), el->v[6], el->v[9]) ;
  e9 = gts_edge_new(gts_edge_class(), el->v[7], el->v[6]) ;
  
  f = gts_face_new(gts_face_class(), e[0], e1, e[8]) ;
  bem3d_element_add_face(el, f, 0) ;

  f = gts_face_new(gts_face_class(), e1, e2, e5) ;
  bem3d_element_add_face(el, f, 1) ;

  f = gts_face_new(gts_face_class(), e[1], e3, e2) ;
  bem3d_element_add_face(el, f, 2) ;

  f = gts_face_new(gts_face_class(), e3, e4, e6) ;
  bem3d_element_add_face(el, f, 3) ;

  f = gts_face_new(gts_face_class(), e[2], e[3], e4) ;
  bem3d_element_add_face(el, f, 4) ;

  f = gts_face_new(gts_face_class(), e5, e7, e[7]) ;
  bem3d_element_add_face(el, f, 5) ;

  f = gts_face_new(gts_face_class(), e7, e8, e9) ;
  bem3d_element_add_face(el, f, 6) ;

  f = gts_face_new(gts_face_class(), e6, e[4], e8) ;
  bem3d_element_add_face(el, f, 7) ;

  f = gts_face_new(gts_face_class(), e[5], e[6], e9) ;
  bem3d_element_add_face(el, f, 8) ;

  bem3d_element_vertex_xi(el,0) = 0.0 ;
  bem3d_element_vertex_eta(el,0) = 0.0 ;

  bem3d_element_vertex_xi(el,1) = 1.0 ;
  bem3d_element_vertex_eta(el,1) = 0.0 ;

  bem3d_element_vertex_xi(el,2) = 0.0 ;
  bem3d_element_vertex_eta(el,2) = 1.0 ;

  bem3d_element_vertex_xi(el,3) = 1.0/3.0 ;
  bem3d_element_vertex_eta(el,3) = 0.0 ;

  bem3d_element_vertex_xi(el,4) = 2.0/3.0 ;
  bem3d_element_vertex_eta(el,4) = 0.0 ;

  bem3d_element_vertex_xi(el,5) = 2.0/3.0 ;
  bem3d_element_vertex_eta(el,5) = 1.0/3.0 ;

  bem3d_element_vertex_xi(el,6) = 1.0/3.0 ;
  bem3d_element_vertex_eta(el,6) = 2.0/3.0 ;

  bem3d_element_vertex_xi(el,7) = 0.0 ;
  bem3d_element_vertex_eta(el,7) = 2.0/3.0 ;

  bem3d_element_vertex_xi(el,8) = 0.0 ;
  bem3d_element_vertex_eta(el,8) = 1.0/3.0 ;

  bem3d_element_vertex_xi(el,9) = 1.0/3.0 ;
  bem3d_element_vertex_eta(el,9) = 1.0/3.0 ;

  return el ;
}

/** 
 * Generate a first order quadrilateral element.  The shape function
 * for geometry and computation is ::bem3d_shfunc_q1.
 * 
 * @@param e array of GtsEdge around the outside of the element
 * @@param v array of GtsVertex around the outside of the element
 * 
 * @@return a pointer to the new element
 */

BEM3DElement *bem3d_element_build_q1(GtsEdge **e, GtsVertex **v)

{
  BEM3DElement *el ;
  GtsFace *f ;

  g_return_val_if_fail(e != NULL, NULL) ;
  g_return_val_if_fail(v != NULL, NULL) ;

  if ( e[0] == NULL ) e[0] = connect_vertices(gts_edge_class(), v[0], v[1]) ;
  if ( e[1] == NULL ) e[1] = connect_vertices(gts_edge_class(), v[1], v[2]) ;
  if ( e[2] == NULL ) e[2] = connect_vertices(gts_edge_class(), v[2], v[3]) ;
  if ( e[3] == NULL ) e[3] = connect_vertices(gts_edge_class(), v[3], v[0]) ;
  if ( e[4] == NULL ) e[4] = connect_vertices(gts_edge_class(), v[0], v[2]) ;

  if ( !gts_segment_connect(GTS_SEGMENT(e[0]), v[0], v[1]) )
    g_error("%s: e[0] does not connect v[0] and v[1];", __FUNCTION__) ;
  if ( !gts_segment_connect(GTS_SEGMENT(e[1]), v[1], v[2]) )
    g_error("%s: e[1] does not connect v[1] and v[2];", __FUNCTION__) ;
  if ( !gts_segment_connect(GTS_SEGMENT(e[2]), v[2], v[3]) )
    g_error("%s: e[2] does not connect v[2] and v[3];", __FUNCTION__) ;
  if ( !gts_segment_connect(GTS_SEGMENT(e[3]), v[3], v[0]) )
    g_error("%s: e[3] does not connect v[3] and v[0];", __FUNCTION__) ;
  if ( !gts_segment_connect(GTS_SEGMENT(e[4]), v[0], v[2]) )
    g_error("%s: e[4] does not connect v[0] and v[2];", __FUNCTION__) ;

  el = bem3d_element_new(bem3d_element_class(),
			 2, 4, 0, 4, bem3d_shfunc_q1, bem3d_shfunc_q1) ;  
  bem3d_element_add_vertex(el, v[0], 0) ;
  bem3d_element_add_vertex(el, v[1], 1) ;
  bem3d_element_add_vertex(el, v[2], 2) ;
  bem3d_element_add_vertex(el, v[3], 3) ;
  bem3d_element_set_corner(el, 0, 0) ;
  bem3d_element_set_corner(el, 1, 1) ;
  bem3d_element_set_corner(el, 2, 2) ;
  bem3d_element_set_corner(el, 3, 3) ;

  f = gts_face_new(gts_face_class(), e[0], e[1], e[4]) ;
  bem3d_element_add_face(el, f, 0) ;
  f = gts_face_new(gts_face_class(), e[4], e[2], e[3]) ;
  bem3d_element_add_face(el, f, 1) ;

  bem3d_element_vertex_xi(el,0) = 0.0 ;
  bem3d_element_vertex_eta(el,0) = 0.0 ;
  bem3d_element_vertex_xi(el,1) = 1.0 ;
  bem3d_element_vertex_eta(el,1) = 0.0 ;
  bem3d_element_vertex_xi(el,2) = 1.0 ;
  bem3d_element_vertex_eta(el,2) = 1.0 ;
  bem3d_element_vertex_xi(el,3) = 0.0 ;
  bem3d_element_vertex_eta(el,3) = 1.0 ;

  return el ;
}

/** 
 * Generate a second order quadrilateral element, based on the GMSH
 * nine point quad. The shape function for geometry and computation is
 * ::bem3d_shfunc_q2. 
 * 
 * @@param e array of GtsEdge around the outside of the element
 * @@param v array of GtsVertex around the outside of the element
 * 
 * @@return a pointer to the new element
 */

BEM3DElement *bem3d_element_build_q2(GtsEdge **e, GtsVertex **v)

{
  BEM3DElement *el ;
  GtsEdge *e1, *e2, *e3, *e4, *e5, *e6, *e7, *e8 ;
  GtsFace *f ;

  g_return_val_if_fail(e != NULL, NULL) ;
  g_return_val_if_fail(v != NULL, NULL) ;

  el = bem3d_element_new(bem3d_element_class(),
		       8, 9, 0, 4, bem3d_shfunc_q2, bem3d_shfunc_q2) ;  

  bem3d_element_add_vertex(el, v[0], 0) ;
  bem3d_element_add_vertex(el, v[2], 1) ;
  bem3d_element_add_vertex(el, v[4], 2) ;
  bem3d_element_add_vertex(el, v[6], 3) ;

  bem3d_element_add_vertex(el, v[1], 4) ;
  bem3d_element_add_vertex(el, v[3], 5) ;
  bem3d_element_add_vertex(el, v[5], 6) ;
  bem3d_element_add_vertex(el, v[7], 7) ;

  if ( v[8] == NULL ) {
    v[8] = gts_vertex_new(gts_vertex_class(),
			  (GTS_POINT(v[0])->x+
			   GTS_POINT(v[2])->x+
			   GTS_POINT(v[4])->x+
			   GTS_POINT(v[6])->x)*0.25,
			  (GTS_POINT(v[0])->y+
			   GTS_POINT(v[2])->y+
			   GTS_POINT(v[4])->y+
			   GTS_POINT(v[6])->y)*0.25,
			  (GTS_POINT(v[0])->z+
			   GTS_POINT(v[2])->z+
			   GTS_POINT(v[4])->z+
			   GTS_POINT(v[6])->z)*0.25) ;
  }

  bem3d_element_add_vertex(el, v[8], 8) ;

  bem3d_element_set_corner(el, 0, 0) ;
  bem3d_element_set_corner(el, 1, 1) ;
  bem3d_element_set_corner(el, 2, 2) ;
  bem3d_element_set_corner(el, 3, 3) ;

  e[0] = connect_vertices(gts_edge_class(), v[0], v[1]) ;
  e[1] = connect_vertices(gts_edge_class(), v[1], v[2]) ;
  e[2] = connect_vertices(gts_edge_class(), v[2], v[3]) ;
  e[3] = connect_vertices(gts_edge_class(), v[3], v[4]) ;
  e[4] = connect_vertices(gts_edge_class(), v[4], v[5]) ;
  e[5] = connect_vertices(gts_edge_class(), v[5], v[6]) ;
  e[6] = connect_vertices(gts_edge_class(), v[6], v[7]) ;
  e[7] = connect_vertices(gts_edge_class(), v[7], v[0]) ;
  
  e1 = connect_vertices(gts_edge_class(), v[0], v[8]) ;
  e2 = connect_vertices(gts_edge_class(), v[1], v[8]) ;
  e3 = connect_vertices(gts_edge_class(), v[2], v[8]) ;
  e4 = connect_vertices(gts_edge_class(), v[3], v[8]) ;
  e5 = connect_vertices(gts_edge_class(), v[4], v[8]) ;
  e6 = connect_vertices(gts_edge_class(), v[5], v[8]) ;
  e7 = connect_vertices(gts_edge_class(), v[6], v[8]) ;
  e8 = connect_vertices(gts_edge_class(), v[7], v[8]) ;

  f = gts_face_new(gts_face_class(), e[0], e2, e1) ;
  bem3d_element_add_face(el, f, 0) ;
  f = gts_face_new(gts_face_class(), e[1], e3, e2) ;
  bem3d_element_add_face(el, f, 1) ;
  f = gts_face_new(gts_face_class(), e[2], e4, e3) ;
  bem3d_element_add_face(el, f, 2) ;
  f = gts_face_new(gts_face_class(), e[3], e5, e4) ;
  bem3d_element_add_face(el, f, 3) ;
  f = gts_face_new(gts_face_class(), e[4], e6, e5) ;
  bem3d_element_add_face(el, f, 4) ;
  f = gts_face_new(gts_face_class(), e[5], e7, e6) ;
  bem3d_element_add_face(el, f, 5) ;
  f = gts_face_new(gts_face_class(), e[6], e8, e7) ;
  bem3d_element_add_face(el, f, 6) ;
  f = gts_face_new(gts_face_class(), e[7], e1, e8) ;
  bem3d_element_add_face(el, f, 7) ;

  bem3d_element_vertex_xi(el,0) = -1.0 ;
  bem3d_element_vertex_eta(el,0) = -1.0 ;
  bem3d_element_vertex_xi(el,1) = 1.0 ;
  bem3d_element_vertex_eta(el,1) = -1.0 ;
  bem3d_element_vertex_xi(el,2) = 1.0 ;
  bem3d_element_vertex_eta(el,2) = 1.0 ;
  bem3d_element_vertex_xi(el,3) = -1.0 ;
  bem3d_element_vertex_eta(el,3) = 1.0 ;

  bem3d_element_vertex_xi(el,4) = 0.0 ;
  bem3d_element_vertex_eta(el,4) = -1.0 ;
  bem3d_element_vertex_xi(el,5) = 1.0 ;
  bem3d_element_vertex_eta(el,5) = 0.0 ;
  bem3d_element_vertex_xi(el,6) = 0.0 ;
  bem3d_element_vertex_eta(el,6) = 1.0 ;
  bem3d_element_vertex_xi(el,7) = -1.0 ;
  bem3d_element_vertex_eta(el,7) = 0.0 ;

  bem3d_element_vertex_xi(el,8) = 0.0 ;
  bem3d_element_vertex_eta(el,8) = 0.0 ;

  return el ;
}

/**
 * @@}
 * 
 */
@


1.4
log
@*** empty log message ***
@
text
@d3 1
a3 1
 * Copyright (C) 2006 Michael Carley
@


1.3
log
@*** empty log message ***
@
text
@d49 2
a50 1
GtsEdge *connect_vertices(GtsVertex *v1, GtsVertex *v2)
d53 1
a53 1
  GtsEdge *e = NULL ;
d56 1
a56 1
    e = gts_edge_new(gts_edge_class(), v1, v2) ;
d129 1
a129 1

d151 12
d165 2
a166 2
		       1, 3, 0, 3,
		       bem3d_shfunc_t1, bem3d_shfunc_t1) ;
a193 1

d215 10
a224 10
  e[0] = connect_vertices(v[0], v[1]) ;
  e[1] = connect_vertices(v[1], v[2]) ;
  e[2] = connect_vertices(v[2], v[3]) ;
  e[3] = connect_vertices(v[3], v[4]) ;
  e[4] = connect_vertices(v[4], v[5]) ;
  e[5] = connect_vertices(v[5], v[0]) ;

  e1 = connect_vertices(v[1], v[5]) ;
  e2 = connect_vertices(v[1], v[3]) ;
  e3 = connect_vertices(v[3], v[5]) ;
d303 1
a303 1
		       9, 10, 0, 3, bem3d_shfunc_t3, bem3d_shfunc_t3) ;
d305 1
d308 10
a317 7
  bem3d_element_add_vertex(el, v[1], 1) ;
  bem3d_element_add_vertex(el, v[2], 2) ;
  bem3d_element_add_vertex(el, v[3], 3) ;
  bem3d_element_set_corner(el, 1, 3) ;
  bem3d_element_add_vertex(el, v[8], 4) ;
  bem3d_element_add_vertex(el, v1, 5) ;
  bem3d_element_add_vertex(el, v[4], 6) ;
d319 2
a320 13
  bem3d_element_add_vertex(el, v[5], 8) ;
  bem3d_element_add_vertex(el, v[6], 9) ;
  bem3d_element_set_corner(el, 2, 9) ;

  e1 = gts_edge_new(gts_edge_class(), el->v[1], el->v[4]) ;
  e2 = gts_edge_new(gts_edge_class(), el->v[1], el->v[5]) ;
  e3 = gts_edge_new(gts_edge_class(), el->v[2], el->v[5]) ;
  e4 = gts_edge_new(gts_edge_class(), el->v[2], el->v[6]) ;
  e5 = gts_edge_new(gts_edge_class(), el->v[4], el->v[5]) ;
  e6 = gts_edge_new(gts_edge_class(), el->v[5], el->v[6]) ;
  e7 = gts_edge_new(gts_edge_class(), el->v[5], el->v[7]) ;
  e8 = gts_edge_new(gts_edge_class(), el->v[5], el->v[8]) ;
  e9 = gts_edge_new(gts_edge_class(), el->v[7], el->v[8]) ;
d322 11
d342 1
a342 1
  f = gts_face_new(gts_face_class(), e4, e6, e3) ;
d348 1
a348 1
  f = gts_face_new(gts_face_class(), e[7], e5, e7) ;
d357 1
a357 1
  f = gts_face_new(gts_face_class(), e9, e[5], e[6]) ;
d363 1
a363 1
  bem3d_element_vertex_xi(el,1) = 1.0/3.0 ;
d366 2
a367 2
  bem3d_element_vertex_xi(el,2) = 2.0/3.0 ;
  bem3d_element_vertex_eta(el,2) = 0.0 ;
d369 1
a369 1
  bem3d_element_vertex_xi(el,3) = 1.0 ;
d372 2
a373 2
  bem3d_element_vertex_xi(el,4) = 0.0 ;
  bem3d_element_vertex_eta(el,4) = 1.0/3.0 ;
d375 1
a375 1
  bem3d_element_vertex_xi(el,5) = 1.0/3.0 ;
d378 2
a379 2
  bem3d_element_vertex_xi(el,6) = 2.0/3.0 ;
  bem3d_element_vertex_eta(el,6) = 1.0/3.0 ;
d384 2
a385 2
  bem3d_element_vertex_xi(el,8) = 1.0/3.0 ;
  bem3d_element_vertex_eta(el,8) = 2.0/3.0 ;
d387 2
a388 2
  bem3d_element_vertex_xi(el,9) = 0.0 ;
  bem3d_element_vertex_eta(el,9) = 1.0 ;
a406 1
  GtsEdge *e1 ;
d412 17
d430 1
a430 1
		       2, 4, 0, 4, bem3d_shfunc_q1, bem3d_shfunc_q1) ;  
d440 1
a440 2
  e1 = gts_edge_new(gts_edge_class(), v[0], v[2]) ;
  f = gts_face_new(gts_face_class(), e[0], e[1], e1) ;
d442 1
a442 1
  f = gts_face_new(gts_face_class(), e1, e[2], e[3]) ;
d514 8
a521 8
  e[0] = connect_vertices(v[0], v[1]) ;
  e[1] = connect_vertices(v[1], v[2]) ;
  e[2] = connect_vertices(v[2], v[3]) ;
  e[3] = connect_vertices(v[3], v[4]) ;
  e[4] = connect_vertices(v[4], v[5]) ;
  e[5] = connect_vertices(v[5], v[6]) ;
  e[6] = connect_vertices(v[6], v[7]) ;
  e[7] = connect_vertices(v[7], v[0]) ;
d523 8
a530 8
  e1 = connect_vertices(v[0], v[8]) ;
  e2 = connect_vertices(v[1], v[8]) ;
  e3 = connect_vertices(v[2], v[8]) ;
  e4 = connect_vertices(v[3], v[8]) ;
  e5 = connect_vertices(v[4], v[8]) ;
  e6 = connect_vertices(v[5], v[8]) ;
  e7 = connect_vertices(v[6], v[8]) ;
  e8 = connect_vertices(v[7], v[8]) ;
@


1.2
log
@*** empty log message ***
@
text
@d79 3
d148 3
d196 3
d273 3
d394 3
d444 3
@


1.1
log
@Initial revision
@
text
@d23 1
a23 1
 * BEMLib can handle a wide range of elements and some of them are
d26 1
a26 1
 * BEMElementBuildFunc type defines a function which takes as input
d30 1
a30 1
 * exception of ::bem_element_build_t3 and ::bem_element_build_q2
d36 5
d46 2
a47 2
#include "bem.h"
#include "bem-private.h"
d62 2
a63 2
 * computation is ::bem_shfunc_t0 and for the geometry is
 * ::bem_shfunc_t1.
d71 1
a71 1
BEMElement *bem_element_build_t0(GtsEdge **e, GtsVertex **v)
d74 1
a74 1
  BEMElement *el ;
d79 1
a79 1
  el = bem_element_new(bem_element_class(),
d81 1
a81 1
		       bem_shfunc_t1, bem_shfunc_t0) ;
d83 6
a88 6
  bem_element_add_vertex(el, v[0], 0) ;
  bem_element_set_corner(el, 0, 0) ;
  bem_element_add_vertex(el, v[1], 1) ;
  bem_element_set_corner(el, 1, 1) ;
  bem_element_add_vertex(el, v[2], 2) ;
  bem_element_set_corner(el, 2, 2) ;
d106 1
a106 1
  bem_element_add_face(el, f, 0) ;
d109 1
a109 1
  bem_element_add_face(el, f, 1) ;
d112 1
a112 1
  bem_element_add_face(el, f, 2) ;
d114 1
a114 1
  bem_element_add_cpt(el, v1, 0) ;
d116 2
a117 2
  bem_element_cpt_xi(el,0) = 1/3.0 ;
  bem_element_cpt_eta(el,0) = 1/3.0 ;
d119 6
a124 6
  bem_element_node_xi(el,0) = 0.0 ;
  bem_element_node_eta(el,0) = 0.0 ;
  bem_element_node_xi(el,1) = 1.0 ;
  bem_element_node_eta(el,1) = 0.0 ;
  bem_element_node_xi(el,2) = 0.0 ;
  bem_element_node_eta(el,2) = 1.0 ;
d131 1
a131 1
 * geometry and computation is ::bem_shfunc_t1.
d136 1
a136 1
 * @@return a pointer to the new ::BEMElement
d139 1
a139 1
BEMElement *bem_element_build_t1(GtsEdge **e, GtsVertex **v)
d142 1
a142 1
  BEMElement *el ;
d145 1
a145 1
  el = bem_element_new(bem_element_class(),
d147 1
a147 1
		       bem_shfunc_t1, bem_shfunc_t1) ;
d149 6
a154 6
  bem_element_add_vertex(el, v[0], 0) ;
  bem_element_set_corner(el, 0, 0) ;
  bem_element_add_vertex(el, v[1], 1) ;
  bem_element_set_corner(el, 1, 1) ;
  bem_element_add_vertex(el, v[2], 2) ;
  bem_element_set_corner(el, 2, 2) ;
d158 1
a158 1
  bem_element_add_face(el, f, 0) ;
d162 6
a167 6
  bem_element_node_xi(el,0) = 0.0 ;
  bem_element_node_eta(el,0) = 0.0 ;
  bem_element_node_xi(el,1) = 1.0 ;
  bem_element_node_eta(el,1) = 0.0 ;
  bem_element_node_xi(el,2) = 0.0 ;
  bem_element_node_eta(el,2) = 1.0 ;
d174 1
a174 1
 * geometry and computation is ::bem_shfunc_t2.
d183 1
a183 1
BEMElement *bem_element_build_t2(GtsEdge **e, GtsVertex **v)
d186 1
a186 1
  BEMElement *el ;
d190 1
a190 1
  el = bem_element_new(bem_element_class(),
d192 1
a192 1
		       bem_shfunc_t2, bem_shfunc_t2) ;
d205 10
a214 10
  bem_element_add_vertex(el, v[0], 0) ;
  bem_element_set_corner(el, 0, 0) ;
  bem_element_add_vertex(el, v[2], 1) ;
  bem_element_set_corner(el, 1, 1) ;
  bem_element_add_vertex(el, v[4], 2) ;
  bem_element_set_corner(el, 2, 2) ;

  bem_element_add_vertex(el, v[1], 3) ;
  bem_element_add_vertex(el, v[3], 4) ;
  bem_element_add_vertex(el, v[5], 5) ;
d217 1
a217 1
  bem_element_add_face(el, f, 0) ;
d220 1
a220 1
  bem_element_add_face(el, f, 1) ;
d223 1
a223 1
  bem_element_add_face(el, f, 2) ;
d226 1
a226 1
  bem_element_add_face(el, f, 3) ;
d228 12
a239 12
  bem_element_node_xi(el,0) = 0.0 ;
  bem_element_node_eta(el,0) = 0.0 ;
  bem_element_node_xi(el,1) = 1.0 ;
  bem_element_node_eta(el,1) = 0.0 ;
  bem_element_node_xi(el,2) = 0.0 ;
  bem_element_node_eta(el,2) = 1.0 ;
  bem_element_node_xi(el,3) = 0.5 ;
  bem_element_node_eta(el,3) = 0.0 ;
  bem_element_node_xi(el,4) = 0.5 ;
  bem_element_node_eta(el,4) = 0.5 ;
  bem_element_node_xi(el,5) = 0.0 ;
  bem_element_node_eta(el,5) = 0.5 ;
d246 1
a246 1
 * geometry and computation is ::bem_shfunc_t3. If the tenth GtsVertex
d256 1
a256 1
BEMElement *bem_element_build_t3(GtsEdge **e, GtsVertex **v)
d259 1
a259 1
  BEMElement *el ;
d278 2
a279 2
  el = bem_element_new(bem_element_class(),
		       9, 10, 0, 3, bem_shfunc_t3, bem_shfunc_t3) ;
d281 13
a293 13
  bem_element_add_vertex(el, v[0], 0) ;
  bem_element_set_corner(el, 0, 0) ;
  bem_element_add_vertex(el, v[1], 1) ;
  bem_element_add_vertex(el, v[2], 2) ;
  bem_element_add_vertex(el, v[3], 3) ;
  bem_element_set_corner(el, 1, 3) ;
  bem_element_add_vertex(el, v[8], 4) ;
  bem_element_add_vertex(el, v1, 5) ;
  bem_element_add_vertex(el, v[4], 6) ;
  bem_element_add_vertex(el, v[7], 7) ;
  bem_element_add_vertex(el, v[5], 8) ;
  bem_element_add_vertex(el, v[6], 9) ;
  bem_element_set_corner(el, 2, 9) ;
d306 1
a306 1
  bem_element_add_face(el, f, 0) ;
d309 1
a309 1
  bem_element_add_face(el, f, 1) ;
d312 1
a312 1
  bem_element_add_face(el, f, 2) ;
d315 1
a315 1
  bem_element_add_face(el, f, 3) ;
d318 1
a318 1
  bem_element_add_face(el, f, 4) ;
d321 1
a321 1
  bem_element_add_face(el, f, 5) ;
d324 1
a324 1
  bem_element_add_face(el, f, 6) ;
d327 1
a327 1
  bem_element_add_face(el, f, 7) ;
d330 1
a330 1
  bem_element_add_face(el, f, 8) ;
d332 2
a333 2
  bem_element_node_xi(el,0) = 0.0 ;
  bem_element_node_eta(el,0) = 0.0 ;
d335 2
a336 2
  bem_element_node_xi(el,1) = 1.0/3.0 ;
  bem_element_node_eta(el,1) = 0.0 ;
d338 2
a339 2
  bem_element_node_xi(el,2) = 2.0/3.0 ;
  bem_element_node_eta(el,2) = 0.0 ;
d341 2
a342 2
  bem_element_node_xi(el,3) = 1.0 ;
  bem_element_node_eta(el,3) = 0.0 ;
d344 2
a345 2
  bem_element_node_xi(el,4) = 0.0 ;
  bem_element_node_eta(el,4) = 1.0/3.0 ;
d347 2
a348 2
  bem_element_node_xi(el,5) = 1.0/3.0 ;
  bem_element_node_eta(el,5) = 1.0/3.0 ;
d350 2
a351 2
  bem_element_node_xi(el,6) = 2.0/3.0 ;
  bem_element_node_eta(el,6) = 1.0/3.0 ;
d353 2
a354 2
  bem_element_node_xi(el,7) = 0.0 ;
  bem_element_node_eta(el,7) = 2.0/3.0 ;
d356 2
a357 2
  bem_element_node_xi(el,8) = 1.0/3.0 ;
  bem_element_node_eta(el,8) = 2.0/3.0 ;
d359 2
a360 2
  bem_element_node_xi(el,9) = 0.0 ;
  bem_element_node_eta(el,9) = 1.0 ;
d367 1
a367 1
 * for geometry and computation is ::bem_shfunc_q1.
d375 1
a375 1
BEMElement *bem_element_build_q1(GtsEdge **e, GtsVertex **v)
d378 1
a378 1
  BEMElement *el ;
d382 10
a391 10
  el = bem_element_new(bem_element_class(),
		       2, 4, 0, 4, bem_shfunc_q1, bem_shfunc_q1) ;  
  bem_element_add_vertex(el, v[0], 0) ;
  bem_element_add_vertex(el, v[1], 1) ;
  bem_element_add_vertex(el, v[2], 2) ;
  bem_element_add_vertex(el, v[3], 3) ;
  bem_element_set_corner(el, 0, 0) ;
  bem_element_set_corner(el, 1, 1) ;
  bem_element_set_corner(el, 2, 2) ;
  bem_element_set_corner(el, 3, 3) ;
d395 1
a395 1
  bem_element_add_face(el, f, 0) ;
d397 1
a397 1
  bem_element_add_face(el, f, 1) ;
d399 8
a406 8
  bem_element_node_xi(el,0) = 0.0 ;
  bem_element_node_eta(el,0) = 0.0 ;
  bem_element_node_xi(el,1) = 1.0 ;
  bem_element_node_eta(el,1) = 0.0 ;
  bem_element_node_xi(el,2) = 1.0 ;
  bem_element_node_eta(el,2) = 1.0 ;
  bem_element_node_xi(el,3) = 0.0 ;
  bem_element_node_eta(el,3) = 1.0 ;
d414 1
a414 1
 * ::bem_shfunc_q2. 
d422 1
a422 1
BEMElement *bem_element_build_q2(GtsEdge **e, GtsVertex **v)
d425 1
a425 1
  BEMElement *el ;
d429 2
a430 2
  el = bem_element_new(bem_element_class(),
		       8, 9, 0, 4, bem_shfunc_q2, bem_shfunc_q2) ;  
d432 9
a440 9
  bem_element_add_vertex(el, v[0], 0) ;
  bem_element_add_vertex(el, v[2], 1) ;
  bem_element_add_vertex(el, v[4], 2) ;
  bem_element_add_vertex(el, v[6], 3) ;

  bem_element_add_vertex(el, v[1], 4) ;
  bem_element_add_vertex(el, v[3], 5) ;
  bem_element_add_vertex(el, v[5], 6) ;
  bem_element_add_vertex(el, v[7], 7) ;
d458 1
a458 1
  bem_element_add_vertex(el, v[8], 8) ;
d460 4
a463 4
  bem_element_set_corner(el, 0, 0) ;
  bem_element_set_corner(el, 1, 1) ;
  bem_element_set_corner(el, 2, 2) ;
  bem_element_set_corner(el, 3, 3) ;
d484 1
a484 1
  bem_element_add_face(el, f, 0) ;
d486 1
a486 1
  bem_element_add_face(el, f, 1) ;
d488 1
a488 1
  bem_element_add_face(el, f, 2) ;
d490 1
a490 1
  bem_element_add_face(el, f, 3) ;
d492 1
a492 1
  bem_element_add_face(el, f, 4) ;
d494 1
a494 1
  bem_element_add_face(el, f, 5) ;
d496 1
a496 1
  bem_element_add_face(el, f, 6) ;
d498 1
a498 1
  bem_element_add_face(el, f, 7) ;
d500 17
a516 17
  bem_element_node_xi(el,0) = -1.0 ;
  bem_element_node_eta(el,0) = -1.0 ;
  bem_element_node_xi(el,1) = 1.0 ;
  bem_element_node_eta(el,1) = -1.0 ;
  bem_element_node_xi(el,2) = 1.0 ;
  bem_element_node_eta(el,2) = 1.0 ;
  bem_element_node_xi(el,3) = -1.0 ;
  bem_element_node_eta(el,3) = 1.0 ;

  bem_element_node_xi(el,4) = 0.0 ;
  bem_element_node_eta(el,4) = -1.0 ;
  bem_element_node_xi(el,5) = 1.0 ;
  bem_element_node_eta(el,5) = 0.0 ;
  bem_element_node_xi(el,6) = 0.0 ;
  bem_element_node_eta(el,6) = 1.0 ;
  bem_element_node_xi(el,7) = -1.0 ;
  bem_element_node_eta(el,7) = 0.0 ;
d518 2
a519 2
  bem_element_node_xi(el,8) = 0.0 ;
  bem_element_node_eta(el,8) = 0.0 ;
@
