head	1.5;
access;
symbols;
locks
	ensmjc:1.5; strict;
comment	@ * @;


1.5
date	2018.08.15.15.51.30;	author ensmjc;	state Exp;
branches;
next	1.4;

1.4
date	2017.07.03.10.47.18;	author ensmjc;	state Exp;
branches;
next	1.3;

1.3
date	2009.08.17.15.28.35;	author ensmjc;	state Exp;
branches;
next	1.2;

1.2
date	2009.01.20.13.21.12;	author ensmjc;	state Exp;
branches;
next	1.1;

1.1
date	2008.10.10.10.35.44;	author ensmjc;	state Exp;
branches;
next	;


desc
@@


1.5
log
@*** empty log message ***
@
text
@/* location.c
 * 
 * Copyright (C) 2006, 2018 Michael Carley
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif /*HAVE_CONFIG_H*/

#include <stdio.h>
#include <math.h>

#include <glib.h>
#include <gts.h>

#include <gsl/gsl_multimin.h>
#include <gsl/gsl_min.h>

#include "bem3d.h"
#include "bem3d-private.h"

/**
 * 
 * @@addtogroup belement
 * @@{
 *
 */

/** 
 * Find element vertex which is closest to a GtsPoint.
 * 
 * @@param e ::BEM3DElement;
 * @@param p GtsPoint;
 * @@param i local index of closest vertex;
 * @@param R distance to closest vertex.
 * 
 * @@return ::BEM3D_SUCCESS on success.
 */

gint bem3d_element_nearest_vertex(BEM3DElement *e, GtsPoint *p, gint *i, 
				  gdouble *R) 

{
  gint j ;
  gdouble Rv ;

  g_return_val_if_fail(e != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(BEM3D_IS_ELEMENT(e), BEM3D_ARGUMENT_WRONG_TYPE) ;
  g_return_val_if_fail(p != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(GTS_IS_POINT(p), BEM3D_ARGUMENT_WRONG_TYPE) ;
  g_return_val_if_fail(i != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(R != NULL, BEM3D_NULL_ARGUMENT) ;

  *R = G_MAXDOUBLE ;
  for ( j = 0 ; j < bem3d_element_vertex_number(e) ; j ++ ) {
    Rv = gts_point_distance2(p, e->v[j]) ;
    if ( Rv < *R ) { *i = j ; *R = Rv ; }
  }
  
  *R = sqrt(*R) ;

  return BEM3D_SUCCESS ;
}

/** 
 * Given the local coordinates of a point on an element, check if it
 * lies inside the element.
 * 
 * @@param e ::BEM3DElement
 * @@param xi first local coordinate of point to check
 * @@param eta second local coordinate of point to check
 * 
 * @@return TRUE if (\a xi, \a eta) lies inside the element, FALSE
 * otherwise.
 */

gboolean bem3d_element_point_inside(BEM3DElement *e, gdouble xi, gdouble eta)

{
  gint i, rot[32] ;
  gdouble xi1, eta1, xi2, eta2 ;

  g_return_val_if_fail(e != NULL, FALSE) ;
  g_return_val_if_fail(BEM3D_IS_ELEMENT(e), FALSE) ;

  g_debug("%s: e=%p", __FUNCTION__, e) ;

  rotation_indices(bem3d_element_corner_number(e), rot) ;

  for ( i = 0 ; i < bem3d_element_corner_number(e) ; i ++ ) {
    g_debug("%s: r=%d", __FUNCTION__, rot[i]) ;
    xi1 = bem3d_element_vertex_xi(e,bem3d_element_corner_index(e,rot[i])) ;
  g_debug("%s:", __FUNCTION__) ;
    eta1 = bem3d_element_vertex_eta(e,bem3d_element_corner_index(e,rot[i])) ;
    xi2 = bem3d_element_vertex_xi(e,bem3d_element_corner_index(e,rot[i+1])) ;
    eta2 = bem3d_element_vertex_eta(e,bem3d_element_corner_index(e,rot[i+1])) ;
    if ( ((xi2-xi)*(eta1-eta) - (xi1-xi)*(eta2-eta)) < 0 )
      return FALSE ;
  }


  return TRUE ;
}

static gdouble _element_area_coordinates_f(const gsl_vector *y,
					   gpointer q)

{
  gpointer *p = (gpointer *)q ;
  BEM3DElement *e = (BEM3DElement *)p[0] ;
  GtsPoint *x = (GtsPoint *)p[1] ;
  gdouble s, t, L[32], dLds[32], dLdt[32] ;
  gdouble R ;
  GtsPoint x0 ;
  GtsVector r ;

  s = gsl_vector_get(y, 0) ; t = gsl_vector_get(y, 1) ;
  e->shf(s, t, L, dLds, dLdt, NULL) ;
  bem3d_element_position(e, L, &x0) ;
  gts_vector_init(r, &x0, x) ;
  R = gts_vector_norm(r) ;

  return (R*R) ;
}

static void _element_area_coordinates_df(const gsl_vector *y,
					 gpointer q, gsl_vector *df)

{
  gpointer *p = (gpointer *)q ;
  BEM3DElement *e = (BEM3DElement *)p[0] ;
  GtsPoint *x = (GtsPoint *)p[1] ;
  gdouble s, t, L[32], dLds[32], dLdt[32] ;
  gdouble R ;
  GtsPoint x0 ;
  GtsVector r, drds, drdt ;

  s = gsl_vector_get(y, 0) ; t = gsl_vector_get(y, 1) ;
  e->shf(s, t, L, dLds, dLdt, NULL) ;
  bem3d_element_position(e, L, &x0) ;
  gts_vector_init(r, &x0, x) ;
  R = gts_vector_norm(r) ; R*= R ;

  if ( R == 0 ) {
    gsl_vector_set(df, 0, 0) ; gsl_vector_set(df, 1, 0) ;
    return ;
  }

  bem3d_element_slopes(e, dLds, dLdt, drds, drdt) ;
  gsl_vector_set(df, 0, -gts_vector_scalar(r,drds)) ;
  gsl_vector_set(df, 1, -gts_vector_scalar(r,drdt)) ;

  return ; 
}

static void _element_area_coordinates_fdf(const gsl_vector *y,
					  gpointer q,
					  gdouble *f, gsl_vector *df)

{
  gpointer *p = (gpointer *)q ;
  BEM3DElement *e = (BEM3DElement *)p[0] ;
  GtsPoint *x = (GtsPoint *)p[1] ;
  gdouble s, t, L[32], dLds[32], dLdt[32] ;
  gdouble R ;
  GtsPoint x0 ;
  GtsVector r, drds, drdt ;

  s = gsl_vector_get(y, 0) ; t = gsl_vector_get(y, 1) ;

  e->shf(s, t, L, dLds, dLdt, NULL) ;
  bem3d_element_position(e, L, &x0) ;
  gts_vector_init(r, &x0, x) ;
  R = gts_vector_norm(r) ; *f = R*R ;

  if ( R == 0 ) {
    gsl_vector_set(df, 0, 0) ; gsl_vector_set(df, 1, 0) ;
    return ;
  }

  bem3d_element_slopes(e, dLds, dLdt, drds, drdt) ;
  gsl_vector_set(df, 0, -gts_vector_scalar(r,drds)) ;
  gsl_vector_set(df, 1, -gts_vector_scalar(r,drdt)) ;

  return ; 
}

/** 
 * Given a ::BEM3DElement, find the area coordinates of the nearest
 * point to a specified GtsPoint, using a rootfinding method. The
 * point found need not lie on the ::BEM3DElement proper. For a plane
 * element, this is equivalent to projection onto the plane.
 * 
 * @@param e ::BEM3DElement;
 * @@param x GtsPoint;
 * @@param xi first area coordinate of nearest point on ::BEM3DElement;
 * @@param eta second area coordinate of nearest point on ::BEM3DElement;
 * @@param constrain if TRUE, limit the search to points which lie on the
 * element or its boundary; if FALSE, the returned point may lie outside
 * the element.
 * 
 * @@return ::BEM3D_SUCCESS on success.
 */

gint bem3d_element_nearest_point(BEM3DElement *e, GtsPoint *x,
				 gdouble *xi, gdouble *eta, 
				 gboolean constrain)

{
  gsl_multimin_function_fdf f ;
  const gsl_multimin_fdfminimizer_type *solver ;
  gsl_multimin_fdfminimizer *s ;
  gsl_vector *init ;
  gpointer p[2] ;
  gint i, iter_max, status ;

  g_debug("%s: x=(%lg,%lg,%lg)", __FUNCTION__, x->x, x->y, x->z) ;

  g_return_val_if_fail(e != NULL, FALSE) ;
  g_return_val_if_fail(BEM3D_IS_ELEMENT(e), FALSE) ;
  g_return_val_if_fail(x != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(GTS_IS_POINT(x), BEM3D_ARGUMENT_WRONG_TYPE) ;
  g_return_val_if_fail(xi != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(eta != NULL, BEM3D_NULL_ARGUMENT) ;

  i = bem3d_element_find_vertex(e, GTS_VERTEX(x)) ;
  if ( i != BEM3D_FAILURE ) {
    *xi = bem3d_element_vertex_xi(e,i) ;
    *eta = bem3d_element_vertex_eta(e,i) ;
    return BEM3D_SUCCESS ;
  }

  iter_max = 16 ;
  f.f = &_element_area_coordinates_f ;
  f.df = &_element_area_coordinates_df ;
  f.fdf = &_element_area_coordinates_fdf ;
  f.n = 2 ;
  f.params = p ;
  p[0] = e ; p[1] = x ;

  init = gsl_vector_alloc(2) ;
  gsl_vector_set(init, 0, *xi) ; gsl_vector_set(init, 1, *eta) ;
  solver = gsl_multimin_fdfminimizer_conjugate_fr ;
  s = gsl_multimin_fdfminimizer_alloc(solver, 2) ;
  gsl_multimin_fdfminimizer_set(s, &f, init, 1e-1, 1e-2) ;
  
  for ( (i = 0), (status = GSL_CONTINUE) ;
	( i < 2 ) ||
	  ((i < iter_max ) && ( status == GSL_CONTINUE)) ; i ++ ) {
    status = gsl_multimin_fdfminimizer_iterate(s) ;
    if ( status ) break ;
    status = gsl_multimin_test_gradient(s->gradient, 1e-12) ;
    if ( status != GSL_CONTINUE ) break ;
    status = gsl_multimin_test_size(s->f, 1e-12) ;
    if ( status != GSL_CONTINUE ) break ;
  }

  *xi = gsl_vector_get(s->x, 0) ; *eta = gsl_vector_get(s->x, 1) ;

  if ( constrain && ! bem3d_element_point_inside(e, *xi, *eta) ) {
    g_log(G_LOG_DOMAIN, G_LOG_LEVEL_DEBUG,
	  "%s: point (%g,%g) lies outside element, constraining",
	  __FUNCTION__, *xi, *eta) ;
/*     fprintf(stderr, "Entering constraint\n") ; */
    bem3d_element_boundary_nearest_point(e, x, xi, eta) ;
/*     fprintf(stderr, "Exiting constraint\n") ; */
  }

  g_log(G_LOG_DOMAIN, G_LOG_LEVEL_DEBUG,
	"%s: %d iterations; (s,t)=(%g,%g); f: %lg; df: (%lg,%lg); %s",
	__FUNCTION__, i, *xi, *eta,
	s->f,
	gsl_vector_get(s->gradient, 0),
	gsl_vector_get(s->gradient, 1),
	gsl_strerror(status)) ;

  gsl_multimin_fdfminimizer_free(s) ;
  gsl_vector_free(init) ;

  g_debug("%s:", __FUNCTION__) ;

  if ( i == iter_max ) return BEM3D_ITERMAX ;

  return BEM3D_SUCCESS ;
}


static gdouble edge_nearest_point_parameter(GtsPoint *x1, GtsPoint *x2,
					    GtsPoint *x)

{
  gdouble t ;
  GtsVector n, s ;

  gts_vector_init(n, x1, x2) ;
  gts_vector_init(s, x1, x) ;

  t = gts_vector_scalar(s,n)/gts_vector_scalar(n,n) ;

  return t ;
}

static gdouble edge_nearest(gdouble t, gpointer p)

{
  gpointer *q = (gpointer *)p ;
  BEM3DElement *e = BEM3D_ELEMENT(q[0]) ;
  GtsPoint *x = GTS_POINT(q[1]) ;
  gint i = *((gint *)q[2]) ;
  gint j = *((gint *)q[3]) ;
  GtsPoint *y = GTS_POINT(q[4]) ;
  gdouble L[32], xi, eta ;
  BEM3DShapeFunc shfunc ;

  shfunc = bem3d_element_shape_func(e) ;

  xi = (1-t)*bem3d_element_vertex_xi(e,i) + t*bem3d_element_vertex_xi(e,j) ;
  eta = (1-t)*bem3d_element_vertex_eta(e,i) + t*bem3d_element_vertex_eta(e,j) ;
  shfunc(xi, eta, L, NULL, NULL, NULL) ;
  bem3d_element_position(e, L, y) ;

  return (gts_point_distance(x,y)) ;
}

/** 
 * Find the area coordinates of the point on the edge of an element
 * which is closest to a point x.
 * 
 * @@param e ::BEM3DElement
 * @@param i index of first corner of edge
 * @@param j index of second corner of edge
 * @@param x  ::GtsPoint 
 * @@param xi first area coordinate of point on edge \a c0--\a c1 which 
 * is closest to \a x
 * @@param eta second area coordinate of point on edge \a i--\a j which 
 * is closest to \a x
 * 
 * @@return ::BEM3D_SUCCESS on success.
 */

gint bem3d_element_edge_nearest_point(BEM3DElement *e, gint i, gint j,
				      GtsPoint *x,
				      gdouble *xi, gdouble *eta)

{
  gint status;
  gint k = 0, kmax = 8 ;
  static const gsl_min_fminimizer_type *m;
  static gsl_min_fminimizer *s;
  gdouble a, b, t ;
  gsl_function f ;
  static GtsPoint *y = NULL ;
  gpointer p[8] ;

  g_debug("%s:", __FUNCTION__) ;

  g_return_val_if_fail(e != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(BEM3D_IS_ELEMENT(e), BEM3D_ARGUMENT_WRONG_TYPE) ;
  g_return_val_if_fail(x != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(GTS_IS_POINT(x), BEM3D_ARGUMENT_WRONG_TYPE) ;
  g_return_val_if_fail(xi != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(eta != NULL, BEM3D_NULL_ARGUMENT) ;

  f.function = &edge_nearest ;
  f.params = p ;
  if ( y == NULL ) {
    m = gsl_min_fminimizer_brent;
    s = gsl_min_fminimizer_alloc(m);
    y = gts_point_new(gts_point_class(), 0, 0, 0) ;
  }
  p[0] = e ; p[1] = x ; p[2] = &i ; p[3] = &j ; p[4] = y ;
  
  t = edge_nearest_point_parameter(bem3d_element_vertex(e,i),
				   bem3d_element_vertex(e,j),
				   x) ;

  gsl_min_fminimizer_set(s, &f, t, t-1.0, t+1.0) ;

  k = 0 ;
  do {
    k ++ ;
    status = gsl_min_fminimizer_iterate(s) ;
    t = gsl_min_fminimizer_x_minimum(s) ;
    a = gsl_min_fminimizer_x_lower(s) ;
    b = gsl_min_fminimizer_x_upper(s) ;

    status = gsl_min_test_interval(a, b, 1e-6, 0.0);

  } while ( (k < kmax) && (status == GSL_CONTINUE) ) ;

  if ( t < 0 ) t = 0.0 ; if ( t > 1 ) t = 1.0 ;
  *xi = (1-t)*bem3d_element_vertex_xi(e,i) + t*bem3d_element_vertex_xi(e,j) ;
  *eta = (1-t)*bem3d_element_vertex_eta(e,i) + t*bem3d_element_vertex_eta(e,j) ;

  return BEM3D_SUCCESS ;
}

/** 
 * Find the area coordinates of the point on any edge of an element
 * which is closest to a point x.
 * 
 * @@param e ::BEM3DElement
 * @@param x  ::GtsPoint 
 * @@param xi first area coordinate of point on edge \a c0--\a c1 which 
 * is closest to \a x
 * @@param eta second area coordinate of point on edge \a i--\a j which 
 * is closest to \a x
 * 
 * @@return ::BEM3D_SUCCESS on success
 */

gint bem3d_element_boundary_nearest_point(BEM3DElement *e, GtsPoint *x,
					  gdouble *xi, gdouble *eta)

{
  gint i, rot[32] ;
  gdouble L[32], s, t ;
  gdouble Rmin, R ;
  static GtsPoint *y  = NULL ;
  BEM3DShapeFunc shfunc ;

  g_debug("%s:", __FUNCTION__) ;

  g_return_val_if_fail(e != NULL, FALSE) ;
  g_return_val_if_fail(BEM3D_IS_ELEMENT(e), FALSE) ;
  g_return_val_if_fail(x != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(GTS_IS_POINT(x), BEM3D_ARGUMENT_WRONG_TYPE) ;
  g_return_val_if_fail(xi != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(eta != NULL, BEM3D_NULL_ARGUMENT) ;

  if ( y == NULL ) {
    y = gts_point_new(gts_point_class(), 0, 0, 0) ;
  }

  shfunc = bem3d_element_shape_func(e) ;
  rotation_indices(bem3d_element_corner_number(e), rot) ;

  Rmin = G_MAXDOUBLE ;
  for ( i = 0 ; i < bem3d_element_corner_number(e) ; i ++ ) {
    bem3d_element_edge_nearest_point(e, 
				   bem3d_element_corner_index(e,rot[i]),
				   bem3d_element_corner_index(e,rot[i+1]),
				   x, &s, &t) ;
    shfunc(s, t, L, NULL, NULL, NULL) ;
    bem3d_element_position(e, L, y) ;
    if ( (R = gts_point_distance(x, y)) < Rmin ) {
      Rmin = R ; *xi = s ; *eta = t ;
    }
  }

  return BEM3D_SUCCESS ;
}

/**
 * @@}
 * 
 */
@


1.4
log
@*** empty log message ***
@
text
@d3 1
a3 1
 * Copyright (C) 2006 Michael Carley
@


1.3
log
@*** empty log message ***
@
text
@d54 2
a55 2
gint bem3d_element_nearest(BEM3DElement *e, GtsPoint *p, gint *i, 
			   gdouble *R) 
@


1.2
log
@*** empty log message ***
@
text
@a35 11
gdouble edge_nearest(gdouble t, gpointer p) ;
gdouble edge_nearest_point_parameter(GtsPoint *x1, GtsPoint *x2,
				     GtsPoint *x) ;
gdouble _element_area_coordinates_f(const gsl_vector *y,
				    gpointer q) ;
void _element_area_coordinates_df(const gsl_vector *y,
				  gpointer q, gsl_vector *df) ;
void _element_area_coordinates_fdf(const gsl_vector *y,
				   gpointer q,
				   gdouble *f, gsl_vector *df) ;

d51 1
a51 1
 * @@return 0 on success.
d61 6
a66 2
  g_return_val_if_fail(e != NULL, BEM3D_EINVAL) ;
  g_return_val_if_fail(p != NULL, BEM3D_EINVAL) ;
a96 1
  g_debug("%s: e=%p", __FUNCTION__, e) ;
d98 1
a101 7
/*   for ( i = 0 ; i < bem3d_element_corner_number(e) ; i ++ ) */
/*     fprintf(stderr, "(%lg,%lg) ", */
/* 	    bem3d_element_vertex_xi(e,bem3d_element_corner_index(e,i)), */
/* 	    bem3d_element_vertex_eta(e,bem3d_element_corner_index(e,i))) ; */
/*   fprintf(stderr, "\n") ; */

  
d119 2
a120 3

gdouble _element_area_coordinates_f(const gsl_vector *y,
				    gpointer q)
d140 2
a141 2
void _element_area_coordinates_df(const gsl_vector *y,
				  gpointer q, gsl_vector *df)
d170 3
a172 3
void _element_area_coordinates_fdf(const gsl_vector *y,
				   gpointer q,
				   gdouble *f, gsl_vector *df)
d216 1
a216 1
 * @@return 0 on success.
d233 6
a238 2
  g_return_val_if_fail(e != NULL, BEM3D_EINVAL) ;
  g_return_val_if_fail(x != NULL, BEM3D_EINVAL) ;
a246 8
/*   for ( i = 0 ; i < bem3d_element_vertex_number(e) ; i ++ ) { */
/*     fprintf(stderr, "  vertex %d (%lg, %lg, %lg)\n", */
/* 	    i,  */
/* 	    GTS_POINT(bem3d_element_vertex(e,i))->x, */
/* 	    GTS_POINT(bem3d_element_vertex(e,i))->y, */
/* 	    GTS_POINT(bem3d_element_vertex(e,i))->z) ; */
/*   } */

d278 1
a278 1
    fprintf(stderr, "Entering constraint\n") ;
d280 1
a280 1
    fprintf(stderr, "Exiting constraint\n") ;
d302 2
a303 2
gdouble edge_nearest_point_parameter(GtsPoint *x1, GtsPoint *x2,
				     GtsPoint *x)
d317 1
a317 1
gdouble edge_nearest(gdouble t, gpointer p)
d329 1
a329 1
  shfunc = bem3d_element_shapefunc(e) ;
d352 1
a352 1
 * @@return 0 on success.
d356 2
a357 2
				    GtsPoint *x,
				    gdouble *xi, gdouble *eta)
d371 6
a376 2
  g_return_val_if_fail(e != NULL, BEM3D_EINVAL) ;
  g_return_val_if_fail(x != NULL, BEM3D_EINVAL) ;
d423 1
a423 1
 * @@return 0 on success
d427 1
a427 1
					gdouble *xi, gdouble *eta)
d438 7
d449 1
a449 1
  shfunc = bem3d_element_shapefunc(e) ;
@


1.1
log
@Initial revision
@
text
@d20 4
d33 2
a34 2
#include "bem.h"
#include "bem-private.h"
d57 1
a57 1
 * @@param e ::BEMElement;
d65 2
a66 2
gint bem_element_nearest(BEMElement *e, GtsPoint *p, gint *i, 
			 gdouble *R) 
d72 2
a73 2
  g_return_val_if_fail(e != NULL, BEM_EINVAL) ;
  g_return_val_if_fail(p != NULL, BEM_EINVAL) ;
d76 1
a76 1
  for ( j = 0 ; j < bem_element_nv(e) ; j ++ ) {
d83 1
a83 1
  return BEM_SUCCESS ;
d90 1
a90 1
 * @@param e ::BEMElement
d98 1
a98 1
gboolean bem_element_point_inside(BEMElement *e, gdouble xi, gdouble eta)
d104 1
d107 7
a113 1
  rotation_indices(bem_element_ncorner(e), rot) ;
d115 10
a124 5
  for ( i = 0 ; i < bem_element_ncorner(e) ; i ++ ) {
    xi1 = bem_element_node_xi(e,bem_element_corner_index(e,rot[i])) ;
    eta1 = bem_element_node_eta(e,bem_element_corner_index(e,rot[i])) ;
    xi2 = bem_element_node_xi(e,bem_element_corner_index(e,rot[i+1])) ;
    eta2 = bem_element_node_eta(e,bem_element_corner_index(e,rot[i+1])) ;
d129 1
d139 1
a139 1
  BEMElement *e = (BEMElement *)p[0] ;
d148 1
a148 1
  bem_element_position(e, L, &x0) ;
d160 1
a160 1
  BEMElement *e = (BEMElement *)p[0] ;
d169 1
a169 1
  bem_element_position(e, L, &x0) ;
d178 1
a178 1
  bem_element_slopes(e, dLds, dLdt, drds, drdt) ;
d191 1
a191 1
  BEMElement *e = (BEMElement *)p[0] ;
d201 1
a201 1
  bem_element_position(e, L, &x0) ;
d210 1
a210 1
  bem_element_slopes(e, dLds, dLdt, drds, drdt) ;
d218 1
a218 1
 * Given a ::BEMElement, find the area coordinates of the nearest
d220 1
a220 1
 * point found need not lie on the ::BEMElement proper. For a plane
d223 1
a223 1
 * @@param e ::BEMElement;
d225 2
a226 2
 * @@param xi first area coordinate of nearest point on ::BEMElement;
 * @@param eta second area coordinate of nearest point on ::BEMElement;
d234 3
a236 3
gint bem_element_nearest_point(BEMElement *e, GtsPoint *x,
			       gdouble *xi, gdouble *eta, 
			       gboolean constrain)
d246 1
a246 2
  g_return_val_if_fail(e != NULL, BEM_EINVAL) ;
  g_return_val_if_fail(x != NULL, BEM_EINVAL) ;
d248 8
a255 5
  i = bem_element_find_vertex(e, GTS_VERTEX(x)) ;
  if ( i != BEM_FAILURE ) {
    *xi = bem_element_node_xi(e,i) ;
    *eta = bem_element_node_eta(e,i) ;
    return BEM_SUCCESS ;
d258 8
d293 1
a293 1
  if ( constrain && ! bem_element_point_inside(e, *xi, *eta) ) {
d297 3
a299 1
    bem_element_boundary_nearest_point(e, x, xi, eta) ;
d313 3
a315 1
  if ( i == iter_max ) return BEM_ITERMAX ;
d317 1
a317 1
  return BEM_SUCCESS ;
d340 1
a340 1
  BEMElement *e = BEM_ELEMENT(q[0]) ;
d346 1
a346 1
  BEMShapeFunc shfunc ;
d348 1
a348 1
  shfunc = bem_element_shapefunc(e) ;
d350 2
a351 2
  xi = (1-t)*bem_element_node_xi(e,i) + t*bem_element_node_xi(e,j) ;
  eta = (1-t)*bem_element_node_eta(e,i) + t*bem_element_node_eta(e,j) ;
d353 1
a353 1
  bem_element_position(e, L, y) ;
d362 1
a362 1
 * @@param e ::BEMElement
d374 1
a374 1
gint bem_element_edge_nearest_point(BEMElement *e, gint i, gint j,
d388 4
a391 2
  g_return_val_if_fail(e != NULL, BEM_EINVAL) ;
  g_return_val_if_fail(x != NULL, BEM_EINVAL) ;
d402 2
a403 2
  t = edge_nearest_point_parameter(bem_element_node(e,i),
				   bem_element_node(e,j),
d421 2
a422 2
  *xi = (1-t)*bem_element_node_xi(e,i) + t*bem_element_node_xi(e,j) ;
  *eta = (1-t)*bem_element_node_eta(e,i) + t*bem_element_node_eta(e,j) ;
d424 1
a424 1
  return BEM_SUCCESS ;
d431 1
a431 1
 * @@param e ::BEMElement
d441 1
a441 1
gint bem_element_boundary_nearest_point(BEMElement *e, GtsPoint *x,
d449 3
a451 1
  BEMShapeFunc shfunc ;
d457 2
a458 2
  shfunc = bem_element_shapefunc(e) ;
  rotation_indices(bem_element_ncorner(e), rot) ;
d461 4
a464 4
  for ( i = 0 ; i < bem_element_ncorner(e) ; i ++ ) {
    bem_element_edge_nearest_point(e, 
				   bem_element_corner_index(e,rot[i]),
				   bem_element_corner_index(e,rot[i+1]),
d467 1
a467 1
    bem_element_position(e, L, y) ;
d473 1
a473 1
  return BEM_SUCCESS ;
@
