head	1.5;
access;
symbols;
locks
	ensmjc:1.5; strict;
comment	@ * @;


1.5
date	2018.08.15.15.51.30;	author ensmjc;	state Exp;
branches;
next	1.4;

1.4
date	2017.07.03.10.47.18;	author ensmjc;	state Exp;
branches;
next	1.3;

1.3
date	2009.08.17.15.28.35;	author ensmjc;	state Exp;
branches;
next	1.2;

1.2
date	2009.01.20.13.21.12;	author ensmjc;	state Exp;
branches;
next	1.1;

1.1
date	2008.10.10.10.35.44;	author ensmjc;	state Exp;
branches;
next	;


desc
@@


1.5
log
@*** empty log message ***
@
text
@/* belement.c
 * 
 * Copyright (C) 2006, 2018 Michael Carley
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif /*HAVE_CONFIG_H*/

#include <stdio.h>
#include <math.h>

#include <glib.h>
#include <gts.h>

#include "bem3d.h"
#include "bem3d-private.h"

#include "trace.h"

#include <gsl/gsl_multimin.h>
#include <gsl/gsl_min.h>

static void element_destroy(GtsObject *object)

{
  BEM3DElement *e = BEM3D_ELEMENT(object) ;

  g_free(e->i) ;  g_free(e->s) ; 
  g_free(e->f) ;  
  if ( e->c != e->v ) g_free(e->c) ;
  g_free(e->v) ;
  if ( e->xc != e->xs ) g_free(e->xc) ;
  g_free(e->xs) ; 
  

  (*GTS_OBJECT_CLASS(bem3d_element_class ())->parent_class->destroy)
    (object) ;  
  return ;
}

static void bem3d_element_class_init (BEM3DElementClass * klass)
{
  /* define new methods and overload inherited methods here */
  GTS_OBJECT_CLASS (klass)->destroy = element_destroy ;
}


static void bem3d_element_init (BEM3DElement * object)
{
  /* initialize object here */
}

/**
 * @@defgroup belement BEM3D elements
 *
 * The definitions of the basic ::BEM3DElement and the functions for
 * handling it. To see how to define new types of element, consult
 * \link elements Building elements \endlink
 *
 * @@{
 * 
 */

/** 
 * The basic class for a ::BEM3DElement. 
 * 
 * @@return the ::BEM3DElementClass
 */

BEM3DElementClass * bem3d_element_class (void)
{
  static BEM3DElementClass * klass = NULL;

  if (klass == NULL) {
    GtsObjectClassInfo bem3d_element_info = {
      "BEM3DElement",
      sizeof (BEM3DElement),
      sizeof (BEM3DElementClass),
      (GtsObjectClassInitFunc) bem3d_element_class_init,
      (GtsObjectInitFunc) bem3d_element_init,
      (GtsArgSetFunc) NULL,
      (GtsArgGetFunc) NULL
    };
    klass = gts_object_class_new (GTS_OBJECT_CLASS (gts_object_class ()),
				  &bem3d_element_info);
  }

  return klass;
}

/** 
 * Allocate a new ::BEM3DElement
 * 
 * @@param klass ::BEM3DElementClass (use ::bem3d_element_class());
 * @@param nf number of GtsFace on the element;
 * @@param nv number of vertices for geometric interpolation; 
 * @@param nc number of collocation points (not necessarily the same as nv);
 * set nc to zero make the collocation points coincide with the geometric
 * vertices;
 * @@param ns number of sides/corners (e.g. three for triangular elements);
 * @@param shf pointer to shape function for geometry;
 * @@param cpf pointer to shape function for collocation.
 * 
 * @@return pointer to new element.
 */

BEM3DElement *bem3d_element_new(BEM3DElementClass * klass,
				gint nf, gint nv, gint nc, gint ns,
				BEM3DShapeFunc shf, BEM3DShapeFunc cpf)

{
  BEM3DElement *e ;
  gint i ;

  g_return_val_if_fail(klass != NULL, NULL) ;
  g_return_val_if_fail(nf > 0, NULL) ;
  g_return_val_if_fail(nv > 0, NULL) ;
  g_return_val_if_fail(nc >= 0, NULL) ;
  g_return_val_if_fail(ns > 0, NULL) ;
  g_return_val_if_fail(shf != NULL, NULL) ;
  g_return_val_if_fail(cpf != NULL, NULL) ;

  e = BEM3D_ELEMENT (gts_object_new (GTS_OBJECT_CLASS (klass)));

  e->nf = nf ;
  e->f = (gpointer *)g_malloc(nf*sizeof(gpointer)) ;
  e->nv = nv ;
  e->v = (gpointer *)g_malloc(nv*sizeof(gpointer)) ;
  e->ns = ns ;
  e->s = (gint *)g_malloc(ns*sizeof(gint)) ;
  e->xs = (gdouble *)g_malloc(2*nv*sizeof(gdouble)) ;
  bem3d_element_moment_order(e) = 0 ;
  e->Imn = NULL ;

  if ( nc > 0 ) {
    e->nc = nc ;
    e->c = (gpointer *)g_malloc(nc*sizeof(gpointer)) ;
    e->xc = (gdouble *)g_malloc(2*nc*sizeof(gdouble)) ;
  } else {
    e->nc = nv ; e->c = e->v ; e->xc = e->xs ;
  }

  e->i = (gint *)g_malloc((e->nc)*sizeof(gint)) ;
  for ( i = 0 ; i < e->nc ; i ++ ) e->i[i] = 0 ;
  e->shf = shf ; e->cpf = cpf ;

  e->reserved = NULL ;

  return e ;
}

/** 
 * Add a new face to a ::BEM3DElement. 
 * 
 * @@param e pointer to element;
 * @@param f pointer to face to add;
 * @@param i local face index for new face.
 * 
 * @@return ::BEM3D_SUCCESS on success.
 */

gint bem3d_element_add_face(BEM3DElement *e, gpointer f, gint i)

{
  g_return_val_if_fail(e != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(BEM3D_IS_ELEMENT(e), BEM3D_ARGUMENT_WRONG_TYPE) ;
  g_return_val_if_fail(f != NULL, BEM3D_NULL_ARGUMENT) ;

  if ( i >= bem3d_element_face_number(e) || i < 0 )
    g_error("%s: cannot add face number %d to %d face element",
	    __FUNCTION__, i, bem3d_element_face_number(e)) ;

  e->f[i] = f ;

  return BEM3D_SUCCESS ;
}

/** 
 * Add a GtsVertex to a ::BEM3DElement.
 * 
 * @@param e pointer to ::BEM3DElement;
 * @@param v pointer to GtsVertex to add;
 * @@param i local index of GtsVertex.
 * 
 * @@return ::BEM3D_SUCCESS on success.
 */

gint bem3d_element_add_vertex(BEM3DElement *e, gpointer v, gint i)

{
  g_return_val_if_fail(e != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(BEM3D_IS_ELEMENT(e), BEM3D_ARGUMENT_WRONG_TYPE) ;
  g_return_val_if_fail(v != NULL, BEM3D_NULL_ARGUMENT) ;

  if ( i >= bem3d_element_vertex_number(e) || i < 0 )
    g_error("%s: cannot add vertex number %d to %d node element",
	    __FUNCTION__, i, bem3d_element_vertex_number(e)) ;

  e->v[i] = v ;

  return BEM3D_SUCCESS ;
}

/** 
 * Add a collocation point to a ::BEM3DElement
 * 
 * @@param e pointer to ::BEM3DElement;
 * @@param v pointer to vertex to add;
 * @@param i local index of collocation point.
 * 
 * @@return ::BEM3D_SUCCESS on success.
 */

gint bem3d_element_add_node(BEM3DElement *e, gpointer v, gint i)

{
  g_return_val_if_fail(e != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(BEM3D_IS_ELEMENT(e), BEM3D_ARGUMENT_WRONG_TYPE) ;
  g_return_val_if_fail(v != NULL, BEM3D_NULL_ARGUMENT) ;

  if ( i >= bem3d_element_node_number(e) )
    g_error("%s: cannot add collocation point number %d to %d "
	    "collocation point element",
	  __FUNCTION__, i, bem3d_element_node_number(e)) ;

  e->c[i] = v ;

  return BEM3D_SUCCESS ;
}

/** 
 * Set the global index of a collocation point.
 * 
 * @@param e pointer to ::BEM3DElement;
 * @@param i local index;
 * @@param j global index.
 * 
 * @@return ::BEM3D_SUCCESS on success.
 */

gint bem3d_element_set_index(BEM3DElement *e, gint i, gint j)

{
  g_return_val_if_fail(e != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(BEM3D_IS_ELEMENT(e), BEM3D_ARGUMENT_WRONG_TYPE) ;

  if ( i >= bem3d_element_node_number(e) || i < 0 )
    g_error("%s: cannot set global index of %dth point of %d "
	    "collocation point element",
	    __FUNCTION__, i, bem3d_element_node_number(e)) ;
  
  e->i[i] = j ;

  return BEM3D_SUCCESS ;
}

/** 
 * Set a corner of a ::BEM3DElement.
 * 
 * @@param e BEM3DElement to set;
 * @@param i local index of corner vertex;
 * @@param j index of corner to set.
 * 
 * @@return ::BEM3D_SUCCESS on success.
 */

gint bem3d_element_set_corner(BEM3DElement *e, gint i, gint j) 

{
  g_return_val_if_fail(e != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(BEM3D_IS_ELEMENT(e), BEM3D_ARGUMENT_WRONG_TYPE) ;

  if ( i >= bem3d_element_corner_number(e) || i < 0 )
    g_error("%s: cannot set %dth corner of %d corner element",
	    __FUNCTION__, i, bem3d_element_corner_number(e)) ;

  e->s[i] = j ;

  return BEM3D_SUCCESS ;
}

/** 
 * Write a ::BEM3DElement to file. Usually called from bem3d_mesh_write. 
 *
 * Format: nf nv nc ns shf cpf [faces] [vertices] [collocation points]
 *         [vertex area coordinate] [collocation point area coordinates]
 *         [collocation point global indices] [corner indices]
 * 
 * @@param e element to write;
 * @@param v hash table of vertices;
 * @@param t hash table of faces;
 * @@param f file pointer.
 * 
 * @@return ::BEM3D_SUCCESS on success.
 */

gint bem3d_element_write(BEM3DElement *e, 
			 GHashTable *v, GHashTable *t,
			 FILE *f)

{
  gint i ;

  g_return_val_if_fail(e != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(BEM3D_IS_ELEMENT(e), BEM3D_ARGUMENT_WRONG_TYPE) ;
  g_return_val_if_fail(v != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(t != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(f != NULL, BEM3D_NULL_ARGUMENT) ;

  fprintf(f, "%u %u", e->nf, e->nv) ;

  if ( e->v == e->c ) fprintf(f, " 0") ;
  else fprintf(f, " %u", e->nc) ;

  fprintf(f, " %u", e->ns) ;

  fprintf(f, " %s %s", 
	  bem3d_shapefunc_lookup_name(e->shf),
	  bem3d_shapefunc_lookup_name(e->cpf)) ;

  for ( i = 0 ; i < e->nf ; i ++ ) {
    fprintf(f, " %u",
	    GPOINTER_TO_UINT (g_hash_table_lookup (t, e->f[i]))) ;
  }

  for ( i = 0 ; i < e->nv ; i ++ ) {
    fprintf(f, " %u",
	    GPOINTER_TO_UINT (g_hash_table_lookup (v, e->v[i]))) ;
  }

  if ( e->v != e->c ) 
    for ( i = 0 ; i < e->nc ; i ++ ) {
      fprintf(f, " %u",
	      GPOINTER_TO_UINT (g_hash_table_lookup (v, e->c[i]))) ;
    }

  if ( e->v != e->c ) {
    for ( i = 0 ; i < 2*(e->nc) ; i ++ ) {
      fprintf(f, " %e", e->xc[i]) ;	    
    }
  }
  for ( i = 0 ; i < 2*(e->nv) ; i ++ ) {
    fprintf(f, " %e", e->xs[i]) ;	    
  }

  for ( i = 0 ; i < e->nc ; i ++ )  fprintf(f, " %u", e->i[i]) ;
  for ( i = 0 ; i < e->ns ; i ++ )  fprintf(f, " %u", e->s[i]) ;

  fprintf(f, "\n") ;

  return BEM3D_SUCCESS ;
}

/** 
 * Find the local index of a GtsVertex on a ::BEM3DElement. 
 * 
 * @@param e ::BEM3DElement to search;
 * @@param v GtsVertex to find.
 * 
 * @@return local index of vertex if on element, -1 otherwise. 
 */

gint bem3d_element_find_vertex(BEM3DElement *e, GtsVertex *v)

{
  gint i ;

  g_return_val_if_fail(e != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(BEM3D_IS_ELEMENT(e), BEM3D_ARGUMENT_WRONG_TYPE) ;
  g_return_val_if_fail(v != NULL, BEM3D_NULL_ARGUMENT) ;

  for ( i = 0 ; i < e->nv ; i ++ ) if ( e->v[i] == v ) return i ;

  return BEM3D_FAILURE ;
}

/** 
 * Find the local index of a collocation point on a ::BEM3DElement.
 * 
 * @@param e ::BEM3DElement to search;
 * @@param v collocation point (GtsVertex) to find.
 * 
 * @@return local index of collocation point if on element, -1 otherwise. 
 */

gint bem3d_element_find_node(BEM3DElement *e, GtsVertex *v)

{
  gint i ;

  g_return_val_if_fail(e != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(BEM3D_IS_ELEMENT(e), BEM3D_ARGUMENT_WRONG_TYPE) ;
  g_return_val_if_fail(v != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(GTS_IS_VERTEX(v), BEM3D_NULL_ARGUMENT) ;

  for ( i = 0 ; i < e->nc ; i ++ ) if ( e->c[i] == v ) return i ;

  return BEM3D_FAILURE ;
}

/** 
 * Surface area of a ::BEM3DElement, computed using a Gaussian
 * quadrature rule.
 * 
 * @@param e ::BEM3DElement;
 * @@param ngp number of quadrature points to use.
 * 
 * @@return computed area of \a e.
 */

gdouble bem3d_element_area(BEM3DElement *e, gint ngp)

{
  gdouble J, dA ;
  static gdouble *L = NULL, *dLds = NULL, *dLdt = NULL ;
  BEM3DShapeFunc sf = bem3d_element_shape_func(e) ;
  BEM3DQuadratureRule *q ;
  gint i ;

  g_return_val_if_fail(e != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(BEM3D_IS_ELEMENT(e), BEM3D_ARGUMENT_WRONG_TYPE) ;
  g_return_val_if_fail(ngp > 0, BEM3D_NULL_ARGUMENT) ;

  if ( L == NULL ) {
    L = (gdouble *)g_malloc(bem3d_element_node_number(e)*4*sizeof(gdouble)) ;
    dLds = (gdouble *)g_malloc(bem3d_element_node_number(e)*4*sizeof(gdouble)) ;
    dLdt = (gdouble *)g_malloc(bem3d_element_node_number(e)*4*sizeof(gdouble)) ;
  }

  q = bem3d_quadrature_rule_new(ngp, 1) ;
  bem3d_quadrature_rule_wx(NULL, e, q, NULL, NULL, &ngp) ;

  dA = 0.0 ;
  for ( i = 0 ; i < bem3d_quadrature_vertex_number(q) ; i ++ ) {
    sf(bem3d_quadrature_xi(q,i),
       bem3d_quadrature_eta(q,i), L, dLds, dLdt, NULL) ;
    J = bem3d_element_jacobian(e, dLds, dLdt) ;
    dA += bem3d_quadrature_weight(q,i)*J ;
  }

  return dA ;
}

/** 
 * Interpolate position on a ::BEM3DElement given a set of shape
 * functions.
 * 
 * @@param e ::BEM3DElement;
 * @@param L array of shape functions for element;
 * @@param q preallocated GtsPoint for interpolated position.
 * 
 * @@return ::BEM3D_SUCCESS on success.
 */

gint bem3d_element_position(BEM3DElement *e, gdouble *L,
			    GtsPoint *q)

{
  gint i ;

  g_return_val_if_fail(e != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(BEM3D_IS_ELEMENT(e), BEM3D_ARGUMENT_WRONG_TYPE) ;
  g_return_val_if_fail(L != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(q != NULL, BEM3D_NULL_ARGUMENT) ;
/*   g_return_val_if_fail(GTS_IS_POINT(q), BEM3D_ARGUMENT_WRONG_TYPE) ; */

  gts_point_set(GTS_POINT(q), 0.0, 0.0, 0.0) ;

  for ( i = 0 ; i < bem3d_element_vertex_number(e) ; i ++ ) {
    GTS_POINT(q)->x += GTS_POINT(e->v[i])->x*L[i] ;
    GTS_POINT(q)->y += GTS_POINT(e->v[i])->y*L[i] ;
    GTS_POINT(q)->z += GTS_POINT(e->v[i])->z*L[i] ;
  }

  return BEM3D_SUCCESS ;
}

/** 
 * Compute Jacobian on a ::BEM3DElement given derivatives of shape
 * functions.
 * 
 * @@param e ::BEM3DElement;
 * @@param dLds shape function derivatives \f$\partial L_{i}/\partial \xi\f$; 
 * @@param dLdt shape function derivatives \f$\partial L_{i}/\partial \eta\f$.
 * 
 * @@return Jacobian.
 */

gdouble bem3d_element_jacobian(BEM3DElement *e, gdouble *dLds, gdouble *dLdt)
  
{
  gint i ;
  GtsVector dxds, dxdt, normal ;
  gdouble J ;

  g_debug("%s: ", __FUNCTION__) ;
  g_return_val_if_fail(e != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(BEM3D_IS_ELEMENT(e), BEM3D_ARGUMENT_WRONG_TYPE) ;
  g_return_val_if_fail(dLds != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(dLdt != NULL, BEM3D_NULL_ARGUMENT) ;

  dxdt[0] = dxdt[1] = dxdt[2] = 0.0 ;
  dxds[0] = dxds[1] = dxds[2] = 0.0 ;

  for ( i = 0 ; i < bem3d_element_vertex_number(e) ; i ++ ) {
    dxds[0] += GTS_POINT(e->v[i])->x*dLds[i] ;
    dxds[1] += GTS_POINT(e->v[i])->y*dLds[i] ;
    dxds[2] += GTS_POINT(e->v[i])->z*dLds[i] ;
    dxdt[0] += GTS_POINT(e->v[i])->x*dLdt[i] ;
    dxdt[1] += GTS_POINT(e->v[i])->y*dLdt[i] ;
    dxdt[2] += GTS_POINT(e->v[i])->z*dLdt[i] ;
  }

  gts_vector_cross(normal,dxds,dxdt) ;

/*   g_assert(!isnan(normal[0])) ; g_assert(!isnan(normal[1])) ; */
/*   g_assert(!isnan(normal[2])) ; */

  J = sqrt(normal[0]*normal[0] + normal[1]*normal[1] + 
	   normal[2]*normal[2]) ;

  return J ;
}

/** 
 * Compute normal to, and Jacobian on, a BEM3DElement given shape
 * function derivatives.
 * 
 * @@param e ::BEM3DElement;
 * @@param dLds shape function derivatives \f$\partial L_{i}/\partial \xi\f$; 
 * @@param dLdt shape function derivatives \f$\partial L_{i}/\partial \eta\f$; 
 * @@param normal GtsVector for normal;
 * @@param J Jacobian.
 * 
 * @@return ::BEM3D_SUCCESS on success;
 */

gint bem3d_element_normal(BEM3DElement *e, gdouble *dLds, gdouble *dLdt,
			  GtsVector normal, gdouble *J)

{
  gint i ;
  GtsVector dxds, dxdt ;

  g_return_val_if_fail(e != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(BEM3D_IS_ELEMENT(e), BEM3D_ARGUMENT_WRONG_TYPE) ;
  g_return_val_if_fail(dLds != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(dLdt != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(normal != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(J != NULL, BEM3D_NULL_ARGUMENT) ;

  dxdt[0] = dxdt[1] = dxdt[2] = 0.0 ;
  dxds[0] = dxds[1] = dxds[2] = 0.0 ;

  for ( i = 0 ; i < bem3d_element_vertex_number(e) ; i ++ ) {
    dxds[0] += GTS_POINT(e->v[i])->x*dLds[i] ;
    dxds[1] += GTS_POINT(e->v[i])->y*dLds[i] ;
    dxds[2] += GTS_POINT(e->v[i])->z*dLds[i] ;
    dxdt[0] += GTS_POINT(e->v[i])->x*dLdt[i] ;
    dxdt[1] += GTS_POINT(e->v[i])->y*dLdt[i] ;
    dxdt[2] += GTS_POINT(e->v[i])->z*dLdt[i] ;
  }

  gts_vector_cross(normal,dxds,dxdt) ;

  if ( isnan(normal[0]) || isnan(normal[1]) || isnan(normal[2]) )
    g_error("%s: NaN in normal", __FUNCTION__) ;

  *J = sqrt(normal[0]*normal[0] + normal[1]*normal[1] + 
	    normal[2]*normal[2]) ;

  g_assert(*J != 0.0) ;

  normal[0] /= (*J) ; normal[1] /= (*J) ; normal[2] /= (*J) ;

  return BEM3D_SUCCESS ;
}

/** 
 * Compute Jacobian matrix, inverse and normal to an element. 
 * 
 * @@param e a ::BEM3DElement;
 * @@param dLds shape function derivatives \f$\partial L_{i}/\partial \xi\f$; 
 * @@param dLdt shape function derivatives \f$\partial L_{i}/\partial \eta\f$; 
 * @@param normal GtsVector for normal;
 * @@param J nine-element matrix for Jacobian;
 * @@param Ji nine-element matrix for inverse of Jacobian or NULL.
 * 
 * @@return 0 on success. If \a normal, \a J, and/or \a Ji are NULL,
 * they are not computed, though if \a Ji is not NULL, \a J must also
 * be defined.
 */

gint bem3d_element_jacobian_matrix_normal(BEM3DElement *e,
					  gdouble *dLds, gdouble *dLdt,
					  GtsVector normal, gdouble *J,
					  gdouble *Ji)

{
  gint i ;
  GtsVector dxds, dxdt, dxdn ;
  
  g_return_val_if_fail(e != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(BEM3D_IS_ELEMENT(e), BEM3D_ARGUMENT_WRONG_TYPE) ;
  g_return_val_if_fail(dLds != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(dLdt != NULL, BEM3D_NULL_ARGUMENT) ;

  dxdt[0] = dxdt[1] = dxdt[2] = 0.0 ;
  dxds[0] = dxds[1] = dxds[2] = 0.0 ;

  for ( i = 0 ; i < bem3d_element_vertex_number(e) ; i ++ ) {
    dxds[0] += GTS_POINT(e->v[i])->x*dLds[i] ;
    dxds[1] += GTS_POINT(e->v[i])->y*dLds[i] ;
    dxds[2] += GTS_POINT(e->v[i])->z*dLds[i] ;
    dxdt[0] += GTS_POINT(e->v[i])->x*dLdt[i] ;
    dxdt[1] += GTS_POINT(e->v[i])->y*dLdt[i] ;
    dxdt[2] += GTS_POINT(e->v[i])->z*dLdt[i] ;
  }

  gts_vector_cross(dxdn,dxds,dxdt) ;

  if ( J != NULL ) {
    J[0] = dxds[0] ; J[1] = dxds[1] ; J[2] = dxds[2] ; 
    J[3] = dxdt[0] ; J[4] = dxdt[1] ; J[5] = dxdt[2] ; 
    J[6] = dxdn[0] ; J[7] = dxdn[1] ; J[8] = dxdn[2] ;
    if ( Ji != NULL ) _invert3x3(Ji,J) ;
  }

  if ( normal == NULL ) return BEM3D_SUCCESS ;

  dxdt[0] = gts_vector_norm(dxdn) ;

  normal[0] = dxdn[0]/dxdt[0] ;
  normal[1] = dxdn[1]/dxdt[0] ;
  normal[2] = dxdn[2]/dxdt[0] ;

  return BEM3D_SUCCESS ;
}

/** 
 * Assemble equations for ::BEM3DElement and GtsPoint.
 * 
 * The integration of the Green's function and its normal derivative
 * weighted by the element shape functions is performed for a
 * specified field point.
 *
 * @@param e ::BEM3DElement;
 * @@param x GtsPoint;
 * @@param config ::BEM3DConfiguration configuration for this problem;
 * @@param gdata ::BEM3DParameters to pass to Green's function;
 * @@param G GArray of integral of \f$G L_{i}\f$ over element;
 * @@param dGdn GArray of integral of \f$d G/d n L_{i}\f$ over element. 
 * 
 * @@return ::BEM3D_SUCCESS on success.
 */

gint bem3d_element_assemble_equations(BEM3DElement *e, GtsPoint *x,
				      BEM3DConfiguration *config,
				      BEM3DParameters *gdata,
				      GArray *G, GArray *dGdn)
				    
{
  BEM3DShapeFunc shfunc = bem3d_element_shape_func(e) ;
  BEM3DShapeFunc cpfunc = bem3d_element_node_func(e) ;
  static BEM3DQuadratureRule *q = NULL ;
  static GArray *g = NULL ;
  static GArray *dgdn = NULL ;
  static gdouble *L = NULL, *dLds = NULL, *dLdt = NULL ;
  BEM3DQuadratureRuleFunc qf ;
  gpointer qd ;
  BEM3DGreensFunction gfunc ;
  gint i, j, k, stride ;
  gdouble s, t, J, w, wt ;
  GtsPoint y ;
  GtsVector n ;

  g_return_val_if_fail(e != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(BEM3D_IS_ELEMENT(e), BEM3D_ARGUMENT_WRONG_TYPE) ;
  g_return_val_if_fail(x != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(G != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(dGdn != NULL, BEM3D_NULL_ARGUMENT) ;

  if ( g == NULL ) {
    g = g_array_new(FALSE, TRUE, sizeof(gdouble)) ;
    dgdn = g_array_new(FALSE, TRUE, sizeof(gdouble)) ;
    L = (gdouble *)g_malloc(4*bem3d_element_node_number(e)*sizeof(gdouble)) ;
    dLds = (gdouble *)g_malloc(4*bem3d_element_node_number(e)*sizeof(gdouble)) ;
    dLdt = (gdouble *)g_malloc(4*bem3d_element_node_number(e)*sizeof(gdouble)) ;
  }
  
  if ( q == NULL ) q = bem3d_quadrature_rule_new(0, 1) ;

  gfunc = config->gfunc ;

  qf = config->qrule ; qd = config->qdata ;

  qf(x, e, q, &gfunc, gdata, qd) ;

  /* g_debug("%s: quadrature rule weights total: %g", */
  /* 	__FUNCTION__, bem3d_quadrature_rule_sum_weights(q)) ; */

  /*get the size of the Green's function*/
  if ( bem3d_greens_function_is_real(&gfunc) ) stride = 1 ;
  else stride = 2 ;
  g_array_set_size(G,bem3d_element_node_number(e)*stride) ; 
  g_array_set_size(dGdn,bem3d_element_node_number(e)*stride) ;  

  for ( i = 0 ; i < G->len ; i ++ )
    g_array_index(G,gdouble,i) = g_array_index(dGdn,gdouble,i) = 0.0 ;

  for ( i = 0 ; i < bem3d_quadrature_vertex_number(q) ; i ++ ) {
    s = bem3d_quadrature_xi(q,i) ;
    t = bem3d_quadrature_eta(q,i) ;
    wt = bem3d_quadrature_weight(q,i) ;
    shfunc(s, t, L, dLds, dLdt, NULL) ;
    bem3d_element_position(e, L, &y) ;
    bem3d_element_normal(e, dLds, dLdt, n, &J) ;
    bem3d_greens_function_func(&gfunc)(x, &y, n, gdata, g, dgdn) ;
    cpfunc(s, t, L, NULL, NULL, NULL) ;
    J *= wt ;
    for ( j = 0 ; j < bem3d_element_node_number(e) ; j ++ ) {
      w = J*L[j] ;
      for ( k = 0 ; k < stride ; k ++ ) {
	g_array_index(G,gdouble,j*stride+k) +=
	  g_array_index(g,gdouble,k)*w ;
	g_array_index(dGdn,gdouble,j*stride+k) +=
	  g_array_index(dgdn,gdouble,k)*w ;
      }
    }
  }

  if ( bem3d_quadrature_free_number(q) != 0 ) {
    if ( bem3d_quadrature_free_number(q) != bem3d_element_node_number(e) )
      g_error("%s: number of free terms (%d) in quadrature rule "
	      "does not match number of nodes on element (%d)",
	      __FUNCTION__, bem3d_quadrature_free_number(q), 
	      bem3d_element_node_number(e)) ;
    /*we should not arrive here in vector problems*/
    g_assert(q->wfree == 1) ;
    for ( j = 0 ; j < bem3d_element_node_number(e)*stride ; j ++ ) {
      g_array_index(G,gdouble,j) += bem3d_quadrature_free_term_g(q,j) ;
      g_array_index(dGdn,gdouble,j) += bem3d_quadrature_free_term_dg(q,j) ;
    }
  }

  return BEM3D_SUCCESS ;
}

/** 
 * Check if a GtsVertex is on a ::BEM3DElement.
 * 
 * @@param e ::BEM3DElement;
 * @@param v GtsVertex.
 * 
 * @@return TRUE if vertex is on element, FALSE otherwise. 
 */

gboolean bem3d_element_has_vertex(BEM3DElement *e, GtsVertex *v)

{
  gint i ;

  g_return_val_if_fail(e != NULL, FALSE) ;
  g_return_val_if_fail(BEM3D_IS_ELEMENT(e), BEM3D_ARGUMENT_WRONG_TYPE) ;
  g_return_val_if_fail(v != NULL, FALSE) ;
  g_return_val_if_fail(GTS_IS_VERTEX(v), BEM3D_ARGUMENT_WRONG_TYPE) ;

  for ( i = 0 ; i < bem3d_element_vertex_number(e) ; i ++ ) {
    if ( e->v[i] == v ) return TRUE ;
  }

  return FALSE ;
}

gint bem3d_element_replace_vertex(BEM3DElement *e, GtsVertex *v, GtsVertex *w)

{
  gint i ;
  
  g_return_val_if_fail(e != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(BEM3D_IS_ELEMENT(e), BEM3D_ARGUMENT_WRONG_TYPE) ;
  g_return_val_if_fail(v != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(GTS_IS_VERTEX(v), BEM3D_ARGUMENT_WRONG_TYPE) ;
  g_return_val_if_fail(w != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(GTS_IS_VERTEX(v), BEM3D_ARGUMENT_WRONG_TYPE) ;

  i = bem3d_element_find_vertex(e, v) ;

  if ( i == BEM3D_FAILURE ) return BEM3D_SUCCESS ;

  e->c[i] = w ;

  return BEM3D_SUCCESS ;
}

gint bem3d_element_find_face(BEM3DElement *e, GtsFace *f)

{
  gint i ;

  g_return_val_if_fail(e != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(BEM3D_IS_ELEMENT(e), BEM3D_ARGUMENT_WRONG_TYPE) ;
  g_return_val_if_fail(f != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(GTS_IS_FACE(f), BEM3D_ARGUMENT_WRONG_TYPE) ;

  for ( i = 0 ; i < e->nf ; i ++ ) if ( e->f[i] == f ) return i ;

  return BEM3D_FAILURE ;
}

gint bem3d_element_reset_index(BEM3DMesh *m, BEM3DElement *e, gint i, gint j)

{
#ifdef _FOREACH_USE_HASH_TABLE_
  gpointer k ;
#endif /*_FOREACH_USE_HASH_TABLE_*/

  g_return_val_if_fail(m != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(BEM3D_IS_MESH(e), BEM3D_ARGUMENT_WRONG_TYPE) ;
  g_return_val_if_fail(e != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(BEM3D_IS_ELEMENT(e), BEM3D_ARGUMENT_WRONG_TYPE) ;

  if ( i >= bem3d_element_node_number(e) || i < 0 )
    g_error("%s: cannot set global index of %dth point of %d "
	    "collocation point element",
	    __FUNCTION__, i, bem3d_element_node_number(e)) ;
  
  e->i[i] = j ;

#ifdef _FOREACH_USE_HASH_TABLE_
  k = g_hash_table_lookup(m->c,
			  GINT_TO_POINTER(bem3d_element_global_index(e,i)+1)
			  ) ;
  if ( k == NULL ) {
    g_hash_table_insert(m->c,
			GINT_TO_POINTER(bem3d_element_global_index(e,i)+1),
			e->c[i]) ;
    g_log(G_LOG_DOMAIN, G_LOG_LEVEL_DEBUG,
	  "%s: inserting: %d; hash table size: %d", 
	  __FUNCTION__, bem3d_element_global_index(e,i),
	  g_hash_table_size(m->c)) ;
  } else {
    g_log(G_LOG_DOMAIN, G_LOG_LEVEL_DEBUG,
	  "%s: not inserting: %d; vertex %p",
	  __FUNCTION__, bem3d_element_global_index(e,i),
	  e->c[i]) ;
  }
#else
  g_assert_not_reached() ;
#endif /*_FOREACH_USE_HASH_TABLE_*/


  return BEM3D_SUCCESS ;
}

gint bem3d_element_slopes(BEM3DElement *e, gdouble *dLds, gdouble *dLdt,
			  GtsVector dxds, GtsVector dxdt)

{
  gint i ;

  g_return_val_if_fail(e != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(BEM3D_IS_ELEMENT(e), BEM3D_ARGUMENT_WRONG_TYPE) ;
  g_return_val_if_fail(dLds != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(dLdt != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(dxds != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(dxdt != NULL, BEM3D_NULL_ARGUMENT) ;

  dxdt[0] = dxdt[1] = dxdt[2] = 0.0 ;
  dxds[0] = dxds[1] = dxds[2] = 0.0 ;

  for ( i = 0 ; i < bem3d_element_vertex_number(e) ; i ++ ) {
    dxds[0] += GTS_POINT(e->v[i])->x*dLds[i] ;
    dxds[1] += GTS_POINT(e->v[i])->y*dLds[i] ;
    dxds[2] += GTS_POINT(e->v[i])->z*dLds[i] ;
    dxdt[0] += GTS_POINT(e->v[i])->x*dLdt[i] ;
    dxdt[1] += GTS_POINT(e->v[i])->y*dLdt[i] ;
    dxdt[2] += GTS_POINT(e->v[i])->z*dLdt[i] ;
  }

  return BEM3D_SUCCESS ;
}

/** 
 * Find collocation points shared between two ::BEM3DElement's. 
 * 
 * @@param e1 ::BEM3DElement;
 * @@param e2 ::BEM3DElement.
 * 
 * @@return GSList of common collocation points.
 */

GSList *bem3d_element_common_nodes(BEM3DElement *e1, BEM3DElement *e2)

{
  GSList *c = NULL ;
  gint i ;

  g_return_val_if_fail(e1 != NULL, NULL) ;
  g_return_val_if_fail(BEM3D_IS_ELEMENT(e1), NULL) ;
  g_return_val_if_fail(e2 != NULL, NULL) ;
  g_return_val_if_fail(BEM3D_IS_ELEMENT(e2), NULL) ;

  for ( i = 0 ; i < bem3d_element_node_number(e1) ; i ++ ) {
    if ( bem3d_element_find_node(e2, bem3d_element_node(e1,i)) != -1 ) {
      c = g_slist_prepend(c, bem3d_element_node(e1,i)) ;
    }
  }

  return c ;
}

/** 
 * Find the elements of a ::BEM3DMesh which share an edge with a
 * specified element.
 * 
 * @@param el ::BEM3DElement whose neighbours are sought;
 * @@param m ::BEM3DMesh.
 * 
 * @@return a GSList of unique elements which border the specified element. 
 */

GSList *bem3d_element_neighbours(BEM3DElement *el, BEM3DMesh *m)

{
  GSList *e = NULL, *f, *edges = NULL, *j ;
  BEM3DElement *g ;
  gint i ;

  g_return_val_if_fail(el != NULL, NULL) ;
  g_return_val_if_fail(BEM3D_IS_ELEMENT(el), NULL) ;
  g_return_val_if_fail(m != NULL, NULL) ;
  g_return_val_if_fail(BEM3D_IS_MESH(m), NULL) ;

  for ( i = 0 ; i < bem3d_element_face_number(el) ; i ++ ) {
    if ( !g_slist_find(edges, GTS_TRIANGLE(bem3d_element_face(el,i))->e1) )
      edges = g_slist_prepend(edges, 
			      GTS_TRIANGLE(bem3d_element_face(el,i))->e1) ;
    if ( !g_slist_find(edges, GTS_TRIANGLE(bem3d_element_face(el,i))->e2) )
      edges = g_slist_prepend(edges, 
			      GTS_TRIANGLE(bem3d_element_face(el,i))->e2) ;
    if ( !g_slist_find(edges, GTS_TRIANGLE(bem3d_element_face(el,i))->e3) )
      edges = g_slist_prepend(edges, 
			      GTS_TRIANGLE(bem3d_element_face(el,i))->e3) ;
  }

  for ( j = edges ; j != NULL ; j = j->next ) {
    for ( f = GTS_EDGE(j->data)->triangles ; f != NULL ; f = f->next ) {
      g = bem3d_mesh_face_element(m, GTS_FACE(f->data)) ;
      if ( !g_slist_find(e, g) && (g != el) ) {
	e = g_slist_prepend(e, g) ;
      }
    }
  }

  g_slist_free(edges) ;

  return e ;
}

/** 
 * Find an element containing a given collocation point, identified by
 * its GtsVertex and its global index.
 * 
 * @@param m ::BEM3DMesh
 * @@param v GtsVertex of collocation point
 * @@param i global index of collocation point
 * 
 * @@return ::BEM3DElement containing \a v with index \a i.
 */

BEM3DElement *bem3d_element_from_node(BEM3DMesh *m, GtsVertex *v, gint i)

{
  GSList *el ;
  BEM3DElement *e ;
  gint k ;
  
  g_return_val_if_fail(m != NULL, NULL) ;
  g_return_val_if_fail(BEM3D_IS_MESH(m), NULL) ;
  g_return_val_if_fail(v != NULL, NULL) ;
  g_return_val_if_fail(GTS_IS_VERTEX(v), NULL) ;

  el = bem3d_mesh_vertex_elements(m, v) ;
  e = NULL ;

  for ( ; el != NULL ; el = el->next ) {
    k = bem3d_element_find_node(BEM3D_ELEMENT(el->data), v) ;
    if ( bem3d_element_global_index(BEM3D_ELEMENT(el->data),k) == i )
      return (el->data) ;
  }

  return e ;
}

/** 
 * Index the collocation points of a ::BEM3DElement. If a point is
 * present in the ::BEM3DMesh \a m, the collocation point there is
 * used. If not, new indices are generated, starting from \a n, which
 * is incremented as required.
 * 
 * @@param e ::BEM3DElement to index
 * @@param m ::BEM3DMesh for index checking
 * @@param n first new index to assign, incremented as new indices are
 * generated.
 * 
 * @@return ::BEM3D_SUCCESS on success.
 */

gint bem3d_element_index_nodes(BEM3DElement *e, BEM3DMesh *m, gint *n)

{
  gint i, j ;

  g_return_val_if_fail(e != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(BEM3D_IS_ELEMENT(e), BEM3D_ARGUMENT_WRONG_TYPE) ;
  g_return_val_if_fail(m != NULL, BEM3D_NULL_ARGUMENT) ;  
  g_return_val_if_fail(BEM3D_IS_MESH(m), BEM3D_ARGUMENT_WRONG_TYPE) ;
  g_return_val_if_fail(n != NULL, BEM3D_NULL_ARGUMENT) ;  

  for ( i = 0 ; i < bem3d_element_node_number(e) ; i ++ ) {
    j = bem3d_mesh_index_from_node(m, bem3d_element_node(e,i)) ;
    if ( j == -1 ) {
      bem3d_element_set_index(e, i, (*n)) ; (*n) ++ ;
    } else {
      bem3d_element_set_index(e, i, j) ;
    }
  }

  return BEM3D_SUCCESS ;
}

/** 
 * Generate two unit vectors, not necessarily orthogonal, which lie in
 * the surface at a point of a ::BEM3DElement.
 * 
 * @@param e ::BEM3DElement
 * @@param dLds derivative of geometric shape function at required
 * point of \a e
 * @@param dLdt derivative of geometric shape function at required
 * point of \a e
 * @@param u1 first local vector \f$d x/d\xi/h_{1}\f$
 * @@param h1 scale factor \f$h_{1}=|d x/d\xi|\f$
 * @@param u2 first local vector \f$d x/d\xi/h_{2}\f$
 * @@param h2 scale factor \f$h_{2}=|d x/d\xi|\f$
 * 
 * @@return ::BEM3D_SUCCESS on success
 */

gint bem3d_element_local_vectors(BEM3DElement *e,
				 gdouble dLds[], gdouble dLdt[],
				 GtsVector u1, gdouble *h1,
				 GtsVector u2, gdouble *h2)
{
  gint i ;
  
  g_return_val_if_fail(e != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(BEM3D_IS_ELEMENT(e), BEM3D_ARGUMENT_WRONG_TYPE) ;
  g_return_val_if_fail(dLds != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(dLdt != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(u1 != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(h1 != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(u2 != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(h2 != NULL, BEM3D_NULL_ARGUMENT) ;

  u1[0] = u1[1] = u1[2] = u2[0] = u2[1] = u2[2] = 0.0 ;

  for ( i = 0 ; i < bem3d_element_vertex_number(e) ; i ++ ) {
    u1[0] += dLds[i]*GTS_POINT(bem3d_element_vertex(e,i))->x ;
    u1[1] += dLds[i]*GTS_POINT(bem3d_element_vertex(e,i))->y ;
    u1[2] += dLds[i]*GTS_POINT(bem3d_element_vertex(e,i))->z ;
    u2[0] += dLdt[i]*GTS_POINT(bem3d_element_vertex(e,i))->x ;
    u2[1] += dLdt[i]*GTS_POINT(bem3d_element_vertex(e,i))->y ;
    u2[2] += dLdt[i]*GTS_POINT(bem3d_element_vertex(e,i))->z ;
  }

  *h1 = gts_vector_norm(u1) ; *h2 = gts_vector_norm(u2) ;

  u1[0] /= (*h1) ; u1[1] /= (*h1) ; u1[2] /= (*h1) ;
  u2[0] /= (*h2) ; u2[1] /= (*h2) ; u2[2] /= (*h2) ;

  return BEM3D_SUCCESS ;
}

/** 
 * Find the GtsEdge's common to two ::BEM3DElement's. 
 * 
 * @@param e1 ::BEM3DElement
 * @@param e2 ::BEM3DElement
 * 
 * @@return a GSList of GtsEdges common to \a e1 and \a e2, or NULL if
 * the elements do not touch.
 */

GSList *bem3d_elements_common_edges(BEM3DElement *e1, BEM3DElement *e2)

{
  GSList *e = NULL ;
  GtsEdge *edge ;
  gint i, j ;

  g_return_val_if_fail(e1 != NULL, NULL) ;
  g_return_val_if_fail(BEM3D_IS_ELEMENT(e1), NULL) ;
  g_return_val_if_fail(e2 != NULL, NULL) ;
  g_return_val_if_fail(BEM3D_IS_ELEMENT(e2), NULL) ;

  for ( i = 0 ; i < bem3d_element_face_number(e1) ; i ++ ) {
    for ( j = 0 ; j < bem3d_element_face_number(e2) ; j ++ ) {
      if ( (edge = 
	    gts_triangles_common_edge(GTS_TRIANGLE(bem3d_element_face(e1,i)),
				      GTS_TRIANGLE(bem3d_element_face(e2,j)))
	    ) != NULL ) {
	e = g_slist_prepend(e, edge) ;
      }
    }
  }

  return e ;
}

/** 
 * Calculate the weights for computing the gradient of a function on a
 * ::BEM3DElement. The gradient \f$\partial\phi/\partial
 * x=\sum_{i=0}^{N}\phi_{i}w_{3i}\f$, \f$\partial\phi/\partial
 * y=\sum_{i=0}^{N}\phi_{i}w_{3i+1}\f$, \f$\partial\phi/\partial
 * z=\sum_{i=0}^{N}\phi_{i}w_{3i+2}\f$, where there are \f$N\f$
 * collocation points on the element \a e. The weights are computed by
 * differentiation of the element shape functions.
 * 
 * @@param e ::BEM3DElement
 * @@param xi local coordinate
 * @@param eta local coordinate
 * @@param w array of weights, which should be presized to at least
 * \f$3N\f$ entries.
 * 
 * @@return ::BEM3D_SUCCESS on success. 
 */

gint bem3d_element_gradient_weights(BEM3DElement *e, gdouble xi, gdouble eta,
				    gdouble *w)

{
  gint i ;
  BEM3DShapeFunc shfunc ;
  BEM3DMatrix J, iJ ;
  gdouble L[32], dLds[32], dLdt[32] ;
  GtsVector u1, u2, u3 ;
  gdouble h1, h2 ;

  g_return_val_if_fail(e != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(BEM3D_IS_ELEMENT(e), BEM3D_ARGUMENT_WRONG_TYPE) ;
  g_return_val_if_fail(w != NULL, BEM3D_NULL_ARGUMENT) ;

  shfunc = bem3d_element_shape_func(e) ;

  shfunc(xi, eta, L, dLds, dLdt, NULL) ;
  bem3d_element_local_vectors(e, dLds, dLdt, u1, &h1, u2, &h2) ;
  gts_vector_cross(u3,u1,u2) ; 
  u1[0] *= h1 ; u1[1] *= h1 ; u1[2] *= h1 ;
  u2[0] *= h2 ; u2[1] *= h2 ; u2[2] *= h2 ;
  u3[0] *= h1*h2 ; u3[1] *= h1*h2 ; u3[2] *= h1*h2 ;

  J[0] = u1[0] ; J[1] = u1[1] ; J[2] = u1[2] ; 
  J[3] = u2[0] ; J[4] = u2[1] ; J[5] = u2[2] ; 
  J[6] = u3[0] ; J[7] = u3[1] ; J[8] = u3[2] ; 
  bem3d_matrix_inverse(J, iJ) ;
  
  for ( i = 0 ; i < bem3d_element_node_number(e) ; i ++ ) {
    u1[0] = dLds[i] ; u1[1] = dLdt[i] ; u1[2] = 0.0 ;
    bem3d_matrix_vector_mul(iJ, u1, u2) ;
    w[i*3+0] = u2[0] ; w[i*3+1] = u2[1] ; w[i*3+2] = u2[2] ;
  }

  return BEM3D_SUCCESS ;
}

/** 
 * Check if a vertex is a corner of an element. 
 * 
 * @@param e a ::BEM3DElement;
 * @@param v a GtsVertex of \a e.
 * 
 * @@return the index of a corner of \a e if \a v is a corner, -1
 * otherwise.
 */

gint bem3d_element_vertex_is_corner(BEM3DElement *e, GtsVertex *v)

{
  gint i ;

  g_return_val_if_fail(e != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(BEM3D_IS_ELEMENT(e), BEM3D_ARGUMENT_WRONG_TYPE) ;
  g_return_val_if_fail(v != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(GTS_IS_VERTEX(v), BEM3D_ARGUMENT_WRONG_TYPE) ;

  for ( i = 0 ; i < bem3d_element_corner_number(e) ; i ++ ) 
    if ( bem3d_element_corner(e,i) == v ) return i ;

  return -1 ;
}

/** 
 * Locate a node of given global index on a ::BEM3DElement
 * 
 * @@param e a ::BEM3DElement;
 * @@param i global index of a node.
 * 
 * @@return local index of a node of \a e with global index \a i, if
 * found, -1 otherwise.
 */

gint bem3d_element_find_index(BEM3DElement *e, gint i)

{
  gint j ;

  g_return_val_if_fail(e != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(BEM3D_IS_ELEMENT(e), BEM3D_ARGUMENT_WRONG_TYPE) ;
  g_return_val_if_fail(i >= 0, BEM3D_ARGUMENT_OUT_OF_RANGE) ;

  for ( j = 0 ; j < bem3d_element_node_number(e) ; j ++ ) 
    if ( bem3d_element_global_index(e, j) == i ) return j ;

  return -1 ;
}

/** 
 * Generate a ::GtsBBox containing the vertices of a ::BEM3DElement. 
 * 
 * @@param klass a GtsBBoxClass;
 * @@param e a ::BEM3DElement;
 * 
 * @@return a ::GtsBBox containing the vertices of \a e or NULL on
 * error.
 */

GtsBBox *bem3d_element_bounding_box(GtsBBoxClass *klass,
				    BEM3DElement *e)

{
  GtsBBox *b ;
  gint i ;
  gdouble x1, y1, z1, x2, y2, z2 ;

  g_return_val_if_fail(klass != NULL, NULL) ;
  g_return_val_if_fail(e != NULL, NULL) ;
  g_return_val_if_fail(BEM3D_IS_ELEMENT(e), NULL) ;

  x1 = y1 = z1 =  G_MAXDOUBLE ;
  x2 = y2 = z2 = -G_MAXDOUBLE ;
 
  for ( i = 0 ; i < bem3d_element_vertex_number(e) ; i ++ ) {
    x1 = MIN(x1, GTS_POINT(bem3d_element_vertex(e,i))->x) ;
    y1 = MIN(y1, GTS_POINT(bem3d_element_vertex(e,i))->y) ;
    z1 = MIN(z1, GTS_POINT(bem3d_element_vertex(e,i))->z) ;
    x2 = MAX(x2, GTS_POINT(bem3d_element_vertex(e,i))->x) ;
    y2 = MAX(y2, GTS_POINT(bem3d_element_vertex(e,i))->y) ;
    z2 = MAX(z2, GTS_POINT(bem3d_element_vertex(e,i))->z) ;
  }

  b = gts_bbox_new(klass, e, x1, y1, z1, x2, y2, z2) ;

  return b ;
}

gint bem3d_element_moments_make(BEM3DElement *e, gint H)

{
  gdouble x1[3], x2[3], x3[3] ;
  GtsVector s, t, n, r ;

  g_return_val_if_fail(e != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(BEM3D_IS_ELEMENT(e), BEM3D_ARGUMENT_WRONG_TYPE) ;
  g_return_val_if_fail(H >= 0, BEM3D_ARGUMENT_OUT_OF_RANGE) ;
  
  if ( e->Imn == NULL ) e->Imn = g_array_new(TRUE, TRUE, sizeof(gdouble)) ;
  g_array_set_size(e->Imn,(H+1)*(H+2)/2) ;

  if ( bem3d_element_shape_func(e) == bem3d_shfunc_t1 ) {
      gts_vector_init(s, 
		  GTS_POINT(bem3d_element_node(e,0)),
		  GTS_POINT(bem3d_element_node(e,1))) ;
      x2[0] = gts_vector_norm(s) ; x2[1] = 0.0 ;
      gts_vector_init(t, 
		      GTS_POINT(bem3d_element_node(e,1)),
		      GTS_POINT(bem3d_element_node(e,2))) ;
      gts_vector_cross(n, s, t) ;
      gts_vector_normalize(n) ; gts_vector_normalize(s) ;
      gts_vector_cross(t, n, s) ;
      x1[0] = x1[1] = x1[2] = x2[2] = x3[2] = 0.0 ;
  
      gts_vector_init(r, 
		      GTS_POINT(bem3d_element_node(e,0)),
		      GTS_POINT(bem3d_element_node(e,2))) ;
      x3[0] = gts_vector_scalar(r,s) ;
      x3[1] = gts_vector_scalar(r,t) ;
      newman_tri_moments(x1, x2, x3, H, 
			 (gdouble *)(&bem3d_element_moment(e,0,0))) ;
  } else 
    g_error("%s: only implemented for linear triangular elements",
	    __FUNCTION__) ;

  bem3d_element_moment_order(e) = H ;

  return BEM3D_SUCCESS ;
}

/** 
 * Find the ::BEM3DElement s shared by two GtsVertex s. 
 * 
 * @@param m a ::BEM3DMesh;
 * @@param v1 a vertex of \a m;
 * @@param v2 another vertex of \a m;
 * 
 * @@return a GSList of ::BEM3DElement s of \a m which contain both \a
 * v1 and \a v2.
 */

GSList *bem3d_elements_from_vertices(BEM3DMesh *m, GtsVertex *v1, 
				     GtsVertex *v2)

{
  GSList *e = NULL, *e1, *i ;

  g_return_val_if_fail(m != NULL, NULL) ;
  g_return_val_if_fail(BEM3D_IS_MESH(m), NULL) ;
  g_return_val_if_fail(v1 != NULL, NULL) ;
  g_return_val_if_fail(GTS_IS_VERTEX(v1), NULL) ;
  g_return_val_if_fail(v2 != NULL, NULL) ;
  g_return_val_if_fail(GTS_IS_VERTEX(v2), NULL) ;  
  g_return_val_if_fail(v1 != v2, NULL) ;  

  e1 = bem3d_mesh_vertex_elements(m, v1) ;
  for ( i = e1 ; i != NULL ; i = i->next ) 
    if ( bem3d_element_find_vertex(BEM3D_ELEMENT(i->data), v2) != -1 )
      e = g_slist_prepend(e, i->data) ;
  
  return e ;
}

/** 
 * Assemble equations for an element inserting directly into matrix
 * rows. Coefficients are accumulated directly in rows assuming
 * zero-offset indexing, with stride 1 for real problems and 2 for
 * complex, as determined from the Green's function.
 * 
 * @@param e a ::BEM3DElement
 * @@param x field (collocation) point
 * @@param ix index of \a x
 * @@param config ::BEM3DConfiguration for the problem
 * @@param gdata parameters for Green's function
 * @@param a matrix row which multiplies potential (\f$\phi\f$)
 * @@param b matrix row which multiplies normal derivative of 
 * potential (\f$\partial\phi/\partial n\f$)
 * 
 * @@return ::BEM3D_SUCCESS on success
 */

gint bem3d_element_assemble_equations_direct(BEM3DElement *e,
					     GtsPoint *x, gint ix,
					     BEM3DConfiguration *config,
					     BEM3DParameters *gdata,
					     gdouble *a, gdouble *b)

{
  BEM3DShapeFunc shfunc = bem3d_element_shape_func(e) ;
  BEM3DShapeFunc cpfunc = bem3d_element_node_func(e) ;
  static GArray *g = NULL ;
  static GArray *dgdn = NULL ;
  gdouble L[32], dLds[32], dLdt[32] ;
  static BEM3DQuadratureRule *q = NULL ;
  BEM3DQuadratureRuleFunc qf ;
  gpointer qd ;
  BEM3DGreensFunction gfunc ;
  gint i, j, k, idx, stride ;
  gdouble s, t, J, w, wt ;
  GtsPoint y ;
  GtsVector n ;

  g_return_val_if_fail(e != NULL, BEM3D_NULL_ARGUMENT) ;
  g_return_val_if_fail(BEM3D_IS_ELEMENT(e), BEM3D_ARGUMENT_WRONG_TYPE) ;
  g_return_val_if_fail(x != NULL, BEM3D_NULL_ARGUMENT) ;

  if ( q == NULL ) q = bem3d_quadrature_rule_new(0, 1) ;
  if ( g == NULL ) {
    g = g_array_new(FALSE, TRUE, sizeof(gdouble)) ;
    dgdn = g_array_new(FALSE, TRUE, sizeof(gdouble)) ;
  }
  
  gfunc = config->gfunc ;

  qf = config->qrule ; qd = config->qdata ;

  qf(x, e, q, &gfunc, gdata, qd) ;

  /* g_debug("%s: quadrature rule weights total: %g", */
  /* 	__FUNCTION__, bem3d_quadrature_rule_sum_weights(q)) ; */

  /*get the size of the Green's function*/
  if ( bem3d_greens_function_is_real(&gfunc) ) stride = 1 ;
  else stride = 2 ;

  for ( i = 0 ; i < bem3d_quadrature_vertex_number(q) ; i ++ ) {
    s = bem3d_quadrature_xi(q,i) ;
    t = bem3d_quadrature_eta(q,i) ;
    wt = bem3d_quadrature_weight(q,i) ;
    shfunc(s, t, L, dLds, dLdt, NULL) ;
    bem3d_element_position(e, L, &y) ;
    bem3d_element_normal(e, dLds, dLdt, n, &J) ;
    bem3d_greens_function_func(&gfunc)(x, &y, n, gdata, g, dgdn) ;
    cpfunc(s, t, L, NULL, NULL, NULL) ;
    J *= wt ;
    for ( j = 0 ; j < bem3d_element_node_number(e) ; j ++ ) {
      w = J*L[j] ;
      idx = bem3d_element_global_index(e,j) ;
      for ( k = 0 ; k < stride ; k ++ ) {
	a[idx*stride+k] += g_array_index(dgdn,gdouble,k)*w ;
	b[idx*stride+k] += g_array_index(g,gdouble,k)*w ;
      }
    }
  }

  if ( bem3d_quadrature_free_number(q) != 0 ) {
    if ( bem3d_quadrature_free_number(q) != bem3d_element_node_number(e) )
      g_error("%s: number of free terms (%d) in quadrature rule "
	      "does not match number of nodes on element (%d)",
	      __FUNCTION__, bem3d_quadrature_free_number(q), 
	      bem3d_element_node_number(e)) ;
    /*we should not arrive here in vector problems*/
    g_assert(q->wfree == 1) ;
    for ( j = 0 ; j < bem3d_element_node_number(e) ; j ++ ) {
      idx = bem3d_element_global_index(e,j) ;
      for ( k = 0 ; k < stride ; k ++ ) {
	a[idx*stride+k] += bem3d_quadrature_free_term_dg(q,j*stride+k) ;
	b[idx*stride+k] += bem3d_quadrature_free_term_g(q,j*stride+k) ;
      }
    }
  }

  return BEM3D_SUCCESS ;
}


/**
 * @@}
 * 
 */

@


1.4
log
@*** empty log message ***
@
text
@d3 1
a3 1
 * Copyright (C) 2006 Michael Carley
d33 2
d109 1
a109 1
 * @@param klass ::BEM3DElementClass (use ::bem3d_element_class())
d595 61
a707 5
  /* if ( qfunc == NULL ) qf = bem3d_quadrature_rule_default ; */
  /* else qf = qfunc ; */
  /* if ( qdata == NULL ) qd = bem3d_quadrature_selector_default() ; */
  /* else qd = qdata ; */

d753 5
a757 8
    /*we should not arrive here in complex problems*/
    g_assert(q->wfree == 1) ; g_assert(stride == 1) ;
    k = 0 ;
    for ( j = 0 ; j < bem3d_element_node_number(e) ; j ++ ) {
      g_array_index(G,gdouble,j*stride+k) += 
	bem3d_quadrature_free_term_g(q,j) ;
      g_array_index(dGdn,gdouble,j*stride+k) += 
	bem3d_quadrature_free_term_dg(q,j) ;
d1331 1
a1331 1
 * @@return a GSList of ::BEM3DElements of \a m which contain both \a
d1356 103
@


1.3
log
@*** empty log message ***
@
text
@d443 2
a444 2
  q = bem3d_quadrature_rule_new(ngp) ;
  bem3d_quadrature_rule_gauss(NULL, e, q, &ngp) ;
d529 2
a530 2
  g_assert(!isnan(normal[0])) ; g_assert(!isnan(normal[1])) ;
  g_assert(!isnan(normal[2])) ;
d601 2
a602 4
 * @@param gfunc ::BEM3DGreensFunc Green's function of problem;
 * @@param gdata user data for gfunc;
 * @@param qfunc ::BEM3DQuadratureRuleFunc quadrature rule function;
 * @@param qdata user data for quadrature rule;
d610 1
a610 1
				      BEM3DGreensFunc gfunc, 
a611 2
				      BEM3DQuadratureRuleFunc qfunc,
				      gpointer qdata,
d623 1
d643 1
a643 1
  if ( q == NULL ) q = bem3d_quadrature_rule_new(0) ; 
d645 4
a648 4
  if ( qfunc == NULL ) qf = bem3d_quadrature_rule_default ;
  else qf = qfunc ;
  if ( qdata == NULL ) qd = bem3d_quadrature_selector_default() ;
  else qd = qdata ;
d650 1
a650 1
  qf(x, e, q, qd) ;
d652 6
a657 2
  g_debug("%s: quadrature rule weights total: %g",
	__FUNCTION__, bem3d_quadrature_rule_sum_weights(q)) ;
d660 2
a661 5
  y.x = x->x+1.0 ; y.y = x->y+1.0 ; y.z = x->z+1.0 ;
  shfunc(0, 0, L, dLds, dLdt, NULL) ;
  bem3d_element_normal(e, dLds, dLdt, n, &J) ;
  gfunc(x, &y, n, gdata, g, dgdn) ;
  stride = g->len ;
d675 1
a675 1
    gfunc(x, &y, n, gdata, g, dgdn) ;
d1267 33
@


1.2
log
@*** empty log message ***
@
text
@d36 18
d57 2
a59 1
}
d78 1
a78 1
 * The basic class for BEM3DElement's. 
d80 1
a80 1
 * @@return the BEM3DElementClass
d107 2
a108 2
 * @@param klass BEM3DElementClass (use ::bem3d_element_class())
 * @@param nf number of GtsFace's on the element;
d113 3
a115 3
 * @@param ns number of sides/corners (e.g. three for triangular elements)
 * @@param shf pointer to shape function for geometry
 * @@param cpf pointer to shape function for collocation
d117 1
a117 1
 * @@return pointer to new element
d121 2
a122 2
			    gint nf, gint nv, gint nc, gint ns,
			    BEM3DShapeFunc shf, BEM3DShapeFunc cpf)
d128 7
a134 1
  g_assert(shf != NULL) ; g_assert(cpf != NULL) ;
d145 2
d168 3
a170 3
 * @@param e pointer to element
 * @@param f pointer to face to add
 * @@param i local face index for new face
d172 1
a172 1
 * @@return 0 on success
d178 7
a184 4
  if ( i >= bem3d_element_face_number(e) )
    g_log(G_LOG_DOMAIN, G_LOG_LEVEL_ERROR,
	  "%s: cannot add face number %d to %d face element",
	  __FUNCTION__, i, bem3d_element_face_number(e)) ;
d198 1
a198 1
 * @@return 0 on success.
d204 7
a210 4
  if ( i >= bem3d_element_vertex_number(e) )
    g_log(G_LOG_DOMAIN, G_LOG_LEVEL_ERROR,
	  "%s: cannot add vertex number %d to %d node element",
	  __FUNCTION__, i, bem3d_element_vertex_number(e)) ;
d224 1
a224 1
 * @@return 0 on success.
d230 4
d235 2
a236 2
    g_log(G_LOG_DOMAIN, G_LOG_LEVEL_ERROR,
	  "%s: cannot add collocation point number %d to %d collocation point element",
d251 1
a251 1
 * @@return 0 on success.
d257 7
a263 5
  if ( i >= bem3d_element_node_number(e) )
    g_log(G_LOG_DOMAIN, G_LOG_LEVEL_ERROR,
	  "%s: cannot set global index of %dth point of %d "
	  "collocation point element",
	  __FUNCTION__, i, bem3d_element_node_number(e)) ;
d277 1
a277 1
 * @@return 0 on success.
d283 6
a288 4
  if ( i >= bem3d_element_corner_number(e) )
    g_log(G_LOG_DOMAIN, G_LOG_LEVEL_ERROR,
	  "%s: cannot set %dth corner of %d corner element",
	  __FUNCTION__, i, bem3d_element_corner_number(e)) ;
d307 1
a307 1
 * @@return 0 on success.
d317 6
d381 5
a385 3
  for ( i = 0 ; i < e->nv ; i ++ ) {
    if ( e->v[i] == v ) return i ;
  }
d404 4
a407 4
  g_return_val_if_fail(e != NULL, BEM3D_EINVAL) ;
  g_return_val_if_fail(IS_BEM3D_ELEMENT(e), BEM3D_EINVAL) ;
  g_return_val_if_fail(v != NULL, BEM3D_EINVAL) ;
  g_return_val_if_fail(GTS_IS_VERTEX(v), BEM3D_EINVAL) ;
d409 1
a409 3
  for ( i = 0 ; i < e->nc ; i ++ ) {
    if ( e->c[i] == v ) return i ;
  }
d419 1
a419 2
 * @@param ngp number of quadrature points to use;
 * @@param dA area of element. 
d421 1
a421 1
 * @@return 0 on success.
d424 1
a424 1
gint bem3d_element_area(BEM3DElement *e, gint ngp, gdouble *dA)
d427 1
a427 1
  gdouble J ;
d429 1
a429 1
  BEM3DShapeFunc sf = bem3d_element_shapefunc(e) ;
d433 3
a435 2
  g_return_val_if_fail(e != NULL, BEM3D_EINVAL) ;
  g_return_val_if_fail(dA != NULL, BEM3D_EINVAL) ;
d446 1
a446 1
  *dA = 0.0 ;
d450 2
a451 2
    bem3d_element_jacobian(e, dLds, dLdt, &J) ;
    *dA += bem3d_quadrature_weight(q,i)*J ;
d454 1
a454 1
  return BEM3D_SUCCESS ;
d465 1
a465 1
 * @@return 0 on success.
d474 5
a478 4
/*   g_debug("%s: L=%p; q=%p", __FUNCTION__, L, q) ; */
  g_return_val_if_fail(e != NULL, BEM3D_EINVAL) ;
  g_return_val_if_fail(L != NULL, BEM3D_EINVAL) ;
  g_return_val_if_fail(q != NULL, BEM3D_EINVAL) ;
d497 1
a497 2
 * @@param dLdt shape function derivatives \f$\partial L_{i}/\partial \eta\f$; 
 * @@param J Jacobian. 
d499 1
a499 1
 * @@return 0 on success. 
d502 2
a503 3
gint bem3d_element_jacobian(BEM3DElement *e, gdouble *dLds, gdouble *dLdt,
			  gdouble *J)

d507 1
d510 4
a513 4
  g_return_val_if_fail(e != NULL, BEM3D_EINVAL) ;
  g_return_val_if_fail(dLds != NULL, BEM3D_EINVAL) ;
  g_return_val_if_fail(dLdt != NULL, BEM3D_EINVAL) ;
  g_return_val_if_fail(J != NULL, BEM3D_EINVAL) ;
d532 2
a533 2
  *J = sqrt(normal[0]*normal[0] + normal[1]*normal[1] + 
	    normal[2]*normal[2]) ;
d535 1
a535 1
  return BEM3D_SUCCESS ;
d548 1
a548 1
 * @@return 0 on success;
d552 1
a552 1
			GtsVector normal, gdouble *J)
d558 6
a563 5
  g_return_val_if_fail(e != NULL, BEM3D_EINVAL) ;
  g_return_val_if_fail(dLds != NULL, BEM3D_EINVAL) ;
  g_return_val_if_fail(dLdt != NULL, BEM3D_EINVAL) ;
  g_return_val_if_fail(normal != NULL, BEM3D_EINVAL) ;
  g_return_val_if_fail(J != NULL, BEM3D_EINVAL) ;
d579 2
a580 4
  if ( isnan(normal[0]) || isnan(normal[1]) || isnan(normal[2]) ) {
    g_log(G_LOG_DOMAIN, G_LOG_LEVEL_ERROR,
	  "%s: NaN in normal", __FUNCTION__) ;
  }
d608 1
a608 1
 * @@return 0 on success.
d619 1
a619 1
  BEM3DShapeFunc shfunc = bem3d_element_shapefunc(e) ;
d625 2
d632 5
a636 6
  g_return_val_if_fail(e != NULL, BEM3D_EINVAL) ;
  g_return_val_if_fail(x != NULL, BEM3D_EINVAL) ;
  g_return_val_if_fail(gfunc != NULL, BEM3D_EINVAL) ;
  g_return_val_if_fail(qfunc != NULL, BEM3D_EINVAL) ;
  g_return_val_if_fail(G != NULL, BEM3D_EINVAL) ;
  g_return_val_if_fail(dGdn != NULL, BEM3D_EINVAL) ;
d648 6
a653 1
  qfunc(x, e, q, qdata) ;
d655 1
a655 3
  g_log(G_LOG_DOMAIN,
	G_LOG_LEVEL_DEBUG,
	"%s: quadrature rule weights total: %g",
d660 1
d691 17
d726 1
d728 1
d742 6
a747 3
  g_return_val_if_fail(e != NULL, BEM3D_EINVAL) ;
  g_return_val_if_fail(v != NULL, BEM3D_EINVAL) ;
  g_return_val_if_fail(w != NULL, BEM3D_EINVAL) ;
d763 4
a766 2
  g_return_val_if_fail(e != NULL, BEM3D_EINVAL) ;
  g_return_val_if_fail(f != NULL, BEM3D_EINVAL) ;
d780 10
a789 3
  g_return_val_if_fail(m != NULL, BEM3D_EINVAL) ;
  g_return_val_if_fail(e != NULL, BEM3D_EINVAL) ;

d819 1
a819 1
			GtsVector dxds, GtsVector dxdt)
d824 7
d862 1
d864 1
d893 1
d895 1
d942 1
d944 1
d969 1
a969 1
 * @@return 0 on success.
d977 5
a981 2
  g_return_val_if_fail(e != NULL, BEM3D_EINVAL) ;
  g_return_val_if_fail(m != NULL, BEM3D_EINVAL) ;  
d1009 1
a1009 1
 * @@return 0 on success
d1013 3
a1015 3
			       gdouble dLds[], gdouble dLdt[],
			       GtsVector u1, gdouble *h1,
			       GtsVector u2, gdouble *h2)
d1019 8
a1026 1
  g_return_val_if_fail(e != NULL, BEM3D_EINVAL) ;
d1064 5
d1098 1
a1098 1
 * @@return 0 on success. 
d1112 5
a1116 1
  shfunc = bem3d_element_shapefunc(e) ;
d1154 4
a1157 4
  g_return_val_if_fail(e != NULL, BEM3D_EINVAL) ;
  g_return_val_if_fail(IS_BEM3D_ELEMENT(e), BEM3D_EINVAL) ;
  g_return_val_if_fail(v != NULL, BEM3D_EINVAL) ;
  g_return_val_if_fail(GTS_IS_VERTEX(v), BEM3D_EINVAL) ;
d1180 3
a1182 3
  g_return_val_if_fail(e != NULL, BEM3D_EINVAL) ;
  g_return_val_if_fail(IS_BEM3D_ELEMENT(e), BEM3D_EINVAL) ;
  g_return_val_if_fail(i >= 0, BEM3D_EINVAL) ;
d1210 1
a1210 1
  g_return_val_if_fail(IS_BEM3D_ELEMENT(e), NULL) ;
d1229 42
@


1.1
log
@Initial revision
@
text
@d20 4
d30 3
d36 1
a36 5
#include "bem.h"
#include "bem-private.h"


static void bem_element_class_init (BEMElementClass * klass)
d42 1
a42 1
static void bem_element_init (BEMElement * object)
d48 1
a48 1
 * @@defgroup belement BEM elements
d50 1
a50 1
 * The definitions of the basic ::BEMElement and the functions for
a57 1

d59 1
a59 1
 * The basic class for BEMElement's. 
d61 1
a61 1
 * @@return the BEMElementClass
d64 1
a64 1
BEMElementClass * bem_element_class (void)
d66 1
a66 1
  static BEMElementClass * klass = NULL;
d69 6
a74 6
    GtsObjectClassInfo bem_element_info = {
      "BEMElement",
      sizeof (BEMElement),
      sizeof (BEMElementClass),
      (GtsObjectClassInitFunc) bem_element_class_init,
      (GtsObjectInitFunc) bem_element_init,
d79 1
a79 1
				  &bem_element_info);
d86 1
a86 1
 * Allocate a new ::BEMElement
d88 1
a88 1
 * @@param klass BEMElementClass (use ::bem_element_class())
d101 1
a101 1
BEMElement *bem_element_new(BEMElementClass * klass,
d103 1
a103 1
			    BEMShapeFunc shf, BEMShapeFunc cpf)
d106 1
a106 1
  BEMElement *e ;
d111 1
a111 1
  e = BEM_ELEMENT (gts_object_new (GTS_OBJECT_CLASS (klass)));
d139 1
a139 1
 * Add a new face to a ::BEMElement. 
d148 1
a148 1
gint bem_element_add_face(BEMElement *e, gpointer f, gint i)
d151 1
a151 1
  if ( i >= bem_element_nfaces(e) )
d154 1
a154 1
	  __FUNCTION__, i, bem_element_nfaces(e)) ;
d158 1
a158 1
  return BEM_SUCCESS ;
d162 1
a162 1
 * Add a GtsVertex to a ::BEMElement.
d164 1
a164 1
 * @@param e pointer to ::BEMElement;
d171 1
a171 1
gint bem_element_add_vertex(BEMElement *e, gpointer v, gint i)
d174 1
a174 1
  if ( i >= bem_element_nv(e) )
d177 1
a177 1
	  __FUNCTION__, i, bem_element_nv(e)) ;
d181 1
a181 1
  return BEM_SUCCESS ;
d185 1
a185 1
 * Add a collocation point to a ::BEMElement
d187 1
a187 1
 * @@param e pointer to ::BEMElement;
d194 1
a194 1
gint bem_element_add_cpt(BEMElement *e, gpointer v, gint i)
d197 1
a197 1
  if ( i >= bem_element_ncpt(e) )
d200 1
a200 1
	  __FUNCTION__, i, bem_element_ncpt(e)) ;
d204 1
a204 1
  return BEM_SUCCESS ;
d210 1
a210 1
 * @@param e pointer to ::BEMElement;
d217 1
a217 1
gint bem_element_set_index(BEMElement *e, gint i, gint j)
d220 1
a220 1
  if ( i >= bem_element_ncpt(e) )
d222 3
a224 2
	  "%s: cannot set global index of %dth point of %d collocation point element",
	  __FUNCTION__, i, bem_element_ncpt(e)) ;
d228 1
a228 1
  return BEM_SUCCESS ;
d232 1
a232 1
 * Set a corner of a ::BEMElement.
d234 1
a234 1
 * @@param e BEMElement to set;
d241 1
a241 1
gint bem_element_set_corner(BEMElement *e, gint i, gint j) 
d244 1
a244 1
  if ( i >= bem_element_ncorner(e) )
d247 1
a247 1
	  __FUNCTION__, i, bem_element_ncorner(e)) ;
d251 1
a251 1
  return BEM_SUCCESS ;
d255 1
a255 1
 * Write a ::BEMElement to file. Usually called from bem_mesh_write. 
d269 3
a271 3
gint bem_element_write(BEMElement *e, 
		       GHashTable *v, GHashTable *t,
		       FILE *f)
d284 2
a285 2
	  bem_shapefunc_lookup_name(e->shf),
	  bem_shapefunc_lookup_name(e->cpf)) ;
d317 1
a317 1
  return BEM_SUCCESS ;
d321 1
a321 1
 * Find the local index of a GtsVertex on a ::BEMElement. 
d323 1
a323 1
 * @@param e ::BEMElement to search;
d329 1
a329 1
gint bem_element_find_vertex(BEMElement *e, GtsVertex *v)
d338 1
a338 1
  return BEM_FAILURE ;
d342 1
a342 1
 * Find the local index of a collocation point on a ::BEMElement.
d344 1
a344 1
 * @@param e ::BEMElement to search;
d350 1
a350 1
gint bem_element_find_cpt(BEMElement *e, GtsVertex *v)
d355 4
a358 2
  g_return_val_if_fail(e != NULL, BEM_EINVAL) ;
  g_return_val_if_fail(v != NULL, BEM_EINVAL) ;
d364 1
a364 1
  return BEM_FAILURE ;
d368 1
a368 1
 * Surface area of a ::BEMElement, computed using a Gaussian
d371 1
a371 1
 * @@param e ::BEMElement;
d378 1
a378 1
gint bem_element_area(BEMElement *e, gint ngp, gdouble *dA)
d383 2
a384 2
  BEMShapeFunc sf = bem_element_shapefunc(e) ;
  BEMQuadratureRule *q ;
d387 2
a388 2
  g_return_val_if_fail(e != NULL, BEM_EINVAL) ;
  g_return_val_if_fail(dA != NULL, BEM_EINVAL) ;
d391 3
a393 3
    L = (gdouble *)g_malloc(bem_element_ncpt(e)*4*sizeof(gdouble)) ;
    dLds = (gdouble *)g_malloc(bem_element_ncpt(e)*4*sizeof(gdouble)) ;
    dLdt = (gdouble *)g_malloc(bem_element_ncpt(e)*4*sizeof(gdouble)) ;
d396 2
a397 2
  q = bem_quadrature_rule_new(ngp) ;
  bem_quadrature_rule_gauss(NULL, e, q, &ngp) ;
d400 5
a404 5
  for ( i = 0 ; i < bem_quadrature_npts(q) ; i ++ ) {
    sf(bem_quadrature_xi(q,i),
       bem_quadrature_eta(q,i), L, dLds, dLdt, NULL) ;
    bem_element_jacobian(e, dLds, dLdt, &J) ;
    *dA += bem_quadrature_weight(q,i)*J ;
d407 1
a407 1
  return BEM_SUCCESS ;
d411 2
a412 1
 * Interpolate position on a ::BEMElement given a set of shape functions. 
d414 1
a414 1
 * @@param e ::BEMElement;
d421 2
a422 2
gint bem_element_position(BEMElement *e, gdouble *L,
			  GtsPoint *q)
d427 4
a430 3
  g_return_val_if_fail(e != NULL, BEM_EINVAL) ;
  g_return_val_if_fail(L != NULL, BEM_EINVAL) ;
  g_return_val_if_fail(q != NULL, BEM_EINVAL) ;
d434 1
a434 1
  for ( i = 0 ; i < bem_element_nv(e) ; i ++ ) {
d440 1
a440 1
  return BEM_SUCCESS ;
d444 2
a445 1
 * Compute Jacobian on a ::BEMElement given derivatives of shape functions. 
d447 1
a447 1
 * @@param e ::BEMElement;
d455 1
a455 1
gint bem_element_jacobian(BEMElement *e, gdouble *dLds, gdouble *dLdt,
d462 5
a466 4
  g_return_val_if_fail(e != NULL, BEM_EINVAL) ;
  g_return_val_if_fail(dLds != NULL, BEM_EINVAL) ;
  g_return_val_if_fail(dLdt != NULL, BEM_EINVAL) ;
  g_return_val_if_fail(J != NULL, BEM_EINVAL) ;
d471 1
a471 1
  for ( i = 0 ; i < bem_element_nv(e) ; i ++ ) {
d488 1
a488 1
  return BEM_SUCCESS ;
d492 1
a492 1
 * Compute normal to, and Jacobian on, a BEMElement given shape
d495 1
a495 1
 * @@param e ::BEMElement;
d504 1
a504 1
gint bem_element_normal(BEMElement *e, gdouble *dLds, gdouble *dLdt,
d511 5
a515 5
  g_return_val_if_fail(e != NULL, BEM_EINVAL) ;
  g_return_val_if_fail(dLds != NULL, BEM_EINVAL) ;
  g_return_val_if_fail(dLdt != NULL, BEM_EINVAL) ;
  g_return_val_if_fail(normal != NULL, BEM_EINVAL) ;
  g_return_val_if_fail(J != NULL, BEM_EINVAL) ;
d520 1
a520 1
  for ( i = 0 ; i < bem_element_nv(e) ; i ++ ) {
d543 1
a543 1
  return BEM_SUCCESS ;
d547 1
a547 1
 * Assemble equations for ::BEMElement and GtsPoint.
d553 1
a553 1
 * @@param e ::BEMElement;
d555 1
a555 1
 * @@param gfunc ::BEMGreensFunc Green's function of problem;
d557 1
a557 1
 * @@param qfunc ::BEMQuadratureRuleFunc quadrature rule function;
d565 6
a570 5
gint bem_element_assemble_equations(BEMElement *e, GtsPoint *x,
				    BEMGreensFunc gfunc, gpointer gdata,
				    BEMQuadratureRuleFunc qfunc,
				    gpointer qdata,
				    GArray *G, GArray *dGdn)
d573 3
a575 3
  BEMShapeFunc shfunc = bem_element_shapefunc(e) ;
  BEMShapeFunc cpfunc = bem_element_collfunc(e) ;
  static BEMQuadratureRule *q = NULL ;
d584 6
a589 6
  g_return_val_if_fail(e != NULL, BEM_EINVAL) ;
  g_return_val_if_fail(x != NULL, BEM_EINVAL) ;
  g_return_val_if_fail(gfunc != NULL, BEM_EINVAL) ;
  g_return_val_if_fail(qfunc != NULL, BEM_EINVAL) ;
  g_return_val_if_fail(G != NULL, BEM_EINVAL) ;
  g_return_val_if_fail(dGdn != NULL, BEM_EINVAL) ;
d594 3
a596 3
    L = (gdouble *)g_malloc(4*bem_element_ncpt(e)*sizeof(gdouble)) ;
    dLds = (gdouble *)g_malloc(4*bem_element_ncpt(e)*sizeof(gdouble)) ;
    dLdt = (gdouble *)g_malloc(4*bem_element_ncpt(e)*sizeof(gdouble)) ;
d599 1
a599 1
  if ( q == NULL ) q = bem_quadrature_rule_new(0) ; 
d606 1
a606 1
	__FUNCTION__, bem_quadrature_rule_sum_weights(q)) ;
d609 2
a610 5
  s = bem_quadrature_xi(q,0) ;
  t = bem_quadrature_eta(q,0) ;
  shfunc(s, t, L, dLds, dLdt, NULL) ;
  bem_element_position(e, L, &y) ;
  bem_element_normal(e, dLds, dLdt, n, &J) ;
d613 2
a614 2
  g_array_set_size(G,bem_element_ncpt(e)*stride) ; 
  g_array_set_size(dGdn,bem_element_ncpt(e)*stride) ;  
d619 4
a622 4
  for ( i = 0 ; i < bem_quadrature_npts(q) ; i ++ ) {
    s = bem_quadrature_xi(q,i) ;
    t = bem_quadrature_eta(q,i) ;
    wt = bem_quadrature_weight(q,i) ;
d624 2
a625 2
    bem_element_position(e, L, &y) ;
    bem_element_normal(e, dLds, dLdt, n, &J) ;
d629 1
a629 1
    for ( j = 0 ; j < bem_element_ncpt(e) ; j ++ ) {
d640 1
a640 1
  return BEM_SUCCESS ;
d644 1
a644 1
 * Check if a GtsVertex is on a ::BEMElement.
d646 1
a646 1
 * @@param e ::BEMElement;
d652 1
a652 1
gboolean bem_element_has_vertex(BEMElement *e, GtsVertex *v)
d660 1
a660 1
  for ( i = 0 ; i < bem_element_nv(e) ; i ++ ) {
d667 1
a667 1
gint bem_element_replace_vertex(BEMElement *e, GtsVertex *v, GtsVertex *w)
d672 3
a674 3
  g_return_val_if_fail(e != NULL, BEM_EINVAL) ;
  g_return_val_if_fail(v != NULL, BEM_EINVAL) ;
  g_return_val_if_fail(w != NULL, BEM_EINVAL) ;
d676 1
a676 1
  i = bem_element_find_vertex(e, v) ;
d678 1
a678 1
  if ( i == BEM_FAILURE ) return BEM_SUCCESS ;
d682 1
a682 1
  return BEM_SUCCESS ;
d685 1
a685 1
gint bem_element_find_face(BEMElement *e, GtsFace *f)
d690 2
a691 2
  g_return_val_if_fail(e != NULL, BEM_EINVAL) ;
  g_return_val_if_fail(f != NULL, BEM_EINVAL) ;
d695 1
a695 1
  return BEM_FAILURE ;
d698 1
a698 1
gint bem_element_reset_index(BEMMesh *m, BEMElement *e, gint i, gint j)
d701 1
a701 1
#ifndef _FOREACH_USE_HASH_TABLE_
d705 2
a706 2
  g_return_val_if_fail(m != NULL, BEM_EINVAL) ;
  g_return_val_if_fail(e != NULL, BEM_EINVAL) ;
d709 2
a710 2
  
#ifndef _FOREACH_USE_HASH_TABLE_
d712 1
a712 1
			  GINT_TO_POINTER(bem_element_global_index(e,i)+1)
d716 11
a726 2
			GINT_TO_POINTER(bem_element_global_index(e,i)+1),
			GINT_TO_POINTER(m->cpt->len)) ;
d728 2
d733 1
a733 1
  return BEM_SUCCESS ;
d736 1
a736 1
gint bem_element_slopes(BEMElement *e, gdouble *dLds, gdouble *dLdt,
d745 1
a745 1
  for ( i = 0 ; i < bem_element_nv(e) ; i ++ ) {
d754 1
a754 1
  return BEM_SUCCESS ;
d758 1
a758 1
 * Find collocation points shared between two ::BEMElement's. 
d760 2
a761 2
 * @@param e1 ::BEMElement;
 * @@param e2 ::BEMElement.
d766 1
a766 1
GSList *bem_element_common_cpts(BEMElement *e1, BEMElement *e2)
d775 3
a777 3
  for ( i = 0 ; i < bem_element_ncpt(e1) ; i ++ ) {
    if ( bem_element_find_cpt(e2, bem_element_cpoint(e1,i)) != -1 ) {
      c = g_slist_prepend(c, bem_element_cpoint(e1,i)) ;
d785 1
a785 1
 * Find the elements of a ::BEMMesh which share an edge with a
d788 2
a789 2
 * @@param el ::BEMElement whose neighbours are sought;
 * @@param m ::BEMMesh.
d794 1
a794 1
GSList *bem_element_neighbours(BEMElement *el, BEMMesh *m)
d798 1
a798 1
  BEMElement *g ;
d804 2
a805 2
  for ( i = 0 ; i < bem_element_nfaces(el) ; i ++ ) {
    if ( !g_slist_find(edges, GTS_TRIANGLE(bem_element_face(el,i))->e1) )
d807 2
a808 2
			      GTS_TRIANGLE(bem_element_face(el,i))->e1) ;
    if ( !g_slist_find(edges, GTS_TRIANGLE(bem_element_face(el,i))->e2) )
d810 2
a811 2
			      GTS_TRIANGLE(bem_element_face(el,i))->e2) ;
    if ( !g_slist_find(edges, GTS_TRIANGLE(bem_element_face(el,i))->e3) )
d813 1
a813 1
			      GTS_TRIANGLE(bem_element_face(el,i))->e3) ;
d818 1
a818 1
      g = bem_mesh_face_element(m, GTS_FACE(f->data)) ;
d834 1
a834 1
 * @@param m ::BEMMesh
d838 1
a838 1
 * @@return ::BEMElement containing \a v with index \a i.
d841 1
a841 1
BEMElement *bem_element_from_cpoint(BEMMesh *m, GtsVertex *v, gint i)
d845 1
a845 1
  BEMElement *e ;
d851 1
a851 1
  el = bem_mesh_vertex_elements(m, v) ;
d855 2
a856 2
    k = bem_element_find_cpt(BEM_ELEMENT(el->data), v) ;
    if ( bem_element_global_index(BEM_ELEMENT(el->data),k) == i )
d864 2
a865 2
 * Index the collocation points of a ::BEMElement. If a point is
 * present in the ::BEMMesh \a m, the collocation point there is
d869 2
a870 2
 * @@param e ::BEMElement to index
 * @@param m ::BEMMesh for index checking
d877 1
a877 1
gint bem_element_index_cpoints(BEMElement *e, BEMMesh *m, gint *n)
d882 2
a883 2
  g_return_val_if_fail(e != NULL, BEM_EINVAL) ;
  g_return_val_if_fail(m != NULL, BEM_EINVAL) ;  
d885 2
a886 2
  for ( i = 0 ; i < bem_element_ncpt(e) ; i ++ ) {
    j = bem_mesh_index_from_cpoint(m, bem_element_cpoint(e,i)) ;
d888 1
a888 1
      bem_element_set_index(e, i, (*n)) ; (*n) ++ ;
d890 1
a890 1
      bem_element_set_index(e, i, j) ;
d894 1
a894 1
  return BEM_SUCCESS ;
d899 1
a899 1
 * the surface at a point of a ::BEMElement.
d901 1
a901 1
 * @@param e ::BEMElement
d914 1
a914 1
gint bem_element_local_vectors(BEMElement *e,
d921 1
a921 1
  g_return_val_if_fail(e != NULL, BEM_EINVAL) ;
d925 7
a931 7
  for ( i = 0 ; i < bem_element_nv(e) ; i ++ ) {
    u1[0] += dLds[i]*GTS_POINT(bem_element_node(e,i))->x ;
    u1[1] += dLds[i]*GTS_POINT(bem_element_node(e,i))->y ;
    u1[2] += dLds[i]*GTS_POINT(bem_element_node(e,i))->z ;
    u2[0] += dLdt[i]*GTS_POINT(bem_element_node(e,i))->x ;
    u2[1] += dLdt[i]*GTS_POINT(bem_element_node(e,i))->y ;
    u2[2] += dLdt[i]*GTS_POINT(bem_element_node(e,i))->z ;
d939 1
a939 1
  return BEM_SUCCESS ;
d943 1
a943 1
 * Find the GtsEdge's common to two ::BEMElement's. 
d945 2
a946 2
 * @@param e1 ::BEMElement
 * @@param e2 ::BEMElement
d952 1
a952 1
GSList *bem_elements_common_edges(BEMElement *e1, BEMElement *e2)
d959 2
a960 2
  for ( i = 0 ; i < bem_element_nfaces(e1) ; i ++ ) {
    for ( j = 0 ; j < bem_element_nfaces(e2) ; j ++ ) {
d962 2
a963 2
	    gts_triangles_common_edge(GTS_TRIANGLE(bem_element_face(e1,i)),
				      GTS_TRIANGLE(bem_element_face(e2,j)))
d975 1
a975 1
 * ::BEMElement. The gradient \f$\partial\phi/\partial
d982 1
a982 1
 * @@param e ::BEMElement
d991 2
a992 2
gint bem_element_gradient_weights(BEMElement *e, gdouble xi, gdouble eta,
				  gdouble *w)
d996 2
a997 2
  BEMShapeFunc shfunc ;
  BEMMatrix J, iJ ;
d1002 1
a1002 1
  shfunc = bem_element_shapefunc(e) ;
d1005 1
a1005 1
  bem_element_local_vectors(e, dLds, dLdt, u1, &h1, u2, &h2) ;
d1014 1
a1014 1
  bem_matrix_inverse(J, iJ) ;
d1016 1
a1016 1
  for ( i = 0 ; i < bem_element_ncpt(e) ; i ++ ) {
d1018 1
a1018 1
    bem_matrix_vector_mul(iJ, u1, u2) ;
d1022 91
a1112 1
  return BEM_SUCCESS ;
@
