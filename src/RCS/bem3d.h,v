head	1.4;
access;
symbols;
locks
	ensmjc:1.4; strict;
comment	@ * @;


1.4
date	2017.07.03.10.47.49;	author ensmjc;	state Exp;
branches;
next	1.3;

1.3
date	2009.08.17.15.28.35;	author ensmjc;	state Exp;
branches;
next	1.2;

1.2
date	2009.01.20.13.21.12;	author ensmjc;	state Exp;
branches;
next	1.1;

1.1
date	2008.10.10.10.35.44;	author ensmjc;	state Exp;
branches;
next	;


desc
@@


1.4
log
@*** empty log message ***
@
text
@/* bem3d.h
 * 
 * Copyright (C) 2006, 2009 Michael Carley
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#ifndef BEM3D_H_INCLUDED
#define BEM3D_H_INCLUDED

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#include <stdio.h>
#include <glib.h>
#include <gts.h>

#include <bem3dconfig.h>

#ifdef BEM3D_HAVE_GMC
#include <gmc.h>
#endif /*BEM3D_HAVE_GMC*/

  /*configuration options for the maintainer*/
#define _FOREACH_USE_HASH_TABLE_ 1

#ifndef BEM3D_QUADRATURE_CACHING
#define BEM3D_QUADRATURE_CACHING 0
#endif /*BEM3D_QUADRATURE_CACHING*/

  /**
   * @@enum bem3d_error
   * @@ingroup logging
   * 
   * Return codes for BEM3D functions.
   */

  typedef enum {
    BEM3D_FAILURE = -1,		/**< unspecified failure */
    BEM3D_SUCCESS = 0,		/**< success */
    BEM3D_EINVAL = 1,		/**< invalid parameter */
    BEM3D_ITERMAX = 2,		/**< maximum number of iterations reached */
    BEM3D_UNKNOWN_FORMAT = 3,	/**< unrecognized file format */
    BEM3D_NULL_ARGUMENT = 4,	/**< argument NULL when it is required 
				   not to be */ 
    BEM3D_ARGUMENT_WRONG_TYPE = 5, /**< an argument was of an incompatible 
				      type */
    BEM3D_ARGUMENT_OUT_OF_RANGE = 6, /**< an argument was outside the valid 
					range */
    BEM3D_BLOCK_FULL = 7,	/**< a ::BEM3DMeshData was full */
    BEM3D_FILE_ERROR = 8        /**< file input or output error */
  } bem3d_error ;

  typedef enum {
    GAUSS_LINEAR = 0,
    GAUSS_LOGARITHMIC = 1,
    GAUSS_TRIANGULAR = 2, 
    GAUSS_CHEBYSHEV_2 = 3,
    GAUSS_HYPER = 4
  } quadrature_rule_t ;

  typedef enum {
    BEM3D_GMSH_SCALAR = 0,
    BEM3D_GMSH_VECTOR = 1,
    BEM3D_GMSH_TENSOR = 2
  } bem3d_gmsh_mode_t ;


  /**
   * @@addtogroup operators
   * @@{
   */
  
  /**
   * @@struct BEM3DOperator 
   *
   * Opaque data structure for computation of surface differential
   * operators. This should only be accessed through the relevant
   * functions and macros.
   * @@hideinitializer
   */

  typedef struct _BEM3DOperator BEM3DOperator ;

  struct _BEM3DOperator {
    GArray *w, *id ;
    gint nc ;
  } ;

  /**
   * The number of elements in a ::BEM3DOperator \a op, e.g. three
   * elements for a gradient operator, one for a Laplacian.
   * @@hideinitializer
   */

#define bem3d_operator_size(op) ((op->nc))

  /**
   * The number of nodes used in computing a ::BEM3DOperator \a op
   * @@hideinitializer
   */

#define bem3d_operator_length(op) ((op->id->len))

  /**
   * Global index of the \a i th node forming the operator \a op
   * @@hideinitializer
   */

#define bem3d_operator_index(op,i) ((g_array_index(op->id,gint,i)))

  /**
   * Weight for the x-component of \a i th node forming the operator \a op
   * @@hideinitializer
   */

#define bem3d_operator_weight(op,i) (&(g_array_index(op->w,gdouble,(op->nc)*i)))

  /**
   * Modes of calculating differential operators and vertex normals
   * from quantities on connected elements.
   */

typedef enum {
    BEM3D_AVERAGE_MWE,		/**< Mean weighted equally */
    BEM3D_AVERAGE_MWA,		/**< Mean weighted by angle */
    BEM3D_AVERAGE_MWSELR,	/**< Mean weighted by sine and edge 
				   length reciprocal*/ 
    BEM3D_AVERAGE_MWAAT,        /**< Mean weighted by areas of adjacent 
				   triangles*/
    BEM3D_AVERAGE_MWELR,        /**< Mean weighted by edge length reciprocals*/
    BEM3D_AVERAGE_MWRELR        /**< Mean weighted by square root of edge 
				   length reciprocals*/
  } BEM3DAverage ;

  /**
   * @@}
   * 
   */

#define BEM3D_PARAMETERS_WAVENUMBER     0
#define BEM3D_PARAMETERS_MACH_NUMBER    1
#define BEM3D_PARAMETERS_AMPLITUDE_REAL 2
#define BEM3D_PARAMETERS_AMPLITUDE_IMAG 3
#define BEM3D_PARAMETERS_NORMAL         4
#define BEM3D_PARAMETERS_LAMBDA_REAL    7
#define BEM3D_PARAMETERS_LAMBDA_IMAG    8
#define BEM3D_PARAMETERS_CONDITIONING   9

#define BEM3D_PARAMETERS_SIZE           16

  /**
   * @@typedef BEM3DShapeFunc
   * @@ingroup shapefunc
   *
   * BEM3D shape function definition
   * 
   * @@param s local coordinate
   * @@param t local coordinate
   * @@param L array to be filled with the shape function(s) at (s,t)
   * @@param dLds array to be filled with the derivatives of L at (s,t)
   * @@param dLdt array to be filled with the derivatives of L at (s,t)
   * @@param data data to be passed to the shape function
   *
   * @@return 0 on success
   */

  typedef gint (* BEM3DShapeFunc)(gdouble s, 
				  gdouble t, 
				  gdouble *L, 
				  gdouble *dLds, 
				  gdouble *dLdt,
				  gpointer data) ;


  /**
   * @@struct BEM3DMesh
   * @@ingroup mesh
   * Opaque data structure for a BEM3D Mesh. This should only be accessed
   * through the relevant functions and macros.
   */

  typedef struct _BEM3DMesh         BEM3DMesh ;

  struct _BEM3DMesh {
    /*< private >*/
    GtsSurface parent;
    GHashTable *e,
      *f,
      *c ;
/*     GByteArray *node ; */
    gint i0, i1 ;
    /*< public >*/
    /* add extra data here (if public) */
  } ;

  /**
   * @@struct BEM3DMeshClass
   * The basic class for a BEM3DMesh.
   * @@ingroup mesh
   */

  typedef struct _BEM3DMeshClass    BEM3DMeshClass;

  struct _BEM3DMeshClass {
    /*< private >*/
    GtsSurfaceClass parent_class;

    /*< public >*/
    /* add extra methods here */
  };

  /** 
   * @@ingroup mesh
   * Casts \a obj to ::BEM3DMesh
   * 
   * @@param obj a GtsObject
   * 
   * @@return result of casting \a obj to ::BEM3DMesh.
   * @@hideinitializer
   */
#define BEM3D_MESH(obj)            GTS_OBJECT_CAST (obj,		\
						    BEM3DMesh,		\
						    bem3d_mesh_class ())
  /** 
   * @@ingroup mesh
   * Casts \a klass to ::BEM3DMeshClass
   * 
   * @@param klass class to cast
   * 
   * @@hideinitializer
   */
#define BEM3D_MESH_CLASS(klass)    GTS_OBJECT_CLASS_CAST (klass,	\
							  BEM3DMeshClass, \
							  bem3d_mesh_class())

  /** 
   * @@ingroup mesh
   * TRUE if \a obj is from the ::BEM3DMeshClass class
   * 
   * @@hideinitializer
   */
#define BEM3D_IS_MESH(obj)         (gts_object_is_from_class \
				    (obj, bem3d_mesh_class ()))

  BEM3DMeshClass *bem3d_mesh_class  (void);
  BEM3DMesh *bem3d_mesh_new    (BEM3DMeshClass * klass,
				GtsFaceClass *face_class,
				GtsEdgeClass *edge_class,
				GtsVertexClass *vertex_class) ;

  /**
   * @@ingroup mesh
   * Number of elements in a ::BEM3DMesh
   * 
   * @@hideinitializer
   */

#define bem3d_mesh_element_number(m) (g_hash_table_size(m->e))

  /**
   * @@ingroup mesh
   * Minimum index of node to be considered in
   * ::bem3d_mesh_foreach_node
   *
   * @@hideinitializer
   */

#define bem3d_mesh_node_index_min(m) (m->i0)
  /**
   * @@ingroup mesh
   * Maximum index of node to be considered in
   * ::bem3d_mesh_foreach_node
   * 
   * @@hideinitializer
   */

#define bem3d_mesh_node_index_max(m) (m->i1)

  /**
   * @@struct BEM3DQuadratureRule
   * @@ingroup Quadrature
   *
   * Quadrature rule for integration on two-dimensional elements
   * containing the nodes and weights normalized to a unit simplex,
   * and a set of `free terms'.
   */

  typedef struct {
    gint nc, nmax, n, nfree, nfree_max, wfree ;
    gdouble *rule ;
    gdouble free_g[32], free_dg[32] ;
  } BEM3DQuadratureRule ;

  /**
   * @@typedef BEM3DElement 
   * Data type for BEM3D elements, containing the data
   * for geometry and collocation points. 
   *
   * The ::BEM3DElement type should usually be accessed only through the
   * provided functions and macros. In order to implement new elements,
   * you should look up the ::BEM3DElementBuildFunc type.
   *
   * @@ingroup belement
   * 
   */

  typedef struct _BEM3DElement         BEM3DElement;

  struct _BEM3DElement {
    /*< private >*/
    GtsObject parent;

    /*< public >*/
    /* add extra data here (if public) */
    gint nf,
      nv,
      nc,
      ns,
      mo,
      *i,
      *s ;
    gpointer *f,
      *v,
      *c ;
    gdouble *xs,
      *xc ;
    BEM3DShapeFunc shf,		
      cpf ;
    GArray *Imn ;
    gpointer reserved ;		
  };

  typedef struct _BEM3DElementClass    BEM3DElementClass;

  /**
   * @@typedef BEM3DElementClass
   * The basic class for a BEM3DElement
   * @@ingroup belement
   */

  struct _BEM3DElementClass {
    /*< private >*/
    GtsObjectClass parent_class;

    /*< public >*/
    /* add extra methods here */
  };

#define BEM3D_ELEMENT(obj)            GTS_OBJECT_CAST (obj,		\
						       BEM3DElement,	\
						       bem3d_element_class ())
#define BEM3D_ELEMENT_CLASS(klass)    GTS_OBJECT_CLASS_CAST (klass,	\
							     BEM3DElementClass,	\
							     bem3d_element_class())
#define BEM3D_IS_ELEMENT(obj)         (gts_object_is_from_class (obj,	\
								 bem3d_element_class ()))

  BEM3DElementClass * bem3d_element_class  (void);

  /**
   * Numerical data associated with a BEM3DMesh
   * 
   * @@hideinitializer
   */

  typedef struct {
    gint nd ;
    GHashTable *t ;
    GArray *d ;
  } BEM3DMeshData ;


  /**
   * @@struct BEM3DLookupFunc
   *
   * gint BEM3DLookupFunc(gint i, gint j, gpointer ldata, GArray *f,
   * GArray *g) ;
   *
   * Function for looking up data
   *
   * @@param i global index of collocation point
   * @@param j local index of collocation point
   * @@param ldata user data to pass to lookup function
   * @@param f solution at collocation point
   * @@param g normal derivative of solution at collocation point
   */

  typedef gint (*BEM3DLookupFunc)(gint i, gint j, gpointer ldata, 
				  GArray *f, GArray *g) ;

  struct _BEM3DParameters {
    gdouble f[BEM3D_PARAMETERS_SIZE] ;
    gint    n[BEM3D_PARAMETERS_SIZE] ;
    gpointer user_data ;
  } ;

  /**
   * @@struct BEM3DParameters
   * @@ingroup gfunc
   *
   * Basic parameter passing for Green's functions et al. Data can be
   * set or extracted using the predefined macros such as
   * ::bem3d_parameters_wavenumber and there is a field for
   * user-defined data which can be accessed using
   * ::bem3d_parameters_user_data.
   * 
   */

  typedef struct _BEM3DParameters BEM3DParameters ;

  /**
   * @@typedef BEM3DGreensFunc
   * @@ingroup gfunc
   *
   * gint BEM3DGreensFunc(GtsPoint *x, GtsPoint *y, GtsVector n, 
   * BEM3DParameters *p, GArray *G, GArray *dGdn)
   *
   * Green's function for various problems. The function should return
   * 0 on success and fill \a G with the Green's function and \a dGdn
   * with its normal derivative, or their equivalents for a particular
   * problem.
   * 
   * @@param x field point
   * @@param y source point
   * @@param n normal at source point
   * @@param param parameters to use in Green's function
   * @@param G Green's function
   * @@param dGdn normal derivative of Green's function
   */

  typedef gint (*BEM3DGreensFunc)(GtsPoint *x, GtsPoint *y,
				  GtsVector n, BEM3DParameters *p,
				  GArray *G, GArray *dGdn) ;

  typedef struct _BEM3DGreensFunction BEM3DGreensFunction ;

  /**
   * @@ingroup gfunc
   * @@struct BEM3DGreensFunction
   *
   * Opaque data structure for Green's functions. 
   *
   * @@hideinitializer
   */
  struct _BEM3DGreensFunction {
    BEM3DGreensFunc func ;
    gboolean real ;
    gint nc ;
  } ;

  /**
   * @@ingroup gfunc
   * The ::BEM3DGreensFunc of a ::BEM3DGreensFunction.
   *
   * @@param g a pointer to a ::BEM3DGreensFunction.
   *
   * @@return the ::BEM3DGreensFunc of \a g.
   * @@hideinitializer
   */
#define bem3d_greens_function_func(g)             ((g)->func)

  /**
   * @@ingroup gfunc
   * Check if a Green's function is real or complex.
   *
   * @@param g a pointer to a ::BEM3DGreensFunction.
   *
   * @@return TRUE if \a g is real.
   * @@hideinitializer
   */
#define bem3d_greens_function_is_real(g)          ((g)->real)

  /**
   * @@ingroup gfunc
   * Find the number of values returned by a Green's function.
   *
   * @@param g a pointer to a ::BEM3DGreensFunction.
   *
   * @@return the number of values returned for one call to \a g.
   * @@hideinitializer
   */
#define bem3d_greens_function_component_number(g) ((g)->nc)

  /**
   * @@ingroup gfunc
   * Wavenumber in a ::BEM3DParameters struct 
   *
   * @@param p a pointer to a ::BEM3DParameters struct
   *
   * @@return the value of the wavenumber contained in \a p
   * @@hideinitializer
   */

#define bem3d_parameters_wavenumber(p) ((p)->f[BEM3D_PARAMETERS_WAVENUMBER]) 

  /**
   * @@ingroup gfunc
   * Mach number in a ::BEM3DParameters struct 
   *
   * @@param p a pointer to a ::BEM3DParameters struct
   *
   * @@return the value of the Mach number field of \a p
   * @@hideinitializer
   */

#define bem3d_parameters_mach_number(p) ((p)->f[BEM3D_PARAMETERS_MACH_NUMBER])

  /**
   * @@ingroup gfunc 
   * Real part of amplitude in a ::BEM3DParameters
   * struct. The real and imaginary parts are aligned so that they can
   * be extracted together and cast, if necessary, to a gsl_complex
   * type. That is:
   * @@verbatim
   &(bem3d_parameters_amplitude_real(p)) @@endverbatim   
   * is a pointer to an array of type gdouble of length two, containing 
   * the real and imaginary parts of the magnitude.
   *
   * @@param p a pointer to a ::BEM3DParameters struct
   *
   * @@return the real part of the amplitude contained in \a p
   * @@hideinitializer
   */

#define bem3d_parameters_amplitude_real(p)	\
  ((p)->f[BEM3D_PARAMETERS_AMPLITUDE_REAL]) 

  /**
   * @@ingroup gfunc
   * Imaginary part of amplitude in a ::BEM3DParameters struct 
   *
   * @@param p a pointer to a ::BEM3DParameters struct
   *
   * @@return the imaginary part of the amplitude contained in \a p
   * @@hideinitializer
   */

#define bem3d_parameters_amplitude_imag(p)	\
  ((p)->f[BEM3D_PARAMETERS_AMPLITUDE_IMAG]) 

  /**
   * @@ingroup gfunc
   *
   * Normal to surface at evaluation point (e.g. in hypersingular
   * scattering calculations)
   *
   * @@param p a pointer to a ::BEM3DParameters struct
   *
   * @@return pointer to three element array of normal components (can be cast
   * to GtsVector)
   * @@hideinitializer
   */

#define bem3d_parameters_normal(p) (&((p)->f[BEM3D_PARAMETERS_NORMAL])) 

  /**
   * @@ingroup gfunc
   *
   * Real part of coupling parameter for Burton and Miller type
   * hypersingular formulations.
   *
   * @@param p a pointer to a ::BEM3DParameters struct
   *
   * @@return real part of coupling parameter (address can be cast to
   * *gsl_complex)
   *
   * @@hideinitializer
   */

#define bem3d_parameters_lambda_real(p) ((p)->f[BEM3D_PARAMETERS_LAMBDA_REAL])

  /**
   * @@ingroup gfunc
   *
   * Imaginary part of coupling parameter for Burton and Miller type
   * hypersingular formulations.
   *
   * @@param p a pointer to a ::BEM3DParameters struct
   *
   * @@return imaginary part of coupling parameter
   *
   * @@hideinitializer
   */

#define bem3d_parameters_lambda_imag(p) ((p)->f[BEM3D_PARAMETERS_LAMBDA_IMAG])

  /**
   * @@ingroup gfunc
   *
   * Conditioning parameter for Burton and Miller type hypersingular
   * formulations (see Wolf and Lele)
   *
   * @@param p a pointer to a ::BEM3DParameters struct
   *
   * @@return value of conditioning parameter
   *
   * @@hideinitializer
   */
#define bem3d_parameters_conditioning(p) ((p)->f[BEM3D_PARAMETERS_CONDITIONING])

  /**
   * @@ingroup gfunc
   * User data in a ::BEM3DParameters struct 
   *
   * @@param p a pointer to a ::BEM3DParameters struct
   *
   * @@return the gpointer reserved for user data in \a p
   * @@hideinitializer
   */

#define bem3d_parameters_user_data(p) ((p)->user_data)

  /**
   * @@struct BEM3DQuadratureRuleFunc
   * @@ingroup Quadrature 
   * gint BEM3DQuadratureRuleFunc(GtsPoint *p, BEM3DElement *e,
   * BEM3DQuadratureRule *q, BEM3DGreensFunction gfunc, 
   * BEM3DParameters *param, gpointer data)
   *
   * Function for generating quadrature rules
   * 
   * @@param p field point for integration;
   * @@param e element over which to integrate;
   * @@param q quadrature rule to hold points;
   * @@param gfunc Green's function to integrate (ignored for some rules);
   * @@param param parameters for @@a gfunc;
   * @@param data user data passed to quadrature generation.
   * 
   * @@return 0 on success
   */

  typedef gint (*BEM3DQuadratureRuleFunc)(GtsPoint *p, BEM3DElement *e,
					  BEM3DQuadratureRule *q, 
					  BEM3DGreensFunction *gfunc,
					  BEM3DParameters *param,
					  gpointer data) ;

#if 0
  /** 
   * @@ingroup gfunc
   * 
   * The averaging mode to be used in computing the normal for Green's
   * function calculations.
   *
   * @@param p a pointer to a ::BEM3DParameters struct;
   * 
   * @@return the ::BEM3DAverage mode for computing normals.
   * @@hideinitializer
   */

#define bem3d_parameters_normal_mode(p) ((p)-nmode)
#endif

  /**
   * Quadrature selection rule structure. 
   * @@ingroup Quadrature
   */

  typedef struct {
    GPtrArray *f ;
    GArray *sigma, *NM ;
  } BEM3DQuadratureSelector ;

#define bem3d_quadrature_selector_length(_s) ((_s)->f->len)
#define bem3d_quadrature_selector_rule(_s,_i) \
  (g_ptr_array_index((_s)->f,(_i)))
#define bem3d_quadrature_selector_sigma(_s,_i) \
  (g_array_index((_s)->sigma,gdouble,(_i)))
#define bem3d_quadrature_selector_data(_s,_i) \
  (g_array_index((_s)->NM,gint,(2*(_i))))

  /**
   * @@struct BEM3DEdge
   * 
   * A data structure for sharp edges on ::BEM3DMesh. It contains an
   * ordered list of mesh nodes with multiple indices, ordered to
   * give the correct orientation about the edge curve.
   *
   * @@hideinitializer
   */


typedef struct _BEM3DEdge         BEM3DEdge;

struct _BEM3DEdge {
  /*< private >*/
  GtsObject parent;

  /*< public >*/
  /* add extra data here (if public) */
  GArray *i ;
  GPtrArray *e, *v ;
  BEM3DMesh *m ;
};

typedef struct _BEM3DEdgeClass    BEM3DEdgeClass;

struct _BEM3DEdgeClass {
  /*< private >*/
  GtsObjectClass parent_class;

  /*< public >*/
  /* add extra methods here */
};

#define BEM3D_EDGE(obj)            GTS_OBJECT_CAST (obj,\
					         BEM3DEdge,\
					         bem3d_edge_class ())
#define BEM3D_EDGE_CLASS(klass)    GTS_OBJECT_CLASS_CAST (klass,\
						 BEM3DEdgeClass,\
						 bem3d_edge_class())
#define BEM3D_IS_EDGE(obj)         (gts_object_is_from_class (obj,\
						 bem3d_edge_class ()))

  /**
   * @@struct BEM3DElementBuildFunc
   * @@ingroup elements
   * Build an element from edge and vertex data
   * 
   * @@param e an array of edges
   * @@param v an array of vertices
   *
   * @@return a pointer to the newly built element
   *
   * The function should insert the vertices into the new element and
   * construct new faces and edges as required to build up the
   * element. Note that the ordering is important for the shape functions. 
   */

  typedef BEM3DElement *(*BEM3DElementBuildFunc)(GtsEdge **e, 
						 GtsVertex **v) ;

  /**
   * @@struct BEM3DNodeFunc
   *
   * A function which visits collocation points, usually called from
   * ::bem3d_mesh_foreach_node
   * 
   * @@param i the collocation point index
   * @@param item pointer to the vertex
   * @@param data user data to pass to the function 
   *
   * @@return 0 on success
   */

  typedef gint (*BEM3DNodeFunc)(gint i, gpointer item, gpointer data) ;

  /**
   * @@struct BEM3DELementFunc
   *
   * A function which visits elements, usually called from
   * bem3d_mesh_foreach_element
   * 
   * @@param item pointer to the element
   * @@param data user data to pass to the function 
   *
   * @@return 0 on success
   */

  typedef gint (*BEM3DElementFunc)(BEM3DElement *item, gpointer data) ;

  /**
   * @@struct BEM3DEquationFunc
   *
   * A function to insert data in an equation matrix
   *
   * @@param i row index 
   * @@param j column index 
   * @@param G Green's function matrix terms
   * @@param dGdn normal derivative terms
   * @@param n number of elements in term (e.g. 2 for complex data)
   * @@param data user data to pass to function
   *
   * @@return 0 on success
   */
  typedef gint (*BEM3DEquationFunc)(gint i, gint j,
				    gdouble *G, gdouble *dGdn,
				    gint n, gpointer data) ;

  /**
   * @@struct BEM3DBCFunc
   *
   * A function to set boundary conditions
   * 
   * @@param v the vertex at which to set the boundary condition;
   * @@param n the normal at that vertex;
   * @@param i the global index of the collocation point;
   * @@param data user data to pass to the function.
   *
   * @@return 0 on success
   */

  typedef gint (*BEM3DBCFunc)(GtsVertex *v, GtsVector n,
			      gint i, gpointer data) ;

  /**
   * @@struct BEM3DMeshDataFunc
   *
   * A function to set numerical data for a mesh and insert it in a
   * BEM3DMeshData variable
   *  
   * @@param i global index of node
   * @@param v node vertex
   * @@param data user data to pass to the function
   * @@param f array of output data
   * 
   * @@return 0 on success
   */

  typedef gint (*BEM3DMeshDataFunc)(gint i, GtsVertex *v, 
				    gpointer data, gdouble *f) ;

  /**
   * @@ingroup matrix
   *
   * A basic definition of a 3x3 matrix.
   * 
   */

  typedef gdouble BEM3DMatrix[9] ;

typedef struct _BEM3DMotion         BEM3DMotion;

struct _BEM3DMotion {
  /*< private >*/
  GtsObject parent;

  /*< public >*/
  /* add extra data here (if public) */
  BEM3DMesh *m, *m0 ;
  GHashTable *defs ;
  GString *x, *y, *z, *u, *v, *w ;
  gpointer fx, fy, fz, fdx, fdy, fdz, fd2x, fd2y, fd2z, fvx, fvy, fvz ;
} ;

typedef struct _BEM3DMotionClass    BEM3DMotionClass;

struct _BEM3DMotionClass {
  /*< private >*/
  GtsObjectClass parent_class;

  /*< public >*/
  /* add extra methods here */
};

#define BEM3D_MOTION(obj)            GTS_OBJECT_CAST (obj,\
					         BEM3DMotion,\
					         bem3d_motion_class ())
#define BEM3D_MOTION_CLASS(klass)    GTS_OBJECT_CLASS_CAST (klass,\
						 BEM3DMotionClass,\
						 bem3d_motion_class())
#define BEM3D_IS_MOTION(obj)         (gts_object_is_from_class (obj,\
						bem3d_motion_class ()))

#define bem3d_motion_mesh(mt)              ((mt)->m)
#define bem3d_motion_base_mesh(mt)         ((mt)->m0)
#define bem3d_motion_position_func_x(mt)   ((mt)->x->str)
#define bem3d_motion_position_func_y(mt)   ((mt)->y->str)
#define bem3d_motion_position_func_z(mt)   ((mt)->z->str)
#define bem3d_motion_velocity_func_u(mt)   ((mt)->u->str)
#define bem3d_motion_velocity_func_v(mt)   ((mt)->v->str)
#define bem3d_motion_velocity_func_w(mt)   ((mt)->w->str)
#define bem3d_motion_evaluator_x(mt)       ((mt)->fx)
#define bem3d_motion_evaluator_y(mt)       ((mt)->fy)
#define bem3d_motion_evaluator_z(mt)       ((mt)->fz)
#define bem3d_motion_evaluator_u(mt)       ((mt)->fvx)
#define bem3d_motion_evaluator_v(mt)       ((mt)->fvy)
#define bem3d_motion_evaluator_w(mt)       ((mt)->fvz)
#define bem3d_motion_evaluator_dx(mt)      ((mt)->fdx)
#define bem3d_motion_evaluator_dy(mt)      ((mt)->fdy)
#define bem3d_motion_evaluator_dz(mt)      ((mt)->fdz)
#define bem3d_motion_evaluator_d2x(mt)     ((mt)->fd2x)
#define bem3d_motion_evaluator_d2y(mt)     ((mt)->fd2y)
#define bem3d_motion_evaluator_d2z(mt)     ((mt)->fd2z)

typedef struct _BEM3DFunction         BEM3DFunction;

struct _BEM3DFunction {
  /*< private >*/
  GtsObject parent;

  /*< public >*/
  /* add extra data here (if public) */
  GHashTable *defs ;
  GPtrArray *functions, *expansions, *evaluators, *definitions ;
  GArray *idx ;
  gchar **vars ;
};

typedef struct _BEM3DFunctionClass    BEM3DFunctionClass;

struct _BEM3DFunctionClass {
  /*< private >*/
  GtsObjectClass parent_class;

  /*< public >*/
  /* add extra methods here */
};

typedef struct _BEM3DConfiguration BEM3DConfiguration ;

struct _BEM3DConfiguration {
  GPtrArray               *keys ;
  BEM3DGreensFunction     gfunc ;
  BEM3DQuadratureRuleFunc qrule ;
  BEM3DQuadratureSelector *qdata ;
  GString                 *job ;
  GString                 *gfunc_comment, *qrule_comment ;
} ;

#define BEM3D_FUNCTION(obj)            GTS_OBJECT_CAST (obj,\
					         BEM3DFunction,\
					         bem3d_function_class ())
#define BEM3D_FUNCTION_CLASS(klass)    GTS_OBJECT_CLASS_CAST (klass,\
						 BEM3DFunctionClass,\
						 bem3d_function_class())
#define BEM3D_IS_FUNCTION(obj)         (gts_object_is_from_class (obj,\
						 bem3d_function_class ()))

BEM3DFunctionClass * bem3d_function_class  (void);
  BEM3DFunction * bem3d_function_new    (BEM3DFunctionClass * klass) ;
  gint bem3d_function_add_function(BEM3DFunction *f, gint i, gchar *def) ;

#define bem3d_function_function_number(f)      ((f->functions->len)) 

  /** 
   * @@ingroup belement
   * 
   * @@param e a ::BEM3DElement
   * 
   * @@return the number of GtsFace's on the element \a e
   * @@hideinitializer
   */
#define bem3d_element_face_number(e) (e->nf)

  /** 
   * @@ingroup belement
   * 
   * @@param e a ::BEM3DElement
   * 
   * @@return the number of geometrical vertices on the element \a e
   * @@hideinitializer
   */
#define bem3d_element_vertex_number(e) (e->nv)

  /** 
   * @@ingroup belement
   * 
   * @@param e a ::BEM3DElement
   * 
   * @@return the number of nodes (collocation points) on the element
   * \a e @@hideinitializer
   */
#define bem3d_element_node_number(e) (e->nc)

  /** 
   * @@ingroup belement
   * 
   * @@param e a ::BEM3DElement
   * 
   * @@return the number of corners on the element \a e
   * @@hideinitializer
   */
#define bem3d_element_corner_number(e) (e->ns)

  /** 
   * @@ingroup belement
   * 
   * @@param e a ::BEM3DElement
   * @@param i index of a corner 0 < i < bem3d_element_corner_number(e)
   *
   * @@return the GtsVertex at the \a i th corner of \a e. 
   * @@hideinitializer
   */
#define bem3d_element_corner(e,i) (e->v[e->s[(i)]])

  /** 
   * @@ingroup belement
   * 
   * @@param e a ::BEM3DElement
   * @@param i index of a corner 0 < i < bem3d_element_corner_number(e)
   *
   * @@return the local index of the \a i th corner of \a e.
   * @@hideinitializer
   */
#define bem3d_element_corner_index(e,i) (e->s[(i)])

  /** 
   * @@ingroup belement
   * 
   * @@param e a ::BEM3DElement
   * @@param _i local index of a collocation point
   *
   * @@return the global index of the \a i th collocation point of \a e.
   * @@hideinitializer
   */
#define bem3d_element_global_index(e,_i) (e->i[(_i)])

  /** 
   * @@ingroup belement
   * 
   * @@param e a ::BEM3DElement
   *
   * @@return the geometric ::BEM3DShapeFunc of \a e
   * @@hideinitializer
   */
#define bem3d_element_shape_func(e) (e->shf)

  /** 
   * @@ingroup belement
   * 
   * @@param e a ::BEM3DElement
   *
   * @@return the collocation ::BEM3DShapeFunc of \a e
   * @@hideinitializer
   */
#define bem3d_element_node_func(e) (e->cpf)

  /** 
   * @@ingroup belement
   * 
   * @@param e a ::BEM3DElement
   * @@param i local index of a collocation point on \a e
   *
   * @@return the GtsVertex of the \a i th node (collocation point) of
   * \a e.  @@hideinitializer
   */
#define bem3d_element_node(e,i) (e->c[i]) 

  /** 
   * @@ingroup belement
   * 
   * @@param e a ::BEM3DElement
   * @@param i local index of a node on \a e
   *
   * @@return the local coordinate \f$\xi\f$ of the \a i th node
   * of \a e.
   * @@hideinitializer
   */

#define bem3d_element_node_xi(e,i) ((e)->xc[2*(i)])

  /** 
   * @@ingroup belement
   * 
   * @@param e a ::BEM3DElement
   * @@param i local index of a node on \a e
   *
   * @@return the local coordinate \f$\eta\f$ of the \a i th node
   * of \a e.
   * @@hideinitializer
   */

#define bem3d_element_node_eta(e,i) ((e)->xc[2*(i)+1])

  /** 
   * @@ingroup belement
   * 
   * @@param e a ::BEM3DElement
   * @@param i local index of a geometric point on \a e
   *
   * @@return the GtsVertex of the \a i th geometric point of \a e.
   * @@hideinitializer
   */
#define bem3d_element_vertex(e,i) (e->v[(i)])

  /** 
   * @@ingroup belement
   * 
   * @@param e a ::BEM3DElement
   * @@param i local index of a collocation point on \a e
   *
   * @@return the local coordinate \f$\xi\f$ of the \a i th vertex
   * of \a e.
   * @@hideinitializer
   */

#define bem3d_element_vertex_xi(e,i) ((e)->xs[2*(i)])

  /** 
   * @@ingroup belement
   * 
   * @@param e a ::BEM3DElement
   * @@param i local index of a collocation point on \a e
   *
   * @@return the local coordinate \f$\eta\f$ of the \a i th vertex
   * of \a e.
   * @@hideinitializer
   */

#define bem3d_element_vertex_eta(e,i) ((e)->xs[2*(i)+1])

  /** 
   * @@ingroup belement
   * 
   * @@param e a ::BEM3DElement
   * @@param i local index of a GtsFace on \a e
   *
   * @@return the \a i th GtsFace of \a e.
   * @@hideinitializer
   */
#define bem3d_element_face(e,i) (e->f[(i)])

  /** 
   * @@ingroup belement
   * 
   * @@param e a ::BEM3DElement
   *
   * @@return the order of the moments for element \a e.
   * @@hideinitializer
   */
#define bem3d_element_moment_order(e) ((e)->mo)

  /** 
   * @@ingroup belement
   * 
   * @@param e a ::BEM3DElement
   * @@param m order of \f$x\f$ in multipole moment;
   * @@param n order of \f$y\f$ in multipole moment.
   *
   * @@return \f$I_{mn}\f$ for element \a e.
   * @@hideinitializer
   */
#define bem3d_element_moment(e,m,n)		\
  (g_array_index((e)->Imn,gdouble,(m)))

#define bem3d_element_edge_vertex_number(e) ((e->n))
#define bem3d_element_edge_vertex(e,_i) (e->v[(_i)])
#define bem3d_element_edge_index_upper(e,_i) (e->i[(2*(_i))])
#define bem3d_element_edge_index_lower(e,_i) (e->i[(2*(_i)+1)])
#define bem3d_element_edge_upper(e) (e->e1)
#define bem3d_element_edge_lower(e) (e->e2)

  /** 
   * @@ingroup belement
   * 
   * @@param m a ::BEM3DMEsh
   * @@param el a ::BEM3DElement
   *
   * @@return TRUE if \a el is an element of \a m, FALSE otherwise.
   * @@hideinitializer
   */

#define bem3d_element_has_parent_mesh(m,el)		\
  ((g_hash_table_lookup(((m)->e), (el)) != NULL))

  /* BEM3DElement *bem3d_element_new    (BEM3DElementClass * klass); */
  BEM3DElement *bem3d_element_new(BEM3DElementClass * klass,
				  gint nf, gint nv, gint nc, gint ns,
				  BEM3DShapeFunc shf, BEM3DShapeFunc cpf) ;
  gint bem3d_element_add_vertex(BEM3DElement *e, gpointer v, gint i) ;
  gboolean bem3d_element_point_inside(BEM3DElement *e, gdouble xi, gdouble eta) ;
  gint bem3d_element_gradient_weights(BEM3DElement *e, gdouble xi, gdouble eta,
				      gdouble *w) ;
  gint bem3d_element_add_node(BEM3DElement *e, gpointer v, gint i) ;
  gint bem3d_element_add_face(BEM3DElement *e, gpointer f, gint i) ;
  gint bem3d_element_write(BEM3DElement *e, 
			   GHashTable *v, GHashTable *t,
			   FILE *f) ;
  gint bem3d_element_set_index(BEM3DElement *e, gint i, gint j) ;
  gint bem3d_element_set_corner(BEM3DElement *e, gint i, gint j)  ;
  gint bem3d_element_find_vertex(BEM3DElement *e, GtsVertex *v) ;
  gint bem3d_element_find_face(BEM3DElement *e, GtsFace *f) ;
  gint bem3d_element_find_node(BEM3DElement *e, GtsVertex *v) ;
  gint bem3d_element_find_index(BEM3DElement *e, gint i) ;
  gdouble bem3d_element_area(BEM3DElement *e, gint ngp) ;
  gint bem3d_element_position(BEM3DElement *e, gdouble *L,
			      GtsPoint *q) ;
  gint bem3d_element_normal(BEM3DElement *e, gdouble *dLds, gdouble *dLdt,
			    GtsVector normal, gdouble *J) ;
  gdouble bem3d_element_jacobian(BEM3DElement *e, gdouble *dLds, 
				 gdouble *dLdt) ;
  gint bem3d_element_assemble_equations(BEM3DElement *e, GtsPoint *x,
					BEM3DConfiguration *config,
					BEM3DParameters *gdata,
					GArray *G, GArray *dGdn) ;
  gint bem3d_element_nearest_vertex(BEM3DElement *e, GtsPoint *p,
				    gint *i, gdouble *R) ;
  gint bem3d_element_boundary_nearest_point(BEM3DElement *e, GtsPoint *x,
					    gdouble *xi, gdouble *eta) ;
  gint bem3d_element_edge_nearest_point(BEM3DElement *e, gint i, gint j,
					GtsPoint *x,
					gdouble *xi, gdouble *eta) ;

  GSList *bem3d_elements_common_edges(BEM3DElement *e1, BEM3DElement *e2) ;
  GSList *bem3d_elements_from_vertices(BEM3DMesh *m, GtsVertex *v1, 
				       GtsVertex *v2) ;
  gint bem3d_element_local_vectors(BEM3DElement *e,
				   gdouble dLds[], gdouble dLdt[],
				   GtsVector u1, gdouble *h1,
				   GtsVector u2, gdouble *h2) ;
  gboolean bem3d_element_has_vertex(BEM3DElement *e, GtsVertex *v) ;
  gint bem3d_element_replace_vertex(BEM3DElement *e, GtsVertex *v, 
				    GtsVertex *w) ;
  gint bem3d_element_reset_index(BEM3DMesh *m, BEM3DElement *e, gint i, gint j) ;
  gint bem3d_element_slopes(BEM3DElement *e, gdouble *dLds, gdouble *dLdt,
			    GtsVector dxds, GtsVector dxdt) ;
  gint bem3d_element_nearest_point(BEM3DElement *e, GtsPoint *x,
				   gdouble *xi, gdouble *eta, 
				   gboolean constrain) ;
  GSList *bem3d_element_neighbours(BEM3DElement *el, BEM3DMesh *m) ;
  gint bem3d_element_moments_make(BEM3DElement *e, gint H) ;

  BEM3DElement *bem3d_element_from_node(BEM3DMesh *m, GtsVertex *v, gint i) ;
  gint bem3d_element_index_nodes(BEM3DElement *e, BEM3DMesh *m, gint *n) ;
  gint bem3d_element_vertex_is_corner(BEM3DElement *e, GtsVertex *v) ;

  BEM3DElement *bem3d_element_build_t0(GtsEdge **e, GtsVertex **v) ;
  BEM3DElement *bem3d_element_build_t1(GtsEdge **e, GtsVertex **v) ;
  BEM3DElement *bem3d_element_build_t2(GtsEdge **e, GtsVertex **v) ;
  BEM3DElement *bem3d_element_build_t3(GtsEdge **e, GtsVertex **v) ;
  BEM3DElement *bem3d_element_build_q1(GtsEdge **e, GtsVertex **v) ;
  BEM3DElement *bem3d_element_build_q2(GtsEdge **e, GtsVertex **v) ;

  GSList *bem3d_element_common_nodes(BEM3DElement *e1, BEM3DElement *e2) ;
  GtsBBox *bem3d_element_bounding_box(GtsBBoxClass *klass,
				      BEM3DElement *e) ;

  gint bem3d_greens_func_laplace(GtsPoint *x, GtsPoint *y,
				 GtsVector n, BEM3DParameters *p, 
				 GArray *G, GArray *dGdn) ;
  gint bem3d_greens_func_helmholtz(GtsPoint *x, GtsPoint *y,
				   GtsVector n, BEM3DParameters *p,
				   GArray *G, GArray *dGdn) ;
  gint bem3d_greens_func_helmholtz_hs(GtsPoint *x, GtsPoint *y,
				      GtsVector ny, BEM3DParameters *p,
				      GArray *G, GArray *dGdn) ;
  gint bem3d_greens_func_convected_helmholtz(GtsPoint *x, GtsPoint *y,
					     GtsVector n, BEM3DParameters *p,
					     GArray *G, GArray *dGdn) ;
  gint bem3d_greens_func_gradient_laplace(GtsPoint *x, GtsPoint *y,
					  GtsVector n, BEM3DParameters *p,
					  GArray *G, GArray *dGdn) ;
  BEM3DParameters *bem3d_parameters_new(void) ;

  gint bem3d_radiation_func_laplace(GArray *G, GArray *dG,
				    GArray *phi, GArray *dphi,
				    GArray *f, gpointer data) ;
  gint bem3d_radiation_func_helmholtz(GArray *G, GArray *dG,
				      GArray *phi, GArray *dphi,
				      GArray *f, gpointer data) ;
  gint bem3d_mesh_radiation_point(BEM3DMesh *m,
				  /* BEM3DGreensFunction *gf,  */
				  BEM3DConfiguration *config,
				  BEM3DParameters *gdata,
				  /* BEM3DQuadratureRuleFunc qf, gpointer qdata, */
				  BEM3DLookupFunc lf, gpointer ldata,
/* 				  BEM3DRadiationFunc rf, gpointer rdata, */
				  GtsPoint *x, GArray *f) ;
  gint bem3d_element_radiation_point(BEM3DElement *e, 
				     BEM3DConfiguration *config,
				     BEM3DParameters *gdata,	     
/* 				     BEM3DQuadratureRuleFunc qfunc,  */
/* 				     gpointer qdata, */
				     BEM3DLookupFunc lfunc, gpointer ldata,
				     GtsPoint *x, 
				     GArray *G, GArray *dGdn,
				     GArray *phi, GArray *dphi) ;
  gint bem3d_mesh_radiation_mesh(BEM3DMesh *m,
				 /* BEM3DGreensFunction *gf, */
				 BEM3DConfiguration *config,
				 BEM3DParameters *gdata,
				 /* BEM3DQuadratureRuleFunc qf, gpointer qdata, */
				 BEM3DLookupFunc lf, gpointer ldata,
				 BEM3DMesh *s, BEM3DMeshData *f) ;

  GtsVertex *bem3d_mesh_node_from_index(BEM3DMesh *m, gint i) ;
  gint bem3d_mesh_index_from_node(BEM3DMesh *m, GtsVertex *v) ;
  gint bem3d_mesh_write(BEM3DMesh *m, FILE *fptr) ;
  guint bem3d_mesh_read(BEM3DMesh *m, GtsFile *f) ;
  guint bem3d_gmsh_read(BEM3DMesh *m, FILE *f) ;
  gint bem3d_mesh_add_element(BEM3DMesh *m, BEM3DElement *e, gboolean force) ;
  gint bem3d_mesh_remove_element(BEM3DMesh *m, BEM3DElement *e) ;
  GSList *bem3d_mesh_vertex_elements(BEM3DMesh *m, GtsVertex *v) ;
  GSList *bem3d_mesh_node_elements(BEM3DMesh *m, gint i) ;
  gint bem3d_mesh_index_nodes(BEM3DMesh *m, gdouble angle, gint n) ;
  gint bem3d_mesh_node_number(BEM3DMesh *m) ;
  gint bem3d_mesh_discretize(GtsSurface *s, gint nne,
			     BEM3DElementBuildFunc bfunc,
			     BEM3DMesh *m) ;
gint bem3d_mesh_assemble_equations(BEM3DMesh *m, BEM3DMesh *n,
				   BEM3DConfiguration *config,
				   BEM3DParameters *gdata,
				   BEM3DEquationFunc efunc, gpointer edata) ;
  /* gint bem3d_mesh_assemble_equations(BEM3DMesh *m, BEM3DMesh *n, */
  /* 				     BEM3DGreensFunction *gf,  */
  /* 				     BEM3DParameters *gdata, */
  /* 				     BEM3DEquationFunc ef, gpointer edata, */
  /* 				     BEM3DQuadratureRuleFunc qf,  */
  /* 				     gpointer qdata) ; */
  gint bem3d_equation_func_simple(gint i, gint j,
				  gdouble *G, gdouble *dGdn, gint n,
				  gpointer *e) ;
  gint bem3d_mesh_write_nodes(BEM3DMesh *m, FILE *f) ;
  gint bem3d_mesh_foreach_element(BEM3DMesh *m, BEM3DElementFunc f, 
				  gpointer data) ;
  gint bem3d_mesh_foreach_node(BEM3DMesh *m, BEM3DNodeFunc f, gpointer data) ;
  gint bem3d_mesh_element_clear_reserved(BEM3DMesh *m) ;
  gint bem3d_mesh_set_bc(BEM3DMesh *m, BEM3DBCFunc bcf, gpointer bdata) ;
gint bem3d_mesh_quad_dgdn(BEM3DMesh *m,
			  BEM3DConfiguration *config,
			  /* BEM3DGreensFunction *gfunc,  */
			  BEM3DParameters *gdata,
			  /* BEM3DQuadratureRuleFunc qfunc, gpointer qdata, */
			  BEM3DLookupFunc lfunc, gpointer ldata,
			  BEM3DEquationFunc efunc, gpointer edata) ;
  /* gint bem3d_mesh_quad_dgdn(BEM3DMesh *m, */
  /* 			    BEM3DGreensFunction *gfunc,  */
  /* 			    BEM3DParameters *gdata, */
  /* 			    BEM3DQuadratureRuleFunc qfunc, gpointer qdata, */
  /* 			    BEM3DLookupFunc lfunc, gpointer ldata, */
  /* 			    BEM3DEquationFunc efunc, gpointer edata) ; */
  gint bem3d_mesh_merge(BEM3DMesh *m, BEM3DMesh *n) ;
  gint bem3d_mesh_element_moments(BEM3DMesh *m, gint H) ;

  BEM3DElement *bem3d_mesh_face_element(BEM3DMesh *m, GtsFace *f) ;

  /**
   * The number of elements (numerical entries) per node in a ::BEM3DMeshData.
   * @@hideinitializer
   */

#define bem3d_mesh_data_element_number(m) ((m)->nd)

/*   /\** */
/*    * The number of nodes in a ::BEM3DMeshData. */
/*    * @@hideinitializer */
/*    *\/ */

/* #define bem3d_mesh_data_node_number(m) ((m)->nc) */

  gint bem3d_mesh_data_multiproc_sum(BEM3DMeshData *m) ;
  BEM3DMeshData *bem3d_mesh_data_new(BEM3DMesh *m, gint n) ;
  gint bem3d_mesh_data_expand(BEM3DMeshData *d, gint ne) ;
  gint bem3d_mesh_data_free(BEM3DMeshData *d) ;
  BEM3DMeshData *bem3d_mesh_data_sized_new(gint n, gint m) ;
  gint bem3d_mesh_data_add_node(BEM3DMeshData *m, gint i) ;
  gdouble *bem3d_mesh_data_get(BEM3DMeshData *m, gint i) ;
  gint bem3d_mesh_data_node_number(BEM3DMeshData *d) ;
/*   gint bem3d_mesh_function_eval(BEM3DMesh *m,  */
/* 				BEM3DMeshDataFunc f, */
/* 				gpointer fdata,  */
/* 				BEM3DMeshData *d) ; */
  gint bem3d_mesh_function_limits(BEM3DMeshData *f, gint i,
				  gdouble *xmin, gdouble *xmax) ;
  gint bem3d_mesh_data_clear(BEM3DMeshData *m) ;
  gint bem3d_mesh_data_add(BEM3DMeshData *f, gint i, GArray *g) ;

  BEM3DQuadratureSelector *bem3d_quadrature_selector_new(void) ;
  gint bem3d_quadrature_selector_add(BEM3DQuadratureSelector *s,
				     BEM3DQuadratureRuleFunc f,
				     gdouble p, gint N, gint M) ;
  BEM3DQuadratureSelector *bem3d_quadrature_selector_default(void) ;
  BEM3DQuadratureSelector *bem3d_quadrature_selector_hypersingular_default(void) ;
  gint bem3d_quadrature_selector_clear(BEM3DQuadratureSelector *s) ;
  gint bem3d_quadrature_select(BEM3DQuadratureSelector *s,
			       gdouble p,
			       BEM3DQuadratureRuleFunc *f,
			       gpointer *data) ;

  gint bem3d_shfunc_t0(gdouble s, gdouble t, 
		       gdouble *L, gdouble *dLds,
		       gdouble *dLdt, gpointer data) ;
  gint bem3d_shfunc_t1(gdouble s, gdouble t, 
		       gdouble *L, gdouble *dLds,
		       gdouble *dLdt, gpointer data) ;
  gint bem3d_shfunc_t2(gdouble s, gdouble t, 
		       gdouble *L, gdouble *dLds,
		       gdouble *dLdt, gpointer data) ;
  gint bem3d_shfunc_t3(gdouble s, gdouble t, 
		       gdouble *L, gdouble *dLds,
		       gdouble *dLdt, gpointer data) ;
  gint bem3d_shfunc_q1(gdouble s, gdouble t, 
		       gdouble *L, gdouble *dLds,
		       gdouble *dLdt, gpointer data) ;
  gint bem3d_shfunc_q2(gdouble s, gdouble t, 
		       gdouble *L, gdouble *dLds,
		       gdouble *dLdt, gpointer data) ;

  gint bem3d_shapefunc_lookup_init(void) ;
  gint bem3d_shapefunc_lookup_add(BEM3DShapeFunc func, gchar *name) ;
  BEM3DShapeFunc bem3d_shapefunc_lookup_func(const gchar *name) ;
  const gchar *bem3d_shapefunc_lookup_name(BEM3DShapeFunc func) ;

  gboolean bem3d_edge_is_sharp(GtsEdge *e, gdouble angle) ;
  GSList *bem3d_edges_local(GtsVertex *v, GtsSurface *s) ;

  gint bem3d_lookup_func_unit(gint i, gint j, 
			      gpointer data,
			      GArray *s, GArray *ds) ;

  gint bem3d_lookup_func_unit_c(gint i, gint j, 
				gpointer data,
				GArray *s, GArray *ds) ;
  gint bem3d_lookup_func_both_unit(gint i, gint j, 
				   gpointer data,
				   GArray *s, GArray *ds) ;

  gint bem3d_area_coordinates_tri(GtsPoint *t1,
				  GtsPoint *t2,
				  GtsPoint *t3,
				  GtsPoint *x,
				  GtsVector xi) ;

  gint bem3d_logging_init(FILE *f, gchar *p, 
			  GLogLevelFlags log_level,
			  gpointer exit_func) ;

#define bem3d_quadrature_clear(q) ((q)->n=(q)->nfree=0) 
#define bem3d_quadrature_vertex_number(q) ((q)->n)
#define bem3d_quadrature_vertex_number_max(q) ((q)->nmax)
#define bem3d_quadrature_component_number(q) ((q)->nc)
/* #define bem3d_quadrature_xi(q,i) ((q)->s[(i)]) */
/* #define bem3d_quadrature_eta(q,i) ((q)->t[(i)]) */
/* #define bem3d_quadrature_weight(q,i) ((q)->w[(i)]) */
#define bem3d_quadrature_xi(q,_i) ((q)->rule[(3*(_i)+0)])
#define bem3d_quadrature_eta(q,_i) ((q)->rule[(3*(_i)+1)])
#define bem3d_quadrature_weight(q,_i) ((q)->rule[(3*(_i)+2)])

#define bem3d_quadrature_free_number(q) ((q)->nfree)
#define bem3d_quadrature_free_term_g(q,i) ((q)->free_g[(q)->wfree*(i)])
#define bem3d_quadrature_free_term_dg(q,i) ((q)->free_dg[(q)->wfree*(i)])

  BEM3DQuadratureRule *bem3d_quadrature_rule_new(gint n, gint nc) ;
  gint bem3d_quadrature_rule_free(BEM3DQuadratureRule *q) ;
  gdouble bem3d_quadrature_rule_sum_weights(BEM3DQuadratureRule *q) ;
  gint bem3d_quadrature_rule_write(BEM3DQuadratureRule *q, FILE *f) ;
  gint bem3d_quadrature_rule_realloc(BEM3DQuadratureRule *q, gint n) ;
  gint bem3d_quadrature_add_point(BEM3DQuadratureRule *q,
				  gdouble xi, gdouble eta,
				  gdouble w) ;
  gint bem3d_quadrature_rule_gauss(GtsPoint *p, BEM3DElement *e,
				   BEM3DQuadratureRule *q, 
				   BEM3DGreensFunction *gfunc, 
				   BEM3DParameters *param,
				   gpointer n) ;
  gint bem3d_quadrature_rule_default(GtsPoint *p,
				     BEM3DElement *e,
				     BEM3DQuadratureRule *q,
				     BEM3DGreensFunction *gfunc, 
				     BEM3DParameters *param,
				     gpointer data) ;
  gint bem3d_quadrature_rule_kw(GtsPoint *p, BEM3DElement *e,
				BEM3DQuadratureRule *q, 
				BEM3DGreensFunction *gfunc, 
				BEM3DParameters *param,
				gpointer data) ;
  gint bem3d_quadrature_rule_polar(GtsPoint *p, BEM3DElement *e,
				   BEM3DQuadratureRule *q, 
				   BEM3DGreensFunction *gfunc, 
				   BEM3DParameters *param,
				   gpointer data) ;
  gint bem3d_quadrature_rule_polar_hs(GtsPoint *p, BEM3DElement *e,
				      BEM3DQuadratureRule *q, 
				      BEM3DGreensFunction *gfunc, 
				      BEM3DParameters *param,
				      gpointer data) ;
  gint bem3d_quadrature_rule_hayami(GtsPoint *xs, BEM3DElement *e,
				    BEM3DQuadratureRule *q, 
				    BEM3DGreensFunction *gfunc, 
				    BEM3DParameters *param,
				    gpointer data) ;
  gint bem3d_quadrature_rule_rnvr(GtsPoint *p, BEM3DElement *e,
				  BEM3DQuadratureRule *q, 
				  BEM3DGreensFunction *gfunc, 
				  BEM3DParameters *param,
				  gpointer data) ;
  gint bem3d_quadrature_rule_wx(GtsPoint *p, BEM3DElement *e,
				BEM3DQuadratureRule *q, 
				BEM3DGreensFunction *gfunc, 
				BEM3DParameters *param,
				gpointer data) ;
  gint bem3d_quadrature_rule_newman(GtsPoint *xs, BEM3DElement *e,
				    BEM3DQuadratureRule *q, 
				    BEM3DGreensFunction *gfunc, 
				    BEM3DParameters *param,
				    gpointer data) ;
  gint bem3d_quadrature_rule_newman_gradient(GtsPoint *xs, BEM3DElement *e,
					     BEM3DQuadratureRule *q, 
					     BEM3DGreensFunction *gfunc, 
					     BEM3DParameters *param,
					     gpointer data) ;

gint bem3d_quadrature_rule_decomp(GtsPoint *xs, BEM3DElement *e,
				  BEM3DQuadratureRule *q, 
				  BEM3DGreensFunction *gfunc,
				  BEM3DParameters *param,
				  gpointer data) ;
gint bem3d_quadrature_rule_decomp_gradient(GtsPoint *xs, BEM3DElement *e,
					   BEM3DQuadratureRule *q, 
					   BEM3DGreensFunction *gfunc,
					   BEM3DParameters *param,
					   gpointer data) ;
  gdouble bem3d_quadrature_parameter(GtsPoint *p, BEM3DElement *e) ;
  gint bem3d_quadrature_rule_remap(gdouble xi0, gdouble eta0,
				   gdouble xi1, gdouble eta1,
				   gdouble xi2, gdouble eta2,
				   gdouble s, gdouble t, gdouble w,
				   gdouble *sn, gdouble *tn,
				   gdouble *wn) ;

  gint bem3d_geometry_plane(GtsSurface *s, gint ni, gint nj) ;
  GtsVertex *bem3d_vertex_from_segments(GtsSegment *s1, GtsSegment *s2) ;
  gint bem3d_mesh_data_write(BEM3DMeshData *f, FILE *fp) ;
  gint bem3d_mesh_data_read(BEM3DMeshData **f, FILE *fp) ;
  gint bem3d_mesh_write_gmsh(BEM3DMesh *m, BEM3DMeshData *f, gint k,
			     gchar *view, bem3d_gmsh_mode_t mode,
			     FILE *fp) ;
  gint bem3d_gmsh_write_element(BEM3DElement *e, BEM3DMeshData *f,
				gint nv, 
				gint *indices_g, gint *indices_d,
				gchar *ename,
				gint k, gint nf, FILE *fp) ;
  gint bem3d_edge_write_pos(BEM3DEdge *edge, gchar *view, FILE *f) ;

  GSList *bem3d_mesh_index_sharp_edges(BEM3DMesh *m, gdouble angle, 
				       gint *n) ;

  gint bem3d_matrix_vector_mul(BEM3DMatrix m, GtsVector v, GtsVector w) ;
  gdouble bem3d_matrix_det(BEM3DMatrix m) ;
  gint bem3d_matrix_inverse(BEM3DMatrix m, BEM3DMatrix im) ;

  BEM3DOperator *bem3d_operator_new(void) ;
  gint bem3d_operator_gradient(BEM3DMesh *m, gint i, BEM3DOperator *op,
			       BEM3DAverage mode) ;
  gint bem3d_node_normal(BEM3DMesh *m, gint i, GtsVector n, 
			 BEM3DAverage mode) ;


#define bem3d_edge_node_number(edge)  ((edge->i->len)/2)
#define bem3d_edge_element_number(edge)  ((edge->e->len)/2)
#define bem3d_edge_node_index_upper(edge,j)  \
  ((g_array_index(edge->i,gint,2*(j)+0)))
#define bem3d_edge_node_index_lower(edge,j)  \
  ((g_array_index(edge->i,gint,2*(j)+1)))
#define bem3d_edge_element_upper(edge,j)  \
  ((g_ptr_array_index(edge->e,2*(j)+0)))
#define bem3d_edge_element_lower(edge,j)  \
  ((g_ptr_array_index(edge->e,2*(j)+1)))
#define bem3d_edge_vertex(edge,j)  ((g_ptr_array_index(edge->v,(j))))
#define bem3d_edge_mesh(edge)      (edge)->m

BEM3DEdgeClass * bem3d_edge_class  (void) ;
BEM3DEdge * bem3d_edge_new    (BEM3DEdgeClass * klass) ;

gint bem3d_mesh_vertex_index_number(BEM3DMesh *m, GtsVertex *v) ;
GSList *bem3d_mesh_sharp_vertices(BEM3DMesh *m) ;
gint bem3d_edge_add_node(BEM3DEdge *e, GtsVertex *v, gint i, gint j) ;
gint bem3d_edge_add_elements(BEM3DEdge *e, 
			     BEM3DElement *e1, BEM3DElement *e2) ;
GSList *bem3d_mesh_extract_edges(BEM3DMesh *m, GSList **e) ;
gint bem3d_edge_clear(BEM3DEdge *e) ;
  gint bem3d_edge_copy(BEM3DEdge *e, BEM3DEdge *f) ;
gint bem3d_link_edges(BEM3DMesh *m, BEM3DEdge *e1, BEM3DEdge *e2,
		      BEM3DElementBuildFunc build, gint nv, 
		      gint nc, gint *idx) ;
  gint bem3d_edge_write(BEM3DEdge *e, FILE *f) ;
  guint bem3d_edge_read(BEM3DEdge *e, GtsFile *f) ;
  gint bem3d_edge_link_to_mesh(BEM3DEdge *e, BEM3DMesh *m) ;
  gboolean bem3d_edge_is_oriented(BEM3DEdge *e, BEM3DMesh *m) ;
  gint bem3d_invert_edge(BEM3DEdge *e) ;

BEM3DMotionClass * bem3d_motion_class  (void);
BEM3DMotion * bem3d_motion_new    (BEM3DMotionClass * klass,
				   BEM3DMesh *m, BEM3DMesh *m0);

gint bem3d_motion_variable_add(BEM3DMotion *m, gchar *var, gchar *def) ;
gint bem3d_motion_write(BEM3DMotion *m, FILE *f) ;
gint bem3d_motion_expand_defs(BEM3DMotion *m) ;
gint bem3d_motion_write_expansions(BEM3DMotion *m, FILE *f) ;
gchar *bem3d_motion_variable_lookup(BEM3DMotion *m, gchar *var) ;
gint bem3d_motion_mesh_position(BEM3DMotion *m, gdouble t) ;
gint bem3d_motion_create_evaluators(BEM3DMotion *m) ;
gint bem3d_motion_free_evaluators(BEM3DMotion *m) ;
gboolean bem3d_motion_token_is_reserved(gchar *token) ;
guint bem3d_motion_read(BEM3DMotion *m, GtsFile *f) ;
gint bem3d_motion_node_velocity(BEM3DMotion *m, gint i, gdouble t,
				GtsVector u) ;
gint bem3d_motion_node_acceleration(BEM3DMotion *m, gint i, gdouble t,
				    GtsVector a) ;


  gint bem3d_function_variable_add(BEM3DFunction *f, gchar *var, gchar *def) ;
  gint bem3d_function_expand_functions(BEM3DFunction *f) ;
  gchar *bem3d_function_variable_lookup(BEM3DFunction *f, gchar *var) ;
  gint bem3d_function_apply(BEM3DFunction *f, 
			    BEM3DMotion *m,
			    gdouble t,
			    BEM3DMeshData *d) ;
  gboolean bem3d_function_token_is_reserved(gchar *var) ;
  gint bem3d_function_write(BEM3DFunction *f, FILE *fid) ; 
  gint bem3d_function_read(BEM3DFunction *f, GtsFile *fid) ;

  BEM3DConfiguration *bem3d_configuration_new(void) ;
  gint bem3d_configuration_init(void) ;
  gint bem3d_configuration_read(BEM3DConfiguration *c, gchar *file) ;
  gint bem3d_configuration_add_identifier(const gchar *id, gpointer v) ;
  gchar *bem3d_configuration_identifier_from_pointer(gpointer v) ;
  gpointer bem3d_configuration_pointer_from_identifier(const gchar *id) ;  
  gint bem3d_configuration_set(BEM3DConfiguration *c, gpointer k)  ;

#ifdef BEM3D_HAVE_GMC  
  typedef struct _BEM3DFMMMatrix BEM3DFMMMatrix ;

  struct _BEM3DFMMMatrix {
    GNode *tree ;
/*     GArray *E ; */
    gdouble *e ;
    gint nd ;
    BEM3DMesh *m ;
    BEM3DConfiguration *config ;
    /* BEM3DGreensFunction *gfunc ; */
    BEM3DParameters *gdata ;
    BEM3DLookupFunc lfunc ;
    gpointer ldata ;
    gint H, L, nc, rows, cols ;
    GmcFieldType field ;
    GmcEvaluationMode mode ;
    GmcNearFieldMatrix *nf ;
    gpointer data ;
    gboolean near_field_integrate, near_field_use_matrix ;
    /*workspace and internally-set data*/
    GmcElementFieldFunc efunc ;
    GArray *g, *dg, *phi, *dphi ;
  } ;

#define BEM3D_FMM_MATRIX(fmm)                  ((BEM3DFMMMatrix *)(fmm))
#define bem3d_fmm_matrix_user_data(fmm)        ((fmm)->data)
#define bem3d_fmm_matrix_tree(fmm)             ((fmm)->tree) 
#define bem3d_fmm_matrix_diagonal(fmm)         ((fmm)->e)
#define bem3d_fmm_matrix_greens_func(fmm)      ((fmm)->gfunc)
#define bem3d_fmm_matrix_configuration(fmm)      ((fmm)->config)
#define bem3d_fmm_matrix_parameters(fmm)       ((fmm)->gdata)
#define bem3d_fmm_matrix_lookup_func(fmm)      ((fmm)->lfunc)
#define bem3d_fmm_matrix_lookup_data(fmm)      ((fmm)->ldata)
#define bem3d_fmm_matrix_mesh(fmm)             ((fmm)->m)
#define bem3d_fmm_matrix_multipole_order(fmm)  ((fmm)->H)
#define bem3d_fmm_matrix_expansion_order(fmm)  ((fmm)->L)
#define bem3d_fmm_matrix_component_number(fmm) ((fmm)->nc)
#define bem3d_fmm_matrix_field_type(fmm)       ((fmm)->field)
#define bem3d_fmm_matrix_field_mode(fmm)       ((fmm)->mode)
#define bem3d_fmm_matrix_near_field(fmm)       ((fmm)->nf)
#define bem3d_fmm_matrix_row_number(fmm)       ((fmm)->rows)
#define bem3d_fmm_matrix_column_number(fmm)    ((fmm)->cols)
#define bem3d_fmm_matrix_near_field_integrate(fmm)	\
  ((fmm)->near_field_integrate)
#define bem3d_fmm_matrix_near_field_use_matrix(fmm)	\
  ((fmm)->near_field_use_matrix)

  GNode *bem3d_mesh_oct_tree(GmcOctTreeBoxClass *klass, 
			     BEM3DMesh *m, gint nc, gint stride, gint nbmax) ;
  gint bem3d_element_hash(BEM3DElement *e, GmcOctTreeBox *b, gint *nv) ;
  BEM3DFMMMatrix *bem3d_fmm_matrix_new(GmcOctTreeBoxClass *klass,
				       BEM3DMesh *m, 
				       BEM3DLookupFunc lfunc,
				       BEM3DConfiguration *config, 
				       /* BEM3DGreensFunction *gfunc,  */
				       BEM3DParameters *gdata,
				       gint nc,
				       gint nbmax, 
				       gint Hmin, gint Hmax,
				       gint Lmin, gint Lmax,
				       GmcFieldType field,
				       GmcEvaluationMode mode) ;
  gint bem3d_fmm_matrix_multiply(BEM3DFMMMatrix *f,
				 gpointer ldata,
				 GmcLookupFunc xlfunc,
				 gpointer xdata,
				 GmcLookupFunc ylfunc,
				 gpointer ydata) ;

gint bem3d_mesh_radiation_mesh_amm(GNode *tree, 
				   BEM3DConfiguration *config,
				   BEM3DParameters *gdata,
				   BEM3DLookupFunc lfunc,
				   gpointer ldata,
				   GmcFieldType field,
				   BEM3DMesh *s, BEM3DMeshData *f) ;

/*   gint bem3d_mesh_radiation_mesh_amm(GNode *tree,  */
/* 				     BEM3DGreensFunction *gfunc, */
/* 				     BEM3DParameters *gdata, */
/* 				     BEM3DQuadratureRuleFunc qfunc,  */
/* 				     gpointer qdata, */
/* 				     BEM3DLookupFunc lfunc, */
/* 				     gpointer ldata, */
/* 				     GmcFieldType field, */
/* 				     BEM3DMesh *s, BEM3DMeshData *f) ; */

  gint bem3d_mesh_radiation_point_amm(GNode *tree, 
				      BEM3DConfiguration *config,
				      BEM3DParameters *gdata,
				      BEM3DLookupFunc lfunc,
				      gpointer ldata,
				      GmcFieldType field,
				      GtsPoint *p, GArray *f) ;
  
#else
  typedef struct _BEM3DFMMMatrix BEM3DFMMMatrix ;

  struct _BEM3DFMMMatrix {
    gpointer data ;
  } ;

  GNode *bem3d_mesh_oct_tree(gpointer klass, BEM3DMesh *m, gint nc,
			     gint stride, gint nbmax) ;
  gint bem3d_element_hash(BEM3DElement *e, gpointer b, gint *nv) ;
  BEM3DFMMMatrix *bem3d_fmm_matrix_new(gpointer klass,
				       BEM3DMesh *m,
				       BEM3DLookupFunc lfunc,
				       BEM3DGreensFunction *gfunc, 
				       BEM3DParameters *gdata,
				       gint nc,
				       gint nbmax, 
				       gint Hmin, gint Hmax,
				       gint Lmin, gint Lmax,
				       gint field,
				       gint mode) ;

  gint bem3d_mesh_radiation_mesh_amm(GNode *tree, 
				     BEM3DGreensFunction *gfunc,
				     BEM3DParameters *gdata,
				     BEM3DQuadratureRuleFunc qfunc, 
				     gpointer qdata,
				     BEM3DLookupFunc lfunc,
				     gpointer ldata,
				     gint field,
				     BEM3DMesh *s, BEM3DMeshData *f) ;

  gint bem3d_mesh_radiation_point_amm(GNode *tree, 
				      BEM3DGreensFunction *gfunc,
				      BEM3DParameters *gdata,
				      BEM3DQuadratureRuleFunc qfunc, 
				      gpointer qdata,
				      BEM3DLookupFunc lfunc,
				      gpointer ldata,
				      gint field,
				      GtsPoint *p, GArray *f) ;
#endif /*BEM3D_HAVE_GMC*/

  gint bem3d_fmm_matrix_free(BEM3DFMMMatrix *f) ;
  gint bem3d_fmm_matrix_write(BEM3DFMMMatrix *m, FILE *f) ;
  BEM3DFMMMatrix *bem3d_fmm_matrix_read(GtsFile *f) ;

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /*BEM3D_H_INCLUDED*/
@


1.3
log
@*** empty log message ***
@
text
@d1 19
d41 1
a41 1
#define BEM3D_QUADRATURE_CACHING 1
d63 2
a64 1
    BEM3D_BLOCK_FULL = 7	/**< a ::BEM3DMeshData was full */
d81 1
d158 6
d298 2
a299 1
   * containing the nodes and weights normalized to a unit simplex.
d303 2
a304 2
    gint nmax, n, nfree, nfree_max, wfree ;
    gdouble *s, *t, *w ;
d381 1
a381 1
    gint nd, nc, ncmax ; 
d383 1
a383 1
    gdouble *data ;
a385 18
  /**
   * @@struct BEM3DQuadratureRuleFunc
   * @@ingroup Quadrature 
   * gint BEM3DQuadratureRuleFunc(GtsPoint *p, BEM3DElement *e,
   * BEM3DQuadratureRule *q, gpointer data) ;
   *
   * Function for generating quadrature rules
   * 
   * @@param p field point for integration
   * @@param e element over which to integrate
   * @@param q quadrature rule to hold points
   * @@param data user data to pass to function
   * 
   * @@return 0 on success
   */

  typedef gint (*BEM3DQuadratureRuleFunc)(GtsPoint *p, BEM3DElement *e,
					  BEM3DQuadratureRule *q, gpointer data) ;
d406 2
a407 2
    gdouble f[16] ;
    gint    n[16] ;
d430 1
a430 1
   * BEM3DParameters *p, GArray *G, GArray *dGdn) ;
d449 49
d523 2
a524 1
   * @@ingroup gfunc Real part of amplitude in a ::BEM3DParameters
d529 1
a529 1
   * &(bem3d_parameters_amplitude_real(p)) @@endverbatim   
d555 59
d627 25
d674 2
a675 6
    gint 
    nmax,				
      n ;				
    BEM3DQuadratureRuleFunc *f ;	
    gdouble *p ;			
    gpointer *data ;		
d678 51
a827 24
   * @@struct BEM3DRadiationFunc
   *
   * Compute radiated quantities given the integrated Green's function
   * and derivative over an element and the solution at the element
   * nodes. In principle, the solution is the sum of 
   * \f$g{\partial\phi}/{\partial n}-\phi \partial g/\partial n\f$ 
   * over the elements.
   * 
   * @@param g GArray of integrated Green's function on element
   * @@param dgdn GArray of integrated Green's function normal derivative 
   * on element
   * @@param phi GArray of solution at element nodes
   * @@param dphi GArray of solution normal derivative at nodes
   * @@param f GArray of radiated field
   * @@param data user data to pass to function
   *
   * @@return 0 on success 
   */

  typedef gint (*BEM3DRadiationFunc)(GArray *g, GArray *dgdn,
				     GArray *phi, GArray *dphi,
				     GArray *f, gpointer data) ;

  /**
d836 103
d1188 1
a1188 1
					BEM3DGreensFunc gfunc, 
a1189 2
					BEM3DQuadratureRuleFunc qfunc,
					gpointer qdata,
d1191 2
a1192 2
  gint bem3d_element_nearest(BEM3DElement *e, GtsPoint *p,
			     gint *i, gdouble *R) ;
d1200 2
d1239 3
d1248 1
d1257 2
a1258 1
				  BEM3DGreensFunc gf, 
d1260 1
a1260 1
				  BEM3DQuadratureRuleFunc qf, gpointer qdata,
d1262 1
a1262 1
				  BEM3DRadiationFunc rf, gpointer rdata,
d1265 1
a1265 1
				     BEM3DGreensFunc gfunc, 
d1267 2
a1268 2
				     BEM3DQuadratureRuleFunc qfunc, 
				     gpointer qdata,
d1274 2
a1275 1
				 BEM3DGreensFunc gf,
d1277 1
a1277 1
				 BEM3DQuadratureRuleFunc qf, gpointer qdata,
a1278 1
				 BEM3DRadiationFunc rf, gpointer rdata,
d1286 1
a1286 1
  gint bem3d_mesh_add_element(BEM3DMesh *m, BEM3DElement *e) ;
d1295 10
a1304 6
  gint bem3d_mesh_assemble_equations(BEM3DMesh *m, BEM3DMesh *n,
				     BEM3DGreensFunc gf, 
				     BEM3DParameters *gdata,
				     BEM3DEquationFunc ef, gpointer edata,
				     BEM3DQuadratureRuleFunc qf, 
				     gpointer qdata) ;
d1314 13
a1326 7
  gint bem3d_mesh_quad_dgdn(BEM3DMesh *m,
			    BEM3DGreensFunc gfunc, 
			    BEM3DParameters *gdata,
			    BEM3DQuadratureRuleFunc qfunc, gpointer qdata,
			    BEM3DLookupFunc lfunc, gpointer ldata,
			    BEM3DRadiationFunc rfunc, gpointer rdata,
			    BEM3DEquationFunc efunc, gpointer edata) ;
d1348 1
d1354 4
a1357 4
  gint bem3d_mesh_function_eval(BEM3DMesh *m, 
				BEM3DMeshDataFunc f,
				gpointer fdata, 
				BEM3DMeshData *d) ;
d1363 1
a1363 1
  BEM3DQuadratureSelector *bem3d_quadrature_selector_new(gint n) ;
d1366 1
a1366 1
				     gdouble p, gpointer data) ;
a1374 4
#define bem3d_quadrature_selector_func(s,i) (s->f[(i)])
#define bem3d_quadrature_selector_sigma(s,i) (s->p[(i)])
#define bem3d_quadrature_selector_data(s,i) (s->data[(i)])

d1426 8
a1433 3
#define bem3d_quadrature_xi(q,i) ((q)->s[(i)])
#define bem3d_quadrature_eta(q,i) ((q)->t[(i)])
#define bem3d_quadrature_weight(q,i) ((q)->w[(i)])
d1438 1
a1438 1
  BEM3DQuadratureRule *bem3d_quadrature_rule_new(gint n) ;
d1447 4
a1450 1
				   BEM3DQuadratureRule *q, gpointer n) ;
d1454 2
d1458 4
a1461 1
				BEM3DQuadratureRule *q, gpointer data) ;
d1463 4
a1466 1
				   BEM3DQuadratureRule *q, gpointer data) ;
d1468 4
a1471 1
				      BEM3DQuadratureRule *q, gpointer data) ;
d1473 4
a1476 1
				    BEM3DQuadratureRule *q, gpointer data) ;
d1478 4
a1481 1
				  BEM3DQuadratureRule *q, gpointer data) ;
d1483 4
a1486 1
				BEM3DQuadratureRule *q, gpointer data) ;
d1488 21
a1508 4
				    BEM3DQuadratureRule *q, gpointer data) ;

  gint bem3d_quadrature_parameter(GtsPoint *p, BEM3DElement *e,
				  gdouble *sigma) ;
d1528 2
d1544 72
d1621 3
a1623 1
    GArray *E ;
d1625 2
a1626 1
    BEM3DGreensFunc gfunc ;
d1630 1
a1630 1
    gint H, L, nc ;
d1644 1
a1644 1
#define bem3d_fmm_matrix_diagonal(fmm)         ((fmm)->E)
d1646 1
d1657 2
d1665 1
a1665 1
			     BEM3DMesh *m, gint nbmax) ;
d1670 2
a1671 1
				       BEM3DGreensFunc gfunc, 
d1686 17
a1702 9
  gint bem3d_mesh_radiation_mesh_amm(GNode *tree, 
				     BEM3DGreensFunc gfunc,
				     BEM3DParameters *gdata,
				     BEM3DQuadratureRuleFunc qfunc, 
				     gpointer qdata,
				     BEM3DLookupFunc lfunc,
				     gpointer ldata,
				     GmcFieldType field,
				     BEM3DMesh *s, BEM3DMeshData *f) ;
d1705 1
a1705 1
				      BEM3DGreensFunc gfunc,
a1706 2
				      BEM3DQuadratureRuleFunc qfunc, 
				      gpointer qdata,
d1719 2
a1720 1
  GNode *bem3d_mesh_oct_tree(gpointer klass, BEM3DMesh *m, gint nbmax) ;
d1725 1
a1725 1
				       BEM3DGreensFunc gfunc, 
d1735 1
a1735 1
				     BEM3DGreensFunc gfunc,
d1745 1
a1745 1
				      BEM3DGreensFunc gfunc,
d1756 2
@


1.2
log
@*** empty log message ***
@
text
@d12 6
d25 7
d33 12
a44 5
    BEM3D_FAILURE = -1,
    BEM3D_SUCCESS = 0,
    BEM3D_EINVAL = 1,
    BEM3D_ITERMAX = 2,
    BEM3D_UNKNOWN_FORMAT = 3
d119 4
a122 2
    BEM3D_AVERAGE_MWSELR,	/**< Mean weighted by sine and edge length reciprocal*/ 
    BEM3D_AVERAGE_MWAAT,        /**< Mean weighted by areas of adjacent triangles*/
d124 2
a125 1
    BEM3D_AVERAGE_MWRELR        /**< Mean weighted by square root of edge length reciprocals*/
a136 1
/* #define BEM3D_PARAMETERS_ */
d164 1
a164 1
   * @@ingroup Mesh
d177 1
a177 1
    GByteArray *node ;
d186 1
a186 1
   * @@ingroup Mesh
d200 1
a200 1
   * @@ingroup Mesh
d212 1
a212 1
   * @@ingroup Mesh
d224 1
a224 1
   * @@ingroup Mesh
d229 1
a229 1
#define IS_BEM3D_MESH(obj)         (gts_object_is_from_class \
d239 1
a239 1
   * @@ingroup Mesh
d248 1
a248 1
   * @@ingroup Mesh
d257 1
a257 1
   * @@ingroup Mesh
d275 1
a275 1
    gint nmax, n ;
d277 1
d301 12
a312 11
    gint nf,			
      nv,				
      nc,				
      ns,				
      *i,				
      *s ;			
    gpointer *f,			
      *v,				
      *c ;			
    gdouble *xs,			
      *xc ;			
d314 2
a315 1
      cpf ;			
d341 1
a341 1
#define IS_BEM3D_ELEMENT(obj)         (gts_object_is_from_class (obj,	\
a346 16
   * Data type for edges of elements, intended for use with sharp edge
   * calculations.
   *
   */

  typedef struct {
    BEM3DElement *e1, *e2 ;
    gint nmax, n ;
    gpointer *v ;
    gint *i ;
    gboolean tag ;
  } BEM3DElementEdge ;

#define BEM3D_ELEMENT_EDGE(e) ((BEM3DElementEdge *)((e)))

  /**
a357 2


a397 1
/*     BEM3DAverage nmode ; */
d469 1
a469 1
   * &(bem3d_parameters_amplitude_real(p)) @@verbatim   
d642 2
a643 1
   * \f$g{d\phi}/{d n}-\phi dg/dn\f$ over the elements.
a655 1

a659 30
  typedef struct _BEM3DENode         BEM3DENode;

  struct _BEM3DENode {
    /*< private >*/
    GtsGNode parent;

    /*< public >*/
    /* add extra data here (if public) */
    BEM3DElement *e ;
  };

  typedef struct _BEM3DENodeClass    BEM3DENodeClass;

  struct _BEM3DENodeClass {
    /*< private >*/
    GtsGNodeClass parent_class;

    /*< public >*/
    /* add extra methods here */
  };

#define BEM3D_ENODE(obj)            GTS_OBJECT_CAST (obj,		\
						     BEM3DENode,	\
						     bem3d_enode_class ())
#define BEM3D_ENODE_CLASS(klass)    GTS_OBJECT_CLASS_CAST (klass,	\
							   BEM3DENodeClass, \
							   bem3d_enode_class())
#define IS_BEM3D_ENODE(obj)         (gts_object_is_from_class (obj,	\
							       bem3d_enode_class ()))

d669 1
d751 1
a751 1
#define bem3d_element_shapefunc(e) (e->shf)
d848 23
d910 1
a910 1
  gint bem3d_element_area(BEM3DElement *e, gint ngp, gdouble *dA) ;
d915 2
a916 2
  gint bem3d_element_jacobian(BEM3DElement *e, gdouble *dLds, gdouble *dLdt,
			      gdouble *J) ;
d946 2
d1008 1
a1008 1
  void bem3d_mesh_write(BEM3DMesh *m, FILE *fptr) ;
d1010 1
a1010 1
  guint bem3d_read_gmsh(FILE *input, BEM3DMesh *m) ;
d1015 1
a1015 1
  gint bem3d_mesh_index_nodes(BEM3DMesh *m, gint *n) ;
d1043 1
a1043 1
  gint bem3d_mesh_clean_edges(BEM3DMesh *m) ;
d1047 13
a1059 2
#define bem3d_mesh_data_width(m) ((m)->nd)
#define bem3d_mesh_data_field_number(m) ((m)->nc)
d1063 1
d1065 1
a1065 1
  gint bem3d_mesh_data_add_vertex(BEM3DMeshData *m, gint i) ;
d1067 1
a1136 5
  void bem3d_logging_func(const gchar *log_domain,
			  GLogLevelFlags log_level,
			  const gchar *message,
			  gpointer data[]) ;

d1141 9
a1149 12
  gint gauss_select_quadrature(guint npts, 
			       const gdouble **xk, const gdouble **wt,
			       quadrature_rule_t quad_type) ;
  gint gauss_set_scaling(gdouble x0, gdouble x1, gdouble *xbar, gdouble *dx,
			 guint npts, quadrature_rule_t quad_type) ;

#define bem3d_quadrature_clear(q) (q->n=0) 
#define bem3d_quadrature_vertex_number(q) (q->n)
#define bem3d_quadrature_vertex_number_max(q) (q->nmax)
#define bem3d_quadrature_xi(q,i) (q->s[i])
#define bem3d_quadrature_eta(q,i) (q->t[i])
#define bem3d_quadrature_weight(q,i) (q->w[i])
d1152 1
d1177 3
a1188 15
  gint bem3d_geometry_curve_line(GtsSurface *s,
				 GtsVertex **v, GtsEdge **e,
				 GtsVertex **w, GtsEdge **g,
				 gint n, gboolean revert) ;
  gint bem3d_geometry_line(GtsVertex *x0, GtsVertex *x1,
			   gint n, GtsVertex **v, GtsEdge **e) ;
  gint bem3d_geometry_sweep(GtsSurface *s, 
			    GtsVertex **v, GtsVertex **w, 
			    GtsEdge **e, gint n) ;
  gint bem3d_geometry_circle(GtsVertex **v, gint n) ;
  gint bem3d_geometry_connect(GtsVertex **v, GtsEdge **e, gint n,
			      gboolean closed) ;
  gint bem3d_geometry_duplicate(GtsVertex **v, GtsVertex **w, gint n) ;
  gint bem3d_geometry_translate(GtsVertex **v, gint n, GtsVector d) ;
  gint bem3d_geometry_square(GtsVertex **v, gint n) ;
a1189 1
  BEM3DElement *bem3d_mesh_edges_element(BEM3DMesh *m, GtsEdge *e1, GtsEdge *e2) ;
a1190 1
  gint bem3d_quadrature_selector_shift(BEM3DQuadratureSelector *s, gint n) ;
d1197 2
a1198 1
				gint nv, gint *indices,
a1202 43
  BEM3DElementEdge *bem3d_element_edge_new(gint nmax) ;
  GSList *bem3d_element_edges_read(BEM3DMesh *m, FILE *f) ;
  gint bem3d_element_edges_link(BEM3DMesh *m,
				GSList *edges1, GSList *edges2, gint ns,
				BEM3DElementBuildFunc bfunc, gboolean tri,
				gint *np) ;
  gint bem3d_element_edge_orient(BEM3DElementEdge *e, GtsVector s) ;
  gint bem3d_element_edge_fix(BEM3DElementEdge *e) ;
  gint bem3d_element_edge_orientation(BEM3DElementEdge *e, gint i, GtsVector s) ;
  /* gint bem3d_element_edge_orientation(BEM3DElement *e1, BEM3DElement *e2, */
  /* 				  GtsPoint *p, GtsVector s) ; */
  gint bem3d_element_edge_tangent(BEM3DElementEdge *e, gint i, GtsVector t) ;
  gint bem3d_element_edge_clear(BEM3DElementEdge *e) ;
  gint bem3d_element_edge_add_vertex(BEM3DElementEdge *e,
				     BEM3DElement *e1, BEM3DElement *e2,
				     GtsVertex *v, gint i, gint j) ;
  gint bem3d_element_edge_write(BEM3DElementEdge *e, FILE *f) ;
  gint bem3d_element_edge_read(BEM3DElementEdge *e, FILE *f) ;
  gint bem3d_element_edge_link(BEM3DElementEdge *e, BEM3DMesh *m) ;
  gboolean bem3d_element_edges_equal(BEM3DElementEdge *e1, BEM3DElementEdge *e2) ;
  gint bem3d_element_edge_free(BEM3DElementEdge *e) ;
  gint bem3d_element_edge_copy_vertices(BEM3DElementEdge *f,
					BEM3DElementEdge *e) ;
  gint bem3d_element_edge_reverse(BEM3DElementEdge *e) ;
  gint bem3d_element_edge_revert(BEM3DElementEdge *e) ;
  gboolean bem3d_element_edges_are_connected(BEM3DElementEdge *e1, 
					     BEM3DElementEdge *e2) ;
  gint bem3d_element_edge_swap_vertices(BEM3DElementEdge *e, gint i, gint j) ;
  gint bem3d_element_edges_match_sense(BEM3DElementEdge *e1, 
				       BEM3DElementEdge *e2) ;
  gint bem3d_element_edge_find_vertex(BEM3DElementEdge *e, GtsVertex *v) ;

  gint bem3d_element_edge_mesh(GSList *e, BEM3DMesh *m) ;
  GSList *bem3d_element_edge_copy_list(GSList *edges) ;
  gint bem3d_element_edge_align(BEM3DElementEdge *e) ;
  GSList *bem3d_element_edge_vertices(GSList *e) ;
  gint bem3d_element_edge_write_quiver(BEM3DElementEdge *e, FILE *f) ;
  gint bem3d_element_edge_update(BEM3DElementEdge *e) ;

  BEM3DENodeClass * bem3d_enode_class  (void);
  BEM3DENode * bem3d_enode_new (BEM3DENodeClass * klass, BEM3DElement *e) ;
  GtsGraph *bem3d_mesh_graph(BEM3DMesh *m) ;
  BEM3DMesh *bem3d_mesh_graph_mesh(GtsGraph *g, BEM3DMesh *m) ;
d1215 90
d1306 35
a1345 1

@


1.1
log
@Initial revision
@
text
@d1 2
a2 2
#ifndef BEM_H_INCLUDED
#define BEM_H_INCLUDED
d8 1
d12 1
a12 1
/*configuration options for the maintainer*/
d15 80
a94 3
#ifndef BEM_QUADRATURE_CACHING
#define BEM_QUADRATURE_CACHING 1
#endif /*BEM_QUADRATURE_CACHING*/
d97 331
a427 6
  BEM_FAILURE = -1,
  BEM_SUCCESS = 0,
  BEM_EINVAL = 1,
  BEM_ITERMAX = 2,
  BEM_UNKNOWN_FORMAT = 3
} bem_error ;
d429 3
a431 7
typedef enum {
  GAUSS_LINEAR = 0,
  GAUSS_LOGARITHMIC = 1,
  GAUSS_TRIANGULAR = 2, 
  GAUSS_CHEBYSHEV_2 = 3,
  GAUSS_HYPER = 4
} quadrature_rule_t ;
d433 454
a886 652
typedef enum {
  BEM_GMSH_SCALAR = 0,
  BEM_GMSH_VECTOR = 1,
  BEM_GMSH_TENSOR = 2
} bem_gmsh_mode_t ;

/**
 * @@typedef BEMShapeFunc
 * @@ingroup shapefunc
 *
 * BEM shape function definition
 * 
 * @@param s local coordinate
 * @@param t local coordinate
 * @@param L array to be filled with the shape function(s) at (s,t)
 * @@param dLds array to be filled with the derivatives of L at (s,t)
 * @@param dLdt array to be filled with the derivatives of L at (s,t)
 * @@param data data to be passed to the shape function
 *
 * @@return 0 on success
 */

typedef gint (* BEMShapeFunc)(gdouble s, 
			      gdouble t, 
			      gdouble *L, 
			      gdouble *dLds, 
			      gdouble *dLdt,
			      gpointer data) ;


typedef struct _BEMMesh         BEMMesh ;

/**
 * @@struct BEMMesh
 *
 * Opaque data structure for a BEM Mesh. This should only be accessed
 * through the relevant functions and macros.
 * 
 */

struct _BEMMesh {
  /*< private >*/
  GtsSurface parent;
  GHashTable *e,
    *f,
    *c ;
  GByteArray *cpt ;
  gint i0, i1 ;
  /*< public >*/
  /* add extra data here (if public) */
};

/**
 * @@typedef BEMMeshClass
 * The basic class for a BEMMesh.
 * @@ingroup Mesh
 */

typedef struct _BEMMeshClass    BEMMeshClass;

struct _BEMMeshClass {
  /*< private >*/
  GtsSurfaceClass parent_class;

  /*< public >*/
  /* add extra methods here */
};

/** 
 * @@ingroup Mesh
 * Casts \a obj to ::BEMMesh
 * 
 * @@param obj a GtsObject
 * 
 * @@return result of casting \a obj to ::BEMMesh.
 */
#define BEM_MESH(obj)            GTS_OBJECT_CAST (obj,\
					         BEMMesh,\
					         bem_mesh_class ())
/** 
 * @@ingroup Mesh
 * Casts \a klass to ::BEMMeshClass
 * 
 * @@param klass class to cast
 * 
 * @@return 
 */
#define BEM_MESH_CLASS(klass)    GTS_OBJECT_CLASS_CAST (klass,\
						 BEMMeshClass,\
						 bem_mesh_class())

/** 
 * @@ingroup Mesh
 * TRUE if \a obj is from the ::BEMMeshClass class
 * 
 * @@param obj 
 * 
 * @@return 
 */
#define IS_BEM_MESH(obj)         (gts_object_is_from_class (obj,\
						 bem_mesh_class ()))

BEMMeshClass *bem_mesh_class  (void);
BEMMesh *bem_mesh_new    (BEMMeshClass * klass,
			  GtsFaceClass *face_class,
			  GtsEdgeClass *edge_class,
			  GtsVertexClass *vertex_class) ;

/**
 * @@ingroup Mesh
 * Number of elements in a ::BEMMesh
 * 
 */

#define bem_mesh_nelements(m) (g_hash_table_size(m->e))

/**
 * @@ingroup Mesh
 * Minimum index of collocation point to be considered in
 * bem_mesh_foreach_cpoint
 * 
 */

#define bem_mesh_cpt_index_min(m) (m->i0)
/**
 * @@ingroup Mesh
 * Maximum index of collocation point to be considered in
 * bem_mesh_foreach_cpoint
 * 
 */

#define bem_mesh_cpt_index_max(m) (m->i1)

/**
 * @@struct BEMQuadratureRule
 * @@ingroup Quadrature
 *
 * Quadrature rule for integration on two-dimensional elements
 * containing the nodes and weights normalized to a unit simplex.
 */

typedef struct {
  gint nmax, n ;
  gdouble *s, *t, *w ;
} BEMQuadratureRule ;

/**
 * @@typedef BEMElement 
 * Data type for BEM elements, containing the data
 * for geometry and collocation points. 
 *
 * The ::BEMElement type should usually be accessed only through the
 * provided functions and macros. In order to implement new elements,
 * you should look up the ::BEMElementBuildFunc type.
 *
 * @@ingroup belement
 * 
 */

typedef struct _BEMElement         BEMElement;

struct _BEMElement {
  /*< private >*/
  GtsObject parent;

  /*< public >*/
  /* add extra data here (if public) */
  gint nf,			
    nv,				
    nc,				
    ns,				
    *i,				
    *s ;			
  gpointer *f,			
    *v,				
    *c ;			
  gdouble *xs,			
    *xc ;			
  BEMShapeFunc shf,		
    cpf ;			
  gpointer reserved ;		
};

typedef struct _BEMElementClass    BEMElementClass;

/**
 * @@typedef BEMElementClass
 * The basic class for a BEMElement
 * @@ingroup belement
 */

struct _BEMElementClass {
  /*< private >*/
  GtsObjectClass parent_class;

  /*< public >*/
  /* add extra methods here */
};

#define BEM_ELEMENT(obj)            GTS_OBJECT_CAST (obj,\
					         BEMElement,\
					         bem_element_class ())
#define BEM_ELEMENT_CLASS(klass)    GTS_OBJECT_CLASS_CAST (klass,\
						 BEMElementClass,\
						 bem_element_class())
#define IS_BEM_ELEMENT(obj)         (gts_object_is_from_class (obj,\
						 bem_element_class ()))

BEMElementClass * bem_element_class  (void);

/**
 * Data type for edges of elements, intended for use with sharp edge
 * calculations.
 *
 */

typedef struct {
  BEMElement *e1, *e2 ;
  gint nmax, n ;
  gpointer *v ;
  gint *i ;
  gboolean tag ;
} BEMElementEdge ;

#define BEM_ELEMENT_EDGE(e) ((BEMElementEdge *)((e)))

/**
 * Numerical data associated with a BEMMesh
 * 
 */

typedef struct {
  gint nd, nc, ncmax ; 
  GHashTable *t ;
  gdouble *data ;
} BEMMeshData ;



/**
 * @@struct BEMQuadratureRuleFunc
 * @@ingroup Quadrature 
 * gint BEMQuadratureRuleFunc(GtsPoint *p, BEMElement *e,
 * BEMQuadratureRule *q, gpointer data) ;
 *
 * Function for generating quadrature rules
 * 
 * @@param p field point for integration
 * @@param e element over which to integrate
 * @@param q quadrature rule to hold points
 * @@param data user data to pass to function
 * 
 * @@return 0 on success
 */

typedef gint (*BEMQuadratureRuleFunc)(GtsPoint *p, BEMElement *e,
				      BEMQuadratureRule *q, gpointer data) ;

/**
 * @@struct BEMLookupFunc
 *
 * gint BEMLookupFunc(gint i, gint j, gpointer ldata, GArray *f,
 * GArray *g) ;
 *
 * Function for looking up data
 *
 * @@param i global index of collocation point
 * @@param j local index of collocation point
 * @@param ldata user data to pass to lookup function
 * @@param f solution at collocation point
 * @@param g normal derivative of solution at collocation point
 */

typedef gint (*BEMLookupFunc)(gint i, gint j, gpointer ldata, 
			      GArray *f, GArray *g) ;

/**
 * @@typedef BEMGreensFunc
 * @@ingroup gfunc
 *
 * gint BEMGreensFunc(GtsPoint *x, GtsPoint *y, GtsVector n, gpointer
 * param, GArray *G, GArray *dGdn) ;
 *
 * Green's function for various problems. The function should return 0
 * on success and fill \a G with the Green's function and \a dGdn with
 * minus its normal derivative, or their equivalents for a particular
 * problem.
 * 
 * @@param x field point
 * @@param y source point
 * @@param n normal at source point
 * @@param param parameters to use in Green's function
 * @@param G Green's function
 * @@param dGdn normal derivative of Green's function
 */

typedef gint (*BEMGreensFunc)(GtsPoint *x, GtsPoint *y,
			      GtsVector n, gpointer param, 
			      GArray *G, GArray *dGdn) ;

/**
 * Quadrature selection rule structure. 
 * @@ingroup Quadrature
 */

typedef struct {
  gint 
  nmax,				
    n ;				
  BEMQuadratureRuleFunc *f ;	
  gdouble *p ;			
  gpointer *data ;		
} BEMQuadratureSelector ;

/**
 * @@struct BEMElementBuildFunc
 * @@ingroup elements
 * Build an element from edge and vertex data
 * 
 * @@param e an array of edges
 * @@param v an array of vertices
 *
 * @@return a pointer to the newly built element
 *
 * The function should insert the vertices into the new element and
 * construct new faces and edges as required to build up the
 * element. Note that the ordering is important for the shape functions. 
 */

typedef BEMElement *(*BEMElementBuildFunc)(GtsEdge **e, 
					   GtsVertex **v) ;

/**
 * @@struct BEMCPTFunc
 *
 * A function which visits collocation points, usually called from
 * ::bem_mesh_foreach_cpoint
 * 
 * @@param i the collocation point index
 * @@param item pointer to the vertex
 * @@param data user data to pass to the function 
 *
 * @@return 0 on success
*/

typedef gint (*BEMCPTFunc)(gint i, gpointer item, gpointer data) ;

/**
 * @@struct BEMELementFunc
 *
 * A function which visits elements, usually called from
 * bem_mesh_foreach_element
 * 
 * @@param item pointer to the element
 * @@param data user data to pass to the function 
 *
 * @@return 0 on success
*/

typedef gint (*BEMElementFunc)(BEMElement *item, gpointer data) ;

/**
 * @@struct BEMEquationFunc
 *
 * A function to insert data in an equation matrix
 *
 * @@param i row index 
 * @@param j column index 
 * @@param G Green's function matrix terms
 * @@param dGdn normal derivative terms
 * @@param n number of elements in term (e.g. 2 for complex data)
 * @@param data user data to pass to function
 *
 * @@return 0 on success
 */
typedef gint (*BEMEquationFunc)(gint i, gint j,
				gdouble *G, gdouble *dGdn,
				gint n, gpointer data) ;

/**
 * @@struct BEMBCFunc
 *
 * A function to set boundary conditions
 * 
 * @@param v the vertex at which to set the boundary condition
 * @@param n the normal at that vertex
 * @@param i the global index of the node
 * @@param data user data to pass to the function
 *
 * @@return 0 on success
 */

typedef gint (*BEMBCFunc)(GtsVertex *v, GtsVector n,
			  gint i, gpointer data) ;

/**
 * @@struct BEMMeshDataFunc
 *
 * A function to set numerical data for a mesh and insert it in a
 * BEMMeshData variable
 *  
 * @@param i global index of node
 * @@param v node vertex
 * @@param data user data to pass to the function
 * @@param f array of output data
 * 
 * @@return 0 on success
 */

typedef gint (*BEMMeshDataFunc)(gint i, GtsVertex *v, 
				gpointer data, gdouble *f) ;

/**
 * @@struct BEMRadiationFunc
 *
 * Compute radiated quantities given the integrated Green's function
 * and derivative over an element and the solution at the element
 * nodes. In principle, the solution is the sum of 
 * \f$g{d\phi}/{d n}-\phi dg/dn\f$ over the elements.
 * 
 * @@param g GArray of integrated Green's function on element
 * @@param dgdn GArray of integrated Green's function normal derivative 
 * on element
 * @@param phi GArray of solution at element nodes
 * @@param dphi GArray of solution normal derivative at nodes
 * @@param f GArray of radiated field
 * @@param data user data to pass to function
 *
 * @@return 0 on success 
*/


typedef gint (*BEMRadiationFunc)(GArray *g, GArray *dgdn,
				 GArray *phi, GArray *dphi,
				 GArray *f, gpointer data) ;

typedef struct _BEMENode         BEMENode;

struct _BEMENode {
  /*< private >*/
  GtsGNode parent;

  /*< public >*/
  /* add extra data here (if public) */
  BEMElement *e ;
};

typedef struct _BEMENodeClass    BEMENodeClass;

struct _BEMENodeClass {
  /*< private >*/
  GtsGNodeClass parent_class;

  /*< public >*/
  /* add extra methods here */
};

#define BEM_ENODE(obj)            GTS_OBJECT_CAST (obj,\
					         BEMENode,\
					         bem_enode_class ())
#define BEM_ENODE_CLASS(klass)    GTS_OBJECT_CLASS_CAST (klass,\
						 BEMENodeClass,\
						 bem_enode_class())
#define IS_BEM_ENODE(obj)         (gts_object_is_from_class (obj,\
						 bem_enode_class ()))

/**
 * @@ingroup matrix
 *
 * A basic definition of a 3x3 matrix.
 * 
 */

typedef gdouble BEMMatrix[9] ;

/** 
 * @@ingroup belement
 * 
 * @@param e a ::BEMElement
 * 
 * @@return the number of GtsFace's on the element \a e
 */
#define bem_element_nfaces(e) (e->nf)

/** 
 * @@ingroup belement
 * 
 * @@param e a ::BEMElement
 * 
 * @@return the number of geometrical vertices on the element \a e
 */
#define bem_element_nv(e) (e->nv)

/** 
 * @@ingroup belement
 * 
 * @@param e a ::BEMElement
 * 
 * @@return the number of collocation points on the element \a e
 */
#define bem_element_ncpt(e) (e->nc)

/** 
 * @@ingroup belement
 * 
 * @@param e a ::BEMElement
 * 
 * @@return the number of corners on the element \a e
 */
#define bem_element_ncorner(e) (e->ns)

/** 
 * @@ingroup belement
 * 
 * @@param e a ::BEMElement
 * @@param _i index of a corner 0 < i < bem_element_ncorner(e)
 *
 * @@return the GtsVertex at the \a i th corner. 
 */
#define bem_element_corner(e,_i) (e->v[e->s[(_i)]])

/** 
 * @@ingroup belement
 * 
 * @@param e a ::BEMElement
 * @@param _i index of a corner 0 < i < bem_element_ncorner(e)
 *
 * @@return the local index of the \a i th corner of \a e.
 */
#define bem_element_corner_index(e,_i) (e->s[(_i)])

/** 
 * @@ingroup belement
 * 
 * @@param e a ::BEMElement
 * @@param _i local index of a collocation point
 *
 * @@return the global index of the \a i th collocation point of \a e.
 */
#define bem_element_global_index(e,_i) (e->i[(_i)])

/** 
 * @@ingroup belement
 * 
 * @@param e a ::BEMElement
 *
 * @@return the geometric ::BEMShapeFunc of \a e
 */
#define bem_element_shapefunc(e) (e->shf)

/** 
 * @@ingroup belement
 * 
 * @@param e a ::BEMElement
 *
 * @@return the collocation ::BEMShapeFunc of \a e
 */
#define bem_element_collfunc(e) (e->cpf)

/** 
 * @@ingroup belement
 * 
 * @@param e a ::BEMElement
 * @@param i local index of a collocation point on \a e
 *
 * @@return the GtsVertex of the \a i th collocation point of \a e.
 */
#define bem_element_cpoint(e,i) (e->c[i]) 

/** 
 * @@ingroup belement
 * 
 * @@param e a ::BEMElement
 * @@param i local index of a collocation point on \a e
 *
 * @@return the local coordinate \f$\xi\f$ of the \a i th collocation
 * point of \a e.
 */

#define bem_element_cpt_xi(e,i) ((e)->xc[2*(i)])

/** 
 * @@ingroup belement
 * 
 * @@param e a ::BEMElement
 * @@param i local index of a collocation point on \a e
 *
 * @@return the local coordinate \f$\eta\f$ of the \a i th collocation
 * point of \a e.
 */

#define bem_element_cpt_eta(e,i) ((e)->xc[2*(i)+1])

/** 
 * @@ingroup belement
 * 
 * @@param e a ::BEMElement
 * @@param i local index of a geometric point on \a e
 *
 * @@return the GtsVertex of the \a i th geometric point of \a e.
 */
#define bem_element_node(e,i) (e->v[(i)])

/** 
 * @@ingroup belement
 * 
 * @@param e a ::BEMElement
 * @@param i local index of a collocation point on \a e
 *
 * @@return the local coordinate \f$\xi\f$ of the \a i th geometric
 * point of \a e.
 */

#define bem_element_node_xi(e,i) ((e)->xs[2*(i)])

/** 
 * @@ingroup belement
 * 
 * @@param e a ::BEMElement
 * @@param i local index of a collocation point on \a e
 *
 * @@return the local coordinate \f$\eta\f$ of the \a i th geometric
 * point of \a e.
 */

#define bem_element_node_eta(e,i) ((e)->xs[2*(i)+1])

/** 
 * @@ingroup belement
 * 
 * @@param e a ::BEMElement
 * @@param i local index of a GtsFace on \a e
 *
 * @@return the \a i th GtsFace of \a e.
 */
#define bem_element_face(e,i) (e->f[(i)])

#define bem_element_edge_npts(e) ((e->n))
#define bem_element_edge_vertex(e,_i) (e->v[(_i)])
#define bem_element_edge_index_upper(e,_i) (e->i[(2*(_i))])
#define bem_element_edge_index_lower(e,_i) (e->i[(2*(_i)+1)])
#define bem_element_edge_upper(e) (e->e1)
#define bem_element_edge_lower(e) (e->e2)

/** 
 * @@ingroup belement
 * 
 * @@param m a ::BEMMEsh
 * @@param el a ::BEMElement
 *
 * @@return TRUE if \a el is an element of \a m, FALSE otherwise.
 */
d888 1
a888 1
#define bem_element_has_parent_mesh(m,el) \
d891 38
a928 33
/* BEMElement *bem_element_new    (BEMElementClass * klass); */
BEMElement *bem_element_new(BEMElementClass * klass,
			    gint nf, gint nv, gint nc, gint ns,
			    BEMShapeFunc shf, BEMShapeFunc cpf) ;
gint bem_element_add_vertex(BEMElement *e, gpointer v, gint i) ;
gboolean bem_element_point_inside(BEMElement *e, gdouble xi, gdouble eta) ;
gint bem_element_gradient_weights(BEMElement *e, gdouble xi, gdouble eta,
				  gdouble *w) ;
gint bem_element_add_cpt(BEMElement *e, gpointer v, gint i) ;
gint bem_element_add_face(BEMElement *e, gpointer f, gint i) ;
gint bem_element_write(BEMElement *e, 
		       GHashTable *v, GHashTable *t,
		       FILE *f) ;
gint bem_element_set_index(BEMElement *e, gint i, gint j) ;
gint bem_element_set_corner(BEMElement *e, gint i, gint j)  ;
gint bem_element_find_vertex(BEMElement *e, GtsVertex *v) ;
gint bem_element_find_face(BEMElement *e, GtsFace *f) ;
gint bem_element_find_cpt(BEMElement *e, GtsVertex *v) ;
gint bem_element_area(BEMElement *e, gint ngp, gdouble *dA) ;
gint bem_element_position(BEMElement *e, gdouble *L,
			  GtsPoint *q) ;
gint bem_element_normal(BEMElement *e, gdouble *dLds, gdouble *dLdt,
			GtsVector normal, gdouble *J) ;
gint bem_element_jacobian(BEMElement *e, gdouble *dLds, gdouble *dLdt,
			  gdouble *J) ;
gint bem_element_assemble_equations(BEMElement *e, GtsPoint *x,
				    BEMGreensFunc gfunc, gpointer gdata,
				    BEMQuadratureRuleFunc qfunc,
				    gpointer qdata,
				    GArray *G, GArray *dGdn) ;
gint bem_element_nearest(BEMElement *e, GtsPoint *p,
			 gint *i, gdouble *R) ;
gint bem_element_boundary_nearest_point(BEMElement *e, GtsPoint *x,
a929 43
gint bem_element_edge_nearest_point(BEMElement *e, gint i, gint j,
				    GtsPoint *x,
				    gdouble *xi, gdouble *eta) ;

GSList *bem_elements_common_edges(BEMElement *e1, BEMElement *e2) ;
gint bem_element_local_vectors(BEMElement *e,
			       gdouble dLds[], gdouble dLdt[],
			       GtsVector u1, gdouble *h1,
			       GtsVector u2, gdouble *h2) ;
gboolean bem_element_has_vertex(BEMElement *e, GtsVertex *v) ;
gint bem_element_replace_vertex(BEMElement *e, GtsVertex *v, 
				GtsVertex *w) ;
gint bem_element_reset_index(BEMMesh *m, BEMElement *e, gint i, gint j) ;
gint bem_element_slopes(BEMElement *e, gdouble *dLds, gdouble *dLdt,
			GtsVector dxds, GtsVector dxdt) ;
gint bem_element_nearest_point(BEMElement *e, GtsPoint *x,
			       gdouble *xi, gdouble *eta, 
			       gboolean constrain) ;
GSList *bem_element_neighbours(BEMElement *el, BEMMesh *m) ;
BEMElement *bem_element_from_cpoint(BEMMesh *m, GtsVertex *v, gint i) ;
gint bem_element_index_cpoints(BEMElement *e, BEMMesh *m, gint *n) ;

BEMElement *bem_element_build_t0(GtsEdge **e, GtsVertex **v) ;
BEMElement *bem_element_build_t1(GtsEdge **e, GtsVertex **v) ;
BEMElement *bem_element_build_t2(GtsEdge **e, GtsVertex **v) ;
BEMElement *bem_element_build_t3(GtsEdge **e, GtsVertex **v) ;
BEMElement *bem_element_build_q1(GtsEdge **e, GtsVertex **v) ;
BEMElement *bem_element_build_q2(GtsEdge **e, GtsVertex **v) ;

GSList *bem_element_common_cpts(BEMElement *e1, BEMElement *e2) ;

gint bem_greens_func_laplace(GtsPoint *x, GtsPoint *y,
			     GtsVector n, gpointer p, 
			     GArray *G, GArray *dGdn) ;
gint bem_greens_func_helmholtz(GtsPoint *x, GtsPoint *y,
			       GtsVector n, gpointer p,
			       GArray *G, GArray *dGdn) ;
gint bem_greens_func_convected_helmholtz(GtsPoint *x, GtsPoint *y,
					 GtsVector n, gpointer p,
					 GArray *G, GArray *dGdn) ;
gint bem_greens_func_gradient_laplace(GtsPoint *x, GtsPoint *y,
				  GtsVector n, gpointer p,
				  GArray *G, GArray *dGdn) ;
d931 333
a1263 271
gint bem_radiation_func_laplace(GArray *G, GArray *dG,
				GArray *phi, GArray *dphi,
				GArray *f, gpointer data) ;
gint bem_radiation_func_helmholtz(GArray *G, GArray *dG,
				  GArray *phi, GArray *dphi,
				  GArray *f, gpointer data) ;
gint bem_mesh_radiation_point(BEMMesh *m,
			      BEMGreensFunc gf, gpointer gdata,
			      BEMQuadratureRuleFunc qf, gpointer qdata,
			      BEMLookupFunc lf, gpointer ldata,
			      BEMRadiationFunc rf, gpointer rdata,
			      GtsPoint *x, GArray *f) ;
gint bem_element_radiation_point(BEMElement *e, 
				 BEMGreensFunc gfunc, gpointer gdata,
				 BEMQuadratureRuleFunc qfunc, gpointer qdata,
				 BEMLookupFunc lfunc, gpointer ldata,
				 GtsPoint *x, 
				 GArray *G, GArray *dGdn,
				 GArray *phi, GArray *dphi) ;
gint bem_mesh_radiation_mesh(BEMMesh *m,
			     BEMGreensFunc gf, gpointer gdata,
			     BEMQuadratureRuleFunc qf, gpointer qdata,
			     BEMLookupFunc lf, gpointer ldata,
			     BEMRadiationFunc rf, gpointer rdata,
			     BEMMesh *s, BEMMeshData *f) ;

GtsVertex *bem_mesh_find_cpt(BEMMesh *m, gint i) ;
void bem_mesh_write(BEMMesh *m, FILE *fptr) ;
guint bem_mesh_read(BEMMesh *m, GtsFile *f) ;
  guint bem_read_gmsh(FILE *input, BEMMesh *m) ;
gint bem_mesh_add_element(BEMMesh *m, BEMElement *e) ;
  gint bem_mesh_remove_element(BEMMesh *m, BEMElement *e) ;
GSList *bem_mesh_vertex_elements(BEMMesh *m, GtsVertex *v) ;
gint bem_mesh_number_cpts(BEMMesh *m, gint *n) ;
gint bem_mesh_count_cpts(BEMMesh *m, gint *n) ;
gint bem_mesh_discretize(GtsSurface *s, gint nne,
			 BEMElementBuildFunc bfunc,
			 BEMMesh *m) ;
gint bem_mesh_index_from_cpoint(BEMMesh *m, GtsVertex *v) ;
gint bem_mesh_assemble_equations(BEMMesh *m, BEMMesh *n,
				 BEMGreensFunc gf, gpointer gdata,
				 BEMEquationFunc ef, gpointer edata,
				 BEMQuadratureRuleFunc qf, gpointer qdata) ;
gint bem_equation_func_simple(gint i, gint j,
			      gdouble *G, gdouble *dGdn, gint n,
			      gpointer *e) ;
gint bem_mesh_write_nodes(BEMMesh *m, FILE *f) ;
gint bem_mesh_foreach_element(BEMMesh *m, BEMElementFunc f, gpointer data) ;
gint bem_mesh_foreach_cpoint(BEMMesh *m, BEMCPTFunc f, gpointer data) ;
gint bem_mesh_element_clear_reserved(BEMMesh *m) ;
gint bem_mesh_set_bc(BEMMesh *m, BEMBCFunc bcf, gpointer bdata) ;
gint bem_mesh_quad_dgdn(BEMMesh *m,
			BEMGreensFunc gfunc, gpointer gdata,
			BEMQuadratureRuleFunc qfunc, gpointer qdata,
			BEMLookupFunc lfunc, gpointer ldata,
			BEMRadiationFunc rfunc, gpointer rdata,
			BEMEquationFunc efunc, gpointer edata) ;
gint bem_mesh_merge(BEMMesh *m, BEMMesh *n) ;
gint bem_mesh_clean_edges(BEMMesh *m) ;

BEMElement *bem_mesh_face_element(BEMMesh *m, GtsFace *f) ;

#define bem_mesh_data_width(m) (m->nd)

  gint bem_mesh_data_multiproc_sum(BEMMeshData *m) ;
BEMMeshData *bem_mesh_data_new(BEMMesh *m, gint n) ;
BEMMeshData *bem_mesh_data_sized_new(gint n, gint m) ;
gint bem_mesh_data_add_node(BEMMeshData *m, gint i) ;
gdouble *bem_mesh_data_get(BEMMeshData *m, gint i) ;
gint bem_mesh_function_eval(BEMMesh *m, 
			    BEMMeshDataFunc f,
			    gpointer fdata, 
			    BEMMeshData *d) ;
gint bem_mesh_function_limits(BEMMeshData *f, gint i,
			      gdouble *xmin, gdouble *xmax) ;
gint bem_mesh_data_clear(BEMMeshData *m) ;
gint bem_mesh_data_add(BEMMeshData *f, gint i, GArray *g) ;

BEMQuadratureSelector *bem_quadrature_selector_new(gint n) ;
gint bem_quadrature_selector_add(BEMQuadratureSelector *s,
				 BEMQuadratureRuleFunc f,
				 gdouble p, gpointer data) ;
BEMQuadratureSelector *bem_quadrature_selector_default(void) ;
BEMQuadratureSelector *bem_quadrature_selector_hypersingular_default(void) ;
gint bem_quadrature_selector_clear(BEMQuadratureSelector *s) ;
gint bem_quadrature_select(BEMQuadratureSelector *s,
			   gdouble p,
			   BEMQuadratureRuleFunc *f,
			   gpointer *data) ;

#define bem_quadrature_selector_func(s,i) (s->f[(i)])
#define bem_quadrature_selector_sigma(s,i) (s->p[(i)])
#define bem_quadrature_selector_data(s,i) (s->data[(i)])

gint bem_shfunc_t0(gdouble s, gdouble t, 
		   gdouble *L, gdouble *dLds,
		   gdouble *dLdt, gpointer data) ;
gint bem_shfunc_t1(gdouble s, gdouble t, 
		   gdouble *L, gdouble *dLds,
		   gdouble *dLdt, gpointer data) ;
gint bem_shfunc_t2(gdouble s, gdouble t, 
		   gdouble *L, gdouble *dLds,
		   gdouble *dLdt, gpointer data) ;
gint bem_shfunc_t3(gdouble s, gdouble t, 
		   gdouble *L, gdouble *dLds,
		   gdouble *dLdt, gpointer data) ;
gint bem_shfunc_q1(gdouble s, gdouble t, 
		   gdouble *L, gdouble *dLds,
		   gdouble *dLdt, gpointer data) ;
gint bem_shfunc_q2(gdouble s, gdouble t, 
		   gdouble *L, gdouble *dLds,
		   gdouble *dLdt, gpointer data) ;

gint bem_shapefunc_lookup_init(void) ;
gint bem_shapefunc_lookup_add(BEMShapeFunc func, gchar *name) ;
BEMShapeFunc bem_shapefunc_lookup_func(const gchar *name) ;
const gchar *bem_shapefunc_lookup_name(BEMShapeFunc func) ;

gboolean bem_edge_is_sharp(GtsEdge *e, gdouble angle) ;
GSList *bem_edges_local(GtsVertex *v, GtsSurface *s) ;

gint bem_lookup_func_unit(gint i, gint j, 
			  gpointer data,
			  GArray *s, GArray *ds) ;

gint bem_lookup_func_unit_c(gint i, gint j, 
			    gpointer data,
			    GArray *s, GArray *ds) ;
gint bem_lookup_func_both_unit(gint i, gint j, 
			       gpointer data,
			       GArray *s, GArray *ds) ;

gint bem_area_coordinates_tri(GtsPoint *t1,
			      GtsPoint *t2,
			      GtsPoint *t3,
			      GtsPoint *x,
			      GtsVector xi) ;

void bem_logging_func(const gchar *log_domain,
		      GLogLevelFlags log_level,
		      const gchar *message,
		      gpointer data[]) ;

gint bem_logging_init(FILE *f, gchar *p, 
		      GLogLevelFlags log_level,
		      gpointer exit_func) ;

gint gauss_select_quadrature(guint npts, 
			     const gdouble **xk, const gdouble **wt,
			     quadrature_rule_t quad_type) ;
gint gauss_set_scaling(gdouble x0, gdouble x1, gdouble *xbar, gdouble *dx,
		       guint npts, quadrature_rule_t quad_type) ;

#define bem_quadrature_clear(q) (q->n=0) 
#define bem_quadrature_npts(q) (q->n)
#define bem_quadrature_npts_max(q) (q->nmax)
#define bem_quadrature_xi(q,i) (q->s[i])
#define bem_quadrature_eta(q,i) (q->t[i])
#define bem_quadrature_weight(q,i) (q->w[i])

BEMQuadratureRule *bem_quadrature_rule_new(gint n) ;
gdouble bem_quadrature_rule_sum_weights(BEMQuadratureRule *q) ;
gint bem_quadrature_rule_write(BEMQuadratureRule *q, FILE *f) ;
gint bem_quadrature_rule_realloc(BEMQuadratureRule *q, gint n) ;
gint bem_quadrature_add_point(BEMQuadratureRule *q,
			      gdouble xi, gdouble eta,
			      gdouble w) ;
gint bem_quadrature_rule_gauss(GtsPoint *p, BEMElement *e,
			       BEMQuadratureRule *q, gpointer n) ;
gint bem_quadrature_rule_default(GtsPoint *p,
				 BEMElement *e,
				 BEMQuadratureRule *q,
				 gpointer data) ;
gint bem_quadrature_rule_kw(GtsPoint *p, BEMElement *e,
			    BEMQuadratureRule *q, gpointer data) ;
gint bem_quadrature_rule_polar(GtsPoint *p, BEMElement *e,
			       BEMQuadratureRule *q, gpointer data) ;
gint bem_quadrature_rule_polar_hs(GtsPoint *p, BEMElement *e,
				  BEMQuadratureRule *q, gpointer data) ;
gint bem_quadrature_rule_hayami(GtsPoint *xs, BEMElement *e,
				BEMQuadratureRule *q, gpointer data) ;
gint bem_quadrature_rule_rnvr(GtsPoint *p, BEMElement *e,
			      BEMQuadratureRule *q, gpointer data) ;
gint bem_quadrature_rule_wx(GtsPoint *p, BEMElement *e,
			    BEMQuadratureRule *q, gpointer data) ;
gint bem_quadrature_parameter(GtsPoint *p, BEMElement *e,
			      gdouble *sigma) ;
gint bem_quadrature_rule_remap(gdouble xi0, gdouble eta0,
			       gdouble xi1, gdouble eta1,
			       gdouble xi2, gdouble eta2,
			       gdouble s, gdouble t, gdouble w,
			       gdouble *sn, gdouble *tn,
			       gdouble *wn) ;

gint bem_geometry_curve_line(GtsSurface *s,
			     GtsVertex **v, GtsEdge **e,
			     GtsVertex **w, GtsEdge **g,
			     gint n, gboolean revert) ;
gint bem_geometry_line(GtsVertex *x0, GtsVertex *x1,
		       gint n, GtsVertex **v, GtsEdge **e) ;
gint bem_geometry_sweep(GtsSurface *s, 
			GtsVertex **v, GtsVertex **w, 
			GtsEdge **e, gint n) ;
gint bem_geometry_circle(GtsVertex **v, gint n) ;
gint bem_geometry_connect(GtsVertex **v, GtsEdge **e, gint n,
			  gboolean closed) ;
gint bem_geometry_duplicate(GtsVertex **v, GtsVertex **w, gint n) ;
gint bem_geometry_translate(GtsVertex **v, gint n, GtsVector d) ;
gint bem_geometry_square(GtsVertex **v, gint n) ;
gint bem_geometry_plane(GtsSurface *s, gint ni, gint nj) ;
BEMElement *bem_mesh_edges_element(BEMMesh *m, GtsEdge *e1, GtsEdge *e2) ;
GtsVertex *bem_vertex_from_segments(GtsSegment *s1, GtsSegment *s2) ;
gint bem_quadrature_selector_shift(BEMQuadratureSelector *s, gint n) ;
gint bem_mesh_data_write(BEMMeshData *f, FILE *fp) ;
gint bem_mesh_data_read(BEMMeshData **f, FILE *fp) ;
gint bem_mesh_write_gmsh(BEMMesh *m, BEMMeshData *f, gint k,
			 gchar *view, bem_gmsh_mode_t mode,
			 FILE *fp) ;
gint bem_gmsh_write_element(BEMElement *e, BEMMeshData *f,
			    gint nv, gint *indices,
			    gchar *ename,
			    gint k, gint nf, FILE *fp) ;
GSList *bem_mesh_index_sharp_edges(BEMMesh *m, gdouble angle, 
				   gint *n) ;
BEMElementEdge *bem_element_edge_new(gint nmax) ;
GSList *bem_element_edges_read(BEMMesh *m, FILE *f) ;
gint bem_element_edges_link(BEMMesh *m,
			    GSList *edges1, GSList *edges2, gint ns,
			    BEMElementBuildFunc bfunc, gboolean tri,
			    gint *np) ;
gint bem_element_edge_orient(BEMElementEdge *e, GtsVector s) ;
gint bem_element_edge_fix(BEMElementEdge *e) ;
gint bem_element_edge_orientation(BEMElementEdge *e, gint i, GtsVector s) ;
/* gint bem_element_edge_orientation(BEMElement *e1, BEMElement *e2, */
/* 				  GtsPoint *p, GtsVector s) ; */
gint bem_element_edge_tangent(BEMElementEdge *e, gint i, GtsVector t) ;
gint bem_element_edge_clear(BEMElementEdge *e) ;
gint bem_element_edge_add_vertex(BEMElementEdge *e,
				 BEMElement *e1, BEMElement *e2,
				 GtsVertex *v, gint i, gint j) ;
gint bem_element_edge_write(BEMElementEdge *e, FILE *f) ;
gint bem_element_edge_read(BEMElementEdge *e, FILE *f) ;
gint bem_element_edge_link(BEMElementEdge *e, BEMMesh *m) ;
gboolean bem_element_edges_equal(BEMElementEdge *e1, BEMElementEdge *e2) ;
gint bem_element_edge_free(BEMElementEdge *e) ;
gint bem_element_edge_copy_vertices(BEMElementEdge *f,
				    BEMElementEdge *e) ;
gint bem_element_edge_reverse(BEMElementEdge *e) ;
gint bem_element_edge_revert(BEMElementEdge *e) ;
gboolean bem_element_edges_are_connected(BEMElementEdge *e1, 
					 BEMElementEdge *e2) ;
gint bem_element_edge_swap_vertices(BEMElementEdge *e, gint i, gint j) ;
gint bem_element_edges_match_sense(BEMElementEdge *e1, 
				   BEMElementEdge *e2) ;
gint bem_element_edge_find_vertex(BEMElementEdge *e, GtsVertex *v) ;

gint bem_element_edge_mesh(GSList *e, BEMMesh *m) ;
GSList *bem_element_edge_copy_list(GSList *edges) ;
gint bem_element_edge_align(BEMElementEdge *e) ;
GSList *bem_element_edge_vertices(GSList *e) ;
gint bem_element_edge_write_quiver(BEMElementEdge *e, FILE *f) ;
gint bem_element_edge_update(BEMElementEdge *e) ;

BEMENodeClass * bem_enode_class  (void);
BEMENode * bem_enode_new (BEMENodeClass * klass, BEMElement *e) ;
GtsGraph *bem_mesh_graph(BEMMesh *m) ;
BEMMesh *bem_mesh_graph_mesh(GtsGraph *g, BEMMesh *m) ;

gint bem_matrix_vector_mul(BEMMatrix m, GtsVector v, GtsVector w) ;
gdouble bem_matrix_det(BEMMatrix m) ;
gint bem_matrix_inverse(BEMMatrix m, BEMMatrix im) ;
d1269 2
a1270 1
#endif /*BEM_H_INCLUDED*/
@
